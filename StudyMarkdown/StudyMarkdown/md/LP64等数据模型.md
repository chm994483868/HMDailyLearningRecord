# 32 位环境（LP32 ILP32）64 位环境（LP64(I32LP64) LLP64 ILP64 SILP64）

**从整文可以看出 pointer 的长度只和机器长度有关，32 位机器下是 32 位，64 位机器下是 64位。**
**从整文可以看出 pointer 的长度只和机器长度有关，32 位机器下是 32 位，64 位机器下是 64位。**
**从整文可以看出 pointer 的长度只和机器长度有关，32 位机器下是 32 位，64 位机器下是 64位。**

## LP64（I32LP64）LLP64 ILP64 SILP64
在 64 位机器上，如果 int 是 32 位，long 是 64 位，pointer 是 64 位，那么该机器就是 **LP64**，其中的 L 表示 long，P 表示 pointer，64 表示 long 和 pointer 都是 64 位的。由于 LP64 下 int 是 32 位，因此 LP64 也叫 **I32LP64**。
类似的还有 **LLP64**(Microsoft Window 专用)，表示 int 是 32 位，long 是 32 位，long long 是 64 位，pointer 是 64 位；**ILP64** 表示 int,long,pointer 都是 64 位；**SILP64** 表示 short,int,long,pointer 都是 64 位。

> 32 位环境涉及 "ILP32" 数据模型，是因为 C 数据类型为 32 位的 int,long,pointer。而 64 位环境使用不同的数据模型，此时的 long 和 pointer 都为 64 位，int 是 32 位， 故称作 "LP64"(也称"I32LP64") 数据模型。

<u>现今所有 64 位的类 Unix 平台均使用 LP64 数据模型，而 64 位 Windows 使用 LLP64 数据模型，除了指针是 64 位，其他基本类型都没有变。</u>

|Data Type|ILP32|LP32|ILP64|LP64|LLP64|
|宏定义|-|-|-|__LP64__|__LLP64__|
|平台|Win32 API / Unix 和 Unix 类的系统 （Linux，Mac OS X）|Win16 API|-|Unix 和 Unix 类的系统 （Linux，Mac OS X)|Win64 API|
|char|8|8|8|8|8|
|short|16|16|16|16|16|
|int|32|32|64|32|32|
|long|32|32|64|64|32|
|long long|64|64|64|64|64|
|pointer|32|32|64|64|64|

在这张表中，LP64，ILP64，LLP64是 64 位平台上的字长模型，ILP32 和LP32 是 32 位平台上的字长模型。
LP64 指 long 和 pointer 是 64 位
ILP64 指 int，long，pointer 是 64 位
LLP64 指 long long 和 pointer 是 64 位，long 是 32 位
ILP32 指 int，long 和 pointer 是 32 位
LP32 指 long 和 pointer 是 32 位

**浮点型话 float 都是 4 字节，double 都是 8 字节。（C中直接写小数，默认是 double 类型）**

这 3 个 64 位模型（LP64、LLP64 和 ILP64）之间的区别在于**非浮点数据类型**。当一个或多个 C 数据类型的宽度从一种模型变换成另外一种模型时，应用程序可能会受到很多方面的影响。
这些影响主要可以分为两类：
+ **数据对象的大小** 编译器按照自然边界对数据类型进行对齐；换而言之，32 位的数据类型在 64 位系统上要按照 32 位边界进行对齐，而 64 位的数据类型在 64 位系统上则要按照 64 位边界进行对齐。这意味着诸如 **结构** 或 **联合** 之类的数据对象的大小在 32 位和 64 位系统上是不同的。
+ **基本数据类型的大小** 通常关于基本数据类型之间关系的假设在 64 位数据模型上都已经无效了。依赖于这些关系的应用程序在 64 位平台上编译也会失败。例如，sizeof (int) = sizeof (long) = sizeof (pointer) 的假设对于 ILP32 数据模型有效，但是对于其他数据模型就无效了

编译器要按照 **自然边界** 对数据类型进行对齐，这意味着编译器会进行 “填充”，从而强制进行这种方式的对齐，就像是在 C 结构和联合中所做的一样。
**结构或联合的成员是根据最宽的成员进行对齐的。**

数据类型转换原则：
自动转换时，占用内存字节数少（值域小）的类型，向占用内存字节数多（值域大）的类型转换，以保证精度不降低。

原则:
1. 对于结构的各个成员，第一个成员位于偏移为0的位置，以后每个数据成员的偏移量必须是 `min(#pragma pack()指定的数，这个数据成员的自身长度)` 的倍数。
2. 在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，对齐将按照`min(#pragma pack()指定的数，结构(或联合)最大数据成员长度）`进行。

**结构体内存对齐，默认对齐原则：**
1. 数据类型对齐值：
        char 型自身对齐值是 1
        short 是 2，int float 是 4，double 是 8（Windows）
        解释：
            char 变量只要一个空余的字节即可存放，
            short 要求起始地址能被 2 整除，不能时要在前一个类型后面补位。
            int、float、double 同理。
2. 结构体的整体对齐：
        其成员中自身对齐值最大的那个值。
        解释：
            结构体最终对齐按照数据成员中最长的类型的整数倍。
**指定对齐原则:**
使用 `#pragma pack` 改变默认对齐原则
格式：
`#pragma pack (value)` 时的指定对齐值 value。
结构体最终对齐按照指定对齐值的整数倍。（指定对齐值时同时影响成员对齐和总体对齐。）
**注意:**
1. value 只能是: 1、2、4、8 等。
2. **指定对齐值与数据类型对齐值相比取较小值。** （这句特别关键❗️❗️❗️）
      如果指定对齐值：
      设为 1: 则 short、int、float 等均为 1。
      设为 2: 则 char 仍为 1，short 为 2，int 也为 2。


**参考链接：**
[LP64是什么意思](https://blog.csdn.net/chaoguo1234/article/details/81277959)
[数据模型（LP32 ILP32 LP64 LLP64 ILP64 ）](https://www.cnblogs.com/lsgxeva/p/7614856.html)


