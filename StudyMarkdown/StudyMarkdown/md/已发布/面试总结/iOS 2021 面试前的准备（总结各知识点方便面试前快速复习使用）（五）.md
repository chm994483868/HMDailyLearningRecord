# iOS 2021 é¢è¯•å‰çš„å‡†å¤‡ï¼ˆæ€»ç»“å„çŸ¥è¯†ç‚¹æ–¹ä¾¿é¢è¯•å‰å¿«é€Ÿå¤ä¹ ä½¿ç”¨ï¼‰ï¼ˆäº”ï¼‰

## 38. å¯¹æ¯”åˆ†æ source0 å’Œ source1ã€‚
&emsp;é¦–å…ˆæˆ‘ä»¬ä»ä»£ç å±‚é¢å¯¹ source0 å’Œ source1 ç‰ˆæœ¬çš„ CFRunLoopSourceRef è¿›è¡ŒåŒºåˆ†ï¼Œstruct \__CFRunLoopSource é€šè¿‡å…¶å†…éƒ¨çš„ \_context æ¥è¿›è¡ŒåŒºåˆ† source0 å’Œ source1ã€‚
```c++
struct __CFRunLoopSource {
    ...
    union {
        CFRunLoopSourceContext version0;   
        CFRunLoopSourceContext1 version1;
    } _context;
};
```
&emsp;å…¶ä¸­ version0ã€version1 åˆ†åˆ«å¯¹åº” source0 å’Œ source1ï¼Œä¸‹é¢æˆ‘ä»¬å†çœ‹ä¸€ä¸‹ CFRunLoopSourceContext å’Œ CFRunLoopSourceContext1 çš„å®šä¹‰ï¼š
```c++
typedef struct {
    ...
    void * info; // ä½œä¸º perform å‡½æ•°çš„å‚æ•°
    ...
    void (*schedule)(void *info, CFRunLoopRef rl, CFStringRef mode); // å½“ source0 åŠ å…¥åˆ° run loop æ—¶è§¦å‘çš„å›è°ƒå‡½æ•°ï¼ˆåœ¨ CFRunLoopAddSource å‡½æ•°ä¸­å¯çœ‹åˆ°å…¶è¢«è°ƒç”¨ï¼‰
    void (*cancel)(void *info, CFRunLoopRef rl, CFStringRef mode); // å½“ source0 ä» run loop ä¸­ç§»é™¤æ—¶è§¦å‘çš„å›è°ƒå‡½æ•°
    
    // source0 è¦æ‰§è¡Œçš„ä»»åŠ¡å—ï¼Œå½“ source0 äº‹ä»¶è¢«è§¦å‘æ—¶çš„å›è°ƒ, è°ƒç”¨ __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ å‡½æ•°æ¥æ‰§è¡Œ perform(info)
    void (*perform)(void *info);
} CFRunLoopSourceContext;
```

```c++
typedef struct {
    ...
    void * info; // ä½œä¸º perform å‡½æ•°çš„å‚æ•°
    ...
#if (TARGET_OS_MAC && !(TARGET_OS_EMBEDDED || TARGET_OS_IPHONE)) || (TARGET_OS_EMBEDDED || TARGET_OS_IPHONE)

    // getPort å‡½æ•°æŒ‡é’ˆï¼Œç”¨äºå½“ source1 è¢«æ·»åŠ åˆ° run loop ä¸­çš„æ—¶å€™ï¼Œä»è¯¥å‡½æ•°ä¸­è·å–å…·ä½“çš„ mach_port_t å¯¹è±¡ï¼Œç”¨æ¥å”¤é†’ run loop
    mach_port_t (*getPort)(void *info);
    
    // perform å‡½æ•°æŒ‡é’ˆå³æŒ‡å‘ run loop è¢«å”¤é†’å source1 è¦æ‰§è¡Œçš„å›è°ƒå‡½æ•°ï¼Œè°ƒç”¨ __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__ å‡½æ•°æ¥æ‰§è¡Œ
    void * (*perform)(void *msg, CFIndex size, CFAllocatorRef allocator, void *info);
#else
    // å…¶å®ƒå¹³å°
    void * (*getPort)(void *info);
    void (*perform)(void *info);
#endif
} CFRunLoopSourceContext1;
```
&emsp;source0 ä»…åŒ…å«ä¸€ä¸ªå›è°ƒå‡½æ•°ï¼ˆperformï¼‰ï¼Œå®ƒå¹¶ä¸èƒ½ä¸»åŠ¨å”¤é†’ run loopï¼ˆè¿›å…¥ä¼‘çœ çš„ run loop ä»…èƒ½é€šè¿‡ mach port å’Œ mach_msg æ¥å”¤é†’ï¼‰ã€‚ä½¿ç”¨æ—¶ï¼Œä½ éœ€è¦å…ˆè°ƒç”¨ CFRunLoopSourceSignal(rls) å°†è¿™ä¸ª source æ ‡è®°ä¸ºå¾…å¤„ç†ï¼Œç„¶åæ‰‹åŠ¨è°ƒç”¨ CFRunLoopWakeUp(rl) æ¥å”¤é†’ run loopï¼ˆCFRunLoopWakeUp å‡½æ•°å†…éƒ¨æ˜¯é€šè¿‡ run loop å®ä¾‹çš„ \_wakeUpPort æˆå‘˜å˜é‡æ¥å”¤é†’ run loop çš„ï¼‰ï¼Œå”¤é†’åçš„ run loop ç»§ç»­æ‰§è¡Œ \__CFRunLoopRun å‡½æ•°å†…éƒ¨çš„å¤–å±‚ do while å¾ªç¯æ¥æ‰§è¡Œ timersï¼ˆæ‰§è¡Œåˆ°è¾¾æ‰§è¡Œæ—¶é—´ç‚¹çš„ timer ä»¥åŠæ›´æ–°ä¸‹æ¬¡æœ€è¿‘çš„æ—¶é—´ç‚¹ï¼‰ å’Œ sources ä»¥åŠ observer å›è°ƒ run loop çŠ¶æ€ï¼Œå…¶ä¸­é€šè¿‡è°ƒç”¨ \__CFRunLoopDoSources0 å‡½æ•°æ¥æ‰§è¡Œ source0 äº‹ä»¶ï¼Œæ‰§è¡Œè¿‡åçš„ source0 ä¼šè¢« \__CFRunLoopSourceUnsetSignaled(rls) æ ‡è®°ä¸ºå·²å¤„ç†ï¼Œåç»­ run loop å¾ªç¯ä¸­ä¸ä¼šå†æ‰§è¡Œæ ‡è®°ä¸ºå·²å¤„ç†çš„ source0ã€‚source0 ä¸åŒäºä¸é‡å¤æ‰§è¡Œçš„ timer å’Œ run loop çš„ block é“¾è¡¨ä¸­çš„ block èŠ‚ç‚¹ï¼Œsource0 æ‰§è¡Œè¿‡åä¸ä¼šè‡ªå·±ä¸»åŠ¨ç§»é™¤ï¼Œä¸é‡å¤æ‰§è¡Œçš„ timer å’Œ block æ‰§è¡Œè¿‡åä¼šè‡ªå·±ä¸»åŠ¨ç§»é™¤ï¼Œæ‰§è¡Œè¿‡åçš„ source0 å¯æ‰‹åŠ¨è°ƒç”¨ CFRunLoopRemoveSource(CFRunLoopGetCurrent(), rls, kCFRunLoopDefaultMode) æ¥ç§»é™¤ã€‚

&emsp;source0 å…·ä½“æ‰§è¡Œæ—¶çš„å‡½æ•°å¦‚ä¸‹ï¼Œinfo åšå‚æ•°æ‰§è¡Œ perform å‡½æ•°ã€‚
```c++
__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(rls->_context.version0.perform, rls->_context.version0.info); // perform(info)
```
&emsp;ä¸‹é¢æ˜¯æˆ‘ä»¬æ‰‹åŠ¨åˆ›å»º source0 çš„ç¤ºä¾‹ä»£ç ï¼Œåˆ›å»ºå¥½çš„ CFRunLoopSourceRef å¿…é¡»è°ƒç”¨ CFRunLoopSourceSignal å‡½æ•°æŠŠå…¶æ ‡è®°ä¸ºå¾…å¤„ç†ï¼Œå¦åˆ™å³ä½¿ run loop æ­£å¸¸å¾ªç¯ï¼Œè¿™é‡Œçš„ rls ä¹Ÿå¾—ä¸åˆ°æ‰§è¡Œï¼Œç”±äº thread çº¿ç¨‹ä¸­çš„è®¡æ—¶å™¨å­˜åœ¨æ‰€ä»¥è¿™é‡Œä¹Ÿå¯ä»¥ä¸ç”¨æ‰‹åŠ¨è°ƒç”¨ CFRunLoopWakeUp å”¤é†’ run loopï¼Œrun loop å·²æ˜¯å”¤é†’çŠ¶æ€ï¼Œrls èƒ½åœ¨ run loop çš„ä¸€ä¸ªå¾ªç¯ä¸­æ­£å¸¸å¾—åˆ°æ‰§è¡Œï¼Œç„¶åæ˜¯å…¶ä¸­çš„ä¸‰ä¸ªæ–­ç‚¹ï¼Œå½“æ‰§è¡Œåˆ°æ–­ç‚¹æ—¶æˆ‘ä»¬åœ¨æ§åˆ¶å°æ‰“å° po [NSRunLoop currentRunLoop] å¯åœ¨ kCFRunLoopDefaultMode çš„ sources0 å“ˆå¸Œè¡¨ä¸­çœ‹åˆ° rlsï¼Œä»¥åŠå®ƒçš„ signalled æ ‡è®°çš„å€¼ï¼Œé€šè¿‡æºç å¯çŸ¥åœ¨ rls çš„ perform å¾…æ‰§è¡Œä¹‹å‰å°±ä¼šå…ˆè°ƒç”¨ \__CFRunLoopSourceUnsetSignaled(rls) æŠŠå…¶æ ‡è®°ä¸ºå·²ç»å¤„ç†ï¼Œä¸”å¤„ç†è¿‡çš„ rls å¹¶ä¸ä¼šä¸»åŠ¨ç§»é™¤ï¼Œå®ƒä¾ç„¶è¢«ä¿å­˜åœ¨ kCFRunLoopDefaultMode çš„ sources0 å“ˆå¸Œè¡¨ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ CFRunLoopRemoveSource å‡½æ•°æ‰‹åŠ¨ç§»é™¤ã€‚source0 ä¸åŒäºä¸é‡å¤æ‰§è¡Œçš„ timer å’Œ run loop çš„ block é“¾è¡¨ä¸­çš„ block èŠ‚ç‚¹ï¼Œsource0 æ‰§è¡Œè¿‡åä¸ä¼šè‡ªå·±ä¸»åŠ¨ç§»é™¤ï¼Œä¸é‡å¤æ‰§è¡Œçš„ timer å’Œ block æ‰§è¡Œè¿‡åè‡ªå·±ä¼šä¸»åŠ¨ç§»é™¤ã€‚

&emsp;è¯è¯´æ˜¯æ‰§è¡Œ source0 æ—¶éœ€è¦æ‰‹åŠ¨è°ƒç”¨ CFRunLoopWakeUp æ¥å”¤é†’ run loopï¼Œå®é™…è§‰å¾—å¥½åƒå¤§éƒ¨åˆ†åœºæ™¯ä¸‹å…¶å®ƒäº‹ä»¶éƒ½ä¼šå¯¼è‡´ run loop æ­£å¸¸è¿›è¡Œç€å¾ªç¯ï¼Œåªè¦ run loop è¿›è¡Œå¾ªç¯åˆ™æ ‡è®°ä¸ºå¾…å¤„ç†çš„ source0 å°±èƒ½å¾—åˆ°æ‰§è¡Œï¼Œå¥½åƒå¹¶ä¸éœ€è¦æˆ‘ä»¬åˆ»æ„çš„æ‰‹åŠ¨è°ƒç”¨ CFRunLoopWakeUp æ¥å”¤é†’å½“å‰çš„ run loopã€‚ 
```c++
- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view.
    NSThread *thread = [[NSThread alloc] initWithBlock:^{
        NSLog(@"ğŸ§—â€â™€ï¸ğŸ§—â€â™€ï¸ ....");
        
        // æ„å»ºä¸‹ä¸‹æ–‡ï¼Œè¿™é‡Œåªæœ‰ä¸‰ä¸ªå‚æ•°æœ‰å€¼ï¼Œ0 æ˜¯ version å€¼ä»£è¡¨æ˜¯ source0ï¼Œinfo åˆ™ç›´æ¥ä¼ çš„ self å³å½“å‰çš„ vcï¼Œschedule å’Œ cancel å·æ‡’äº†ä¼ çš„ NULLï¼Œå®ƒä»¬åˆ†åˆ«æ˜¯
        // æ‰§è¡Œ CFRunLoopAddSource æ·»åŠ  rls å’Œ CFRunLoopRemoveSource ç§»é™¤ rls æ—¶è°ƒç”¨çš„ï¼Œå¤§å®¶å¯ä»¥è‡ªå·±è¯•è¯•ï¼Œ
        // ç„¶åæœ€åæ˜¯æ‰§è¡Œå‡½æ•° perform ä¼ äº† runLoopSourcePerformRoutineã€‚
        CFRunLoopSourceContext context = {0, (__bridge void *)(self), NULL, NULL, NULL, NULL, NULL, NULL, NULL, runLoopSourcePerformRoutine};
        
        CFRunLoopSourceRef rls = CFRunLoopSourceCreate(kCFAllocatorDefault, 0, &context);
        CFRunLoopAddSource(CFRunLoopGetCurrent(), rls, kCFRunLoopDefaultMode);

        // åˆ›å»ºå¥½çš„ rls å¿…é¡»æ‰‹åŠ¨æ ‡è®°ä¸ºå¾…å¤„ç†ï¼Œå¦åˆ™å³ä½¿ run loop æ­£å¸¸å¾ªç¯ä¹Ÿä¸ä¼šæ‰§è¡Œæ­¤ rls
        CFRunLoopSourceSignal(rls); // â¬…ï¸ æ–­ç‚¹ 1
        
        // ç”±äºè®¡æ—¶å™¨ä¸€ç›´åœ¨å¾ªç¯æ‰§è¡Œï¼Œæ‰€ä»¥è¿™é‡Œå¯ä¸éœ€è¦æˆ‘ä»¬æ‰‹åŠ¨å”¤é†’ run loop 
        CFRunLoopWakeUp(CFRunLoopGetCurrent()); // â¬…ï¸ æ–­ç‚¹ 2

        [NSTimer scheduledTimerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) {
            NSLog(@"â°â°â° timer å›è°ƒ...");
            CFRunLoopRemoveSource(CFRunLoopGetCurrent(), rls, kCFRunLoopDefaultMode); // â¬…ï¸ æ–­ç‚¹ 4ï¼ˆè¿™é‡Œæ‰§è¡Œä¸€æ¬¡è®¡æ—¶å™¨å›è°ƒå†æ‰“æ–­ç‚¹ï¼‰
        }];

        [[NSRunLoop currentRunLoop] run]; 
    }];
    
    [thread start];
}

void runLoopSourcePerformRoutine (void *info) {
    NSLog(@"ğŸ‘˜ğŸ‘˜ %@", [NSThread currentThread]); // â¬…ï¸ æ–­ç‚¹ 3
}
```
&emsp;åˆå§‹åˆ›å»ºå®Œæˆçš„ rls çš„ signalled å€¼ä¸º NOï¼Œå¦‚æœæ¥ä¸‹æ¥ä¸æ‰§è¡Œ CFRunLoopSourceSignal(rls) çš„è¯ï¼Œrls æ˜¯ä¸ä¼šè¢« run loop æ‰§è¡Œçš„ã€‚
```c++
// â¬…ï¸ æ–­ç‚¹ 1
...
sources0 = <CFBasicHash 0x282aa55f0 [0x20e729430]>{type = mutable set, count = 1,
entries =>
    1 : <CFRunLoopSource 0x2811f6580 [0x20e729430]>{signalled = No, valid = Yes, order = 0, context = <CFRunLoopSource context>{version = 0, info = 0x139d1c2e0, callout = runLoopSourcePerformRoutine (0x100e929ec)}}
}
...
```
&emsp;CFRunLoopSourceSignal(rls) æ‰§è¡Œåï¼Œçœ‹åˆ° rls çš„ signalled ç½®ä¸º Yesï¼Œåœ¨ run loop å¾ªç¯ä¸­è°ƒç”¨ \__CFRunLoopDoSources0 å‡½æ•°æ—¶ rls ä¼šå¾—åˆ°æ‰§è¡Œã€‚
```c++
// â¬…ï¸ æ–­ç‚¹ 2
...
sources0 = <CFBasicHash 0x282aa55f0 [0x20e729430]>{type = mutable set, count = 1,
entries =>
    1 : <CFRunLoopSource 0x2811f6580 [0x20e729430]>{signalled = Yes, valid = Yes, order = 0, context = <CFRunLoopSource context>{version = 0, info = 0x139d1c2e0, callout = runLoopSourcePerformRoutine (0x100e929ec)}}
}
...
```
&emsp;é€šè¿‡ \__CFRunLoopDoSources0 å‡½æ•°çš„æºç å¯çŸ¥åœ¨ rls çš„ perform å‡½æ•°æ‰§è¡Œä¹‹å‰ \__CFRunLoopSourceUnsetSignaled(rls) å·²ç»æŠŠ rls æ ‡è®°ä¸ºå·²å¤„ç†ã€‚
```c++
// â¬…ï¸ æ–­ç‚¹ 3
...
sources0 = <CFBasicHash 0x282aa55f0 [0x20e729430]>{type = mutable set, count = 1,
entries =>
    1 : <CFRunLoopSource 0x2811f6580 [0x20e729430]>{signalled = No, valid = Yes, order = 0, context = <CFRunLoopSource context>{version = 0, info = 0x139d1c2e0, callout = runLoopSourcePerformRoutine (0x100e929ec)}}
}
...
}
```
&emsp;CFRunLoopRemoveSource(CFRunLoopGetCurrent(), rls, kCFRunLoopDefaultMode) æ‰§è¡Œè¿‡åçœ‹åˆ° rls å·²ç»è¢«ç§»é™¤ï¼Œè¿™é‡Œ source0 ä¸åŒäºä¸é‡å¤æ‰§è¡Œçš„ timer å’Œ run loop çš„ block é“¾è¡¨ä¸­çš„ block èŠ‚ç‚¹ï¼Œsource0 æ‰§è¡Œè¿‡åä¸ä¼šè‡ªå·±ä¸»åŠ¨ç§»é™¤ï¼Œtimer å’Œ block æ‰§è¡Œè¿‡åè‡ªå·±ä¼šä¸»åŠ¨ç§»é™¤ã€‚
```c++
// â¬…ï¸ æ–­ç‚¹ 4
...
sources0 = <CFBasicHash 0x282aa55f0 [0x20e729430]>{type = mutable set, count = 0,
entries =>
}
...
```
&emsp;é’ˆå¯¹ timers/sourcesï¼ˆ0/1ï¼‰ çš„æ‰§è¡Œæµç¨‹ï¼ˆæš‚æ—¶å¿½ç•¥ run loop ä¼‘çœ å’Œ main run loop æ‰§è¡Œï¼Œå…¶å®æææå¤§éƒ¨åˆ†æƒ…å†µæˆ‘ä»¬éƒ½æ˜¯åœ¨ä½¿ç”¨ä¸»çº¿ç¨‹çš„ run loopï¼Œè¿™é‡Œä¸ºäº†åˆ†æ timers/sources æš‚æ—¶å‡è£…æ˜¯åœ¨å­çº¿ç¨‹çš„ run loop ä¸­ï¼‰æˆ‘ä»¬è¿™é‡Œå†å›é¡¾ä¸€ä¸‹ \__CFRunLoopRun å‡½æ•°ï¼Œä» \__CFRunLoopRun å‡½æ•°çš„å¤–å±‚ do while å¾ªç¯å¼€å§‹ï¼Œé¦–å…ˆè¿›æ¥ä¼šè¿ç€å›è°ƒ kCFRunLoopBeforeTimers å’Œ kCFRunLoopBeforeSources ä¸¤ä¸ª run loop çš„æ´»åŠ¨å˜åŒ–ï¼Œç„¶åæ¥ä¸‹æ¥å°±æ˜¯è°ƒç”¨ \__CFRunLoopDoSources0(rl, rlm, stopAfterHandle) æ¥æ‰§è¡Œ source0ï¼Œå¦‚æœæœ‰ source0 è¢«æ‰§è¡Œäº†ï¼Œåˆ™ sourceHandledThisLoop ä¸º Trueï¼Œå°±ä¸ä¼šå›è°ƒ kCFRunLoopBeforeWaiting å’Œ kCFRunLoopAfterWaiting ä¸¤ä¸ªæ´»åŠ¨å˜åŒ–ã€‚æ¥ç€æ˜¯æ ¹æ®å½“å‰ run loop çš„æœ¬æ¬¡å¾ªç¯è¢«æŸä¸ª mach port å”¤é†’çš„ï¼ˆ\__CFRunLoopServiceMachPort(waitSet, &msg, sizeof(msg_buffer), &livePort, poll ? 0 : TIMEOUT_INFINITY, &voucherState, &voucherCopy) å”¤é†’æœ¬æ¬¡ run loop çš„ mach port ä¼šè¢«èµ‹å€¼åˆ° livePort ä¸­ï¼‰æ¥å¤„ç†å…·ä½“çš„å†…å®¹ï¼Œå‡å¦‚æ˜¯ rlm->_timerPortï¼ˆæˆ– modeQueuePort å®ƒä¸¤ç­‰åŒåªæ˜¯é’ˆå¯¹ä¸åŒçš„å¹³å°ä¸åŒçš„ timer ä½¿ç”¨æ–¹å¼ï¼‰å”¤é†’çš„åˆ™è°ƒç”¨ \__CFRunLoopDoTimers(rl, rlm, mach_absolute_time()) æ¥æ‰§è¡Œ timer çš„å›è°ƒï¼Œå¦‚æœè¿˜æœ‰å…¶å®ƒ timer æˆ–è€… timer é‡å¤æ‰§è¡Œçš„è¯ä¼šè°ƒç”¨ \__CFArmNextTimerInMode(rlm, rl) æ¥æ›´æ–°æ³¨å†Œä¸‹æ¬¡æœ€è¿‘çš„ timer çš„è§¦å‘æ—¶é—´ã€‚  æœ€åçš„è¯å°±æ˜¯ source1 çš„ç«¯å£äº†ï¼Œé¦–å…ˆé€šè¿‡ CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort)ï¼ˆå†…éƒ¨æ˜¯ CFRunLoopSourceRef found = rlm->_portToV1SourceMap ? (CFRunLoopSourceRef)CFDictionaryGetValue(rlm->_portToV1SourceMap, (const void *)(uintptr_t)port) : NULL;ï¼Œå³ä» rlm çš„ \_portToV1SourceMap å­—å…¸ä¸­ä»¥ livePort ä¸º Key æ‰¾åˆ°å¯¹åº”çš„ CFRunLoopSourceRefï¼‰æ¥æ‰¾åˆ° livePort æ‰€å¯¹åº”çš„å…·ä½“çš„ rlsï¼ˆsource1ï¼‰ï¼Œç„¶åæ˜¯è°ƒç”¨ \__CFRunLoopDoSource1(rl, rlm, rls, msg, msg->msgh_size, &reply) æ¥æ‰§è¡Œ rls çš„å›è°ƒï¼Œå†…éƒ¨å…·ä½“çš„æ‰§è¡Œæ˜¯ \_\_CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION\_\_(rls->_context.version1.perform, msg, size, reply, rls->_context.version1.info) å³åŒæ ·æ˜¯ info åšå‚æ•°æ‰§è¡Œ perform å‡½æ•°ï¼Œä¸”åœ¨ä¸´è¿‘æ‰§è¡Œå‰åŒæ ·ä¼šè°ƒç”¨ \__CFRunLoopSourceUnsetSignaled(rls) æŠŠ source1 æ ‡è®°ä¸ºå·²å¤„ç†ï¼Œä¸”åŒ soure0 ä¸€æ ·ä¹Ÿä¸ä¼šä¸»åŠ¨ä» rlm çš„ sources1 å“ˆå¸Œè¡¨ä¸­ä¸»åŠ¨ç§»é™¤ã€‚ï¼ˆsource1 ç³»ç»Ÿä¼šè‡ªåŠ¨ signaledï¼‰

&emsp; Source1 åŒ…å«äº†ä¸€ä¸ª mach portï¼ˆç”± CFRunLoopSourceRef åˆ›å»ºæ—¶çš„ CFRunLoopSourceContext1 ä¼ å…¥ï¼‰ å’Œä¸€ä¸ªå›è°ƒï¼ˆCFRunLoopSourceContext1 çš„ perform å‡½æ•°æŒ‡é’ˆï¼‰ï¼Œè¢«ç”¨äºé€šè¿‡å†…æ ¸å’Œå…¶å®ƒçº¿ç¨‹ç›¸äº’å‘é€æ¶ˆæ¯ï¼ˆmach_msgï¼‰ï¼Œè¿™ç§ Source èƒ½ä¸»åŠ¨å”¤é†’ run loop çš„çº¿ç¨‹ã€‚

&emsp;Source1 åŒ…å«çš„ mach port æ¥è‡ªäºåˆ›å»º source1 æ—¶ CFRunLoopSourceContext1 çš„ info æˆå‘˜å˜é‡ï¼ŒCFRunLoopSourceRef é€šè¿‡ \_context  çš„ info æŒæœ‰ mach portï¼ŒåŒæ—¶ä»¥ CFRunLoopSourceRef ä¸º Keyï¼Œä»¥ mach port ä¸º Value ä¿å­˜åœ¨ rlm çš„ \_portToV1SourceMap ä¸­ï¼Œå¹¶ä¸”ä¼šæŠŠè¯¥ mach port æ’å…¥åˆ° rlm çš„ \_portSet ä¸­ã€‚å¦‚ä¸‹ä»£ç æ‘˜å½•è‡ª CFRunLoopAddSource å‡½æ•°ä¸­ï¼š
```c++
...
} else if (1 == rls->_context.version0.version) {
    // æŠŠ rls æ·»åŠ åˆ° rlm çš„ _sources1 é›†åˆä¸­
    CFSetAddValue(rlm->_sources1, rls);
    
    // ä»¥ info ä¸ºå‚ï¼Œè°ƒç”¨ rls->_context.version1.getPort å‡½æ•°è¯»å‡º mach port
    // åŸºäº CFMachPort åˆ›å»ºçš„ CFRunLoopSourceRef å…¶ context çš„ getPort æŒ‡é’ˆè¢«èµ‹å€¼ä¸º __CFMachPortGetPort å‡½æ•°ï¼ˆiOS ä¸‹ä»…èƒ½ä½¿ç”¨ CFMachPortï¼Œä¸èƒ½ä½¿ç”¨ CFMessagePortï¼‰
    // åŸºäº CFMessagePort åˆ›å»ºçš„ CFRunLoopSourceRef å…¶ context çš„ getPort æŒ‡é’ˆè¢«èµ‹å€¼ä¸º __CFMessagePortGetPort å‡½æ•°ï¼ˆmacOS ä¸‹å¯ç”¨ CFMessagePortï¼‰
    __CFPort src_port = rls->_context.version1.getPort(rls->_context.version1.info);
    
    if (CFPORT_NULL != src_port) {
        // æŠŠ rls å’Œ src_port ä¿å­˜åœ¨ rlm çš„ _portToV1SourceMap å­—å…¸ä¸­
        CFDictionarySetValue(rlm->_portToV1SourceMap, (const void *)(uintptr_t)src_port, rls);
        // æŠŠ src_port æ’å…¥åˆ° rlm çš„ _portSet ä¸­
        __CFPortSetInsert(src_port, rlm->_portSet);
    }
}
...
```
&emsp;å¯çœ‹åˆ° source0 ä¸­ä»…æœ‰ä¸€äº›å›è°ƒå‡½æ•°ï¼ˆperform å‡½æ•°æŒ‡é’ˆï¼‰ä¼šåœ¨ run loop çš„æœ¬æ¬¡å¾ªç¯ä¸­æ‰§è¡Œï¼Œè€Œ source1 ä¸­æœ‰ mach port å¯ç”¨æ¥ä¸»åŠ¨å”¤é†’ run loop åæ‰§è¡Œ source1 ä¸­çš„å›è°ƒå‡½æ•°ï¼ˆperform å‡½æ•°æŒ‡é’ˆï¼‰ï¼Œå³ source1 åˆ›å»ºæ—¶ä¼šæœ‰ mach port ä¼ å…¥ï¼Œç„¶åå½“é€šè¿‡ mach_msg å‡½æ•°å‘è¿™ä¸ª mach port å‘æ¶ˆæ¯æ—¶ï¼Œå½“å‰çš„ run loop å°±ä¼šè¢«å”¤é†’æ¥æ‰§è¡Œè¿™ä¸ª source1 äº‹ä»¶ï¼Œä½†æ˜¯ source0 åˆ™æ˜¯ä¾èµ–äºç”± â€œåˆ«äººâ€ æ¥å”¤é†’ run loopï¼Œä¾‹å¦‚ç”±å¼€å‘è€…æ‰‹åŠ¨è°ƒç”¨ CFRunLoopWakeUp å‡½æ•°æ¥å”¤é†’ run loopï¼Œæˆ–è€…ç”± source1 å”¤é†’ run loop åï¼Œåœ¨å½“å‰ run loop çš„æœ¬æ¬¡å¾ªç¯ä¸­è¢«æ ‡è®°ä¸ºå¾…å¤„ç†çš„ source0 ä¹Ÿè¶æœºå¾—åˆ°æ‰§è¡Œã€‚ 

&emsp;source1 ç”± run loop å’Œå†…æ ¸ç®¡ç†ï¼Œmach port é©±åŠ¨ã€‚ source0 åˆ™åå‘åº”ç”¨å±‚ä¸€äº›ï¼Œå¦‚ Cocoa é‡Œé¢çš„ UIEvent å¤„ç†ï¼Œä¼šä»¥ source0 çš„å½¢å¼å‘é€ç»™ main run loopã€‚

&emsp;ç¿»çœ‹äº†å‡ ç¯‡åšå®¢åå‘ç°æ‰‹åŠ¨å”¤é†’ run loop é€‚ç”¨çš„åœºæ™¯å¯ä»¥æ˜¯åœ¨ä¸»çº¿ç¨‹ä¸­å”¤é†’ä¼‘çœ ä¸­çš„å­çº¿ç¨‹ã€‚åªè¦èƒ½æ‹¿åˆ°å­çº¿ç¨‹çš„ run loop å¯¹è±¡å°±èƒ½é€šè¿‡è°ƒç”¨ CFRunLoopWakeUp å‡½æ•°æ¥å”¤é†’æŒ‡å®šçš„å­çº¿ç¨‹ï¼Œå”¤é†’çš„æ–¹å¼æ˜¯è°ƒç”¨ mach_msg å‡½æ•°å‘å­çº¿ç¨‹çš„ run loop å¯¹è±¡çš„ \_weakUpPort å‘é€æ¶ˆæ¯å³å¯ã€‚ä¸‹é¢æˆ‘ä»¬çœ‹ä¸€ä¸‹æŒºç®€çŸ­çš„æºç ã€‚

&emsp;CFRunLoopWakeUp å‡½æ•°å®šä¹‰å¦‚ä¸‹ï¼Œåªéœ€è¦ä¸€ä¸ªæˆ‘ä»¬æƒ³è¦å”¤é†’çš„çº¿ç¨‹çš„ run loop å¯¹è±¡ã€‚
```c++
void CFRunLoopWakeUp(CFRunLoopRef rl) {
    CHECK_FOR_FORK();
    // This lock is crucial to ignorable wakeups, do not remove it.
    
    // CFRunLoopRef åŠ é”
    __CFRunLoopLock(rl);
    
    // å¦‚æœ rl å·²ç»è¢«æ ‡è®°ä¸º "å¿½ç•¥å”¤é†’"ï¼Œåˆ™ç›´æ¥è§£é” returnï¼Œ
    // å…¶å®å½“ rl æœ‰è¿™ä¸ª "å¿½ç•¥å”¤é†’" çš„æ ‡è®°æ—¶ä»£è¡¨çš„æ˜¯ rl æ­¤æ—¶å·²ç»æ˜¯å”¤é†’çŠ¶æ€äº†ï¼Œæ‰€ä»¥æœ¬æ¬¡å”¤é†’æ“ä½œå¯ä»¥å¿½ç•¥ã€‚
    // å…¨å±€æœç´¢ __CFRunLoopSetIgnoreWakeUps è®¾ç½® "å¿½ç•¥å”¤é†’" æ ‡è®°çš„å‡½æ•°ï¼Œ
    // å¯å‘ç°å…¶è°ƒç”¨éƒ½æ˜¯åœ¨ __CFRunLoopRun å‡½æ•°ä¸­ run loop å”¤é†’ä¹‹å‰ï¼Œç”¨æ¥æ ‡è®° run loop æ­¤æ—¶æ˜¯å”¤é†’çŠ¶æ€ã€‚ 
    if (__CFRunLoopIsIgnoringWakeUps(rl)) {
        __CFRunLoopUnlock(rl);
        return;
    }
    
#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI
    kern_return_t ret;
    
    /* We unconditionally try to send the message, since we don't want to lose a wakeup,
    but the send may fail if there is already a wakeup pending, since the queue length is 1. */
    
    // __CFSendTrivialMachMessage å‡½æ•°å†…éƒ¨æ­£æ˜¯è°ƒç”¨ mach_msg å‘ rl->_wakeUpPort ç«¯å£å‘é€æ¶ˆæ¯
    ret = __CFSendTrivialMachMessage(rl->_wakeUpPort, 0, MACH_SEND_TIMEOUT, 0);
    // å‘é€ä¸æˆåŠŸä¸”ä¸æ˜¯è¶…æ—¶ï¼Œåˆ™ crash
    if (ret != MACH_MSG_SUCCESS && ret != MACH_SEND_TIMED_OUT) CRASH("*** Unable to send message to wake up port. (%d) ***", ret);
    
#elif DEPLOYMENT_TARGET_WINDOWS
    SetEvent(rl->_wakeUpPort);
#endif
    // CFRunLoopRef è§£é”
    __CFRunLoopUnlock(rl);
}
```
&emsp;å¦‚æ­¤ï¼Œä¸»çº¿ç¨‹é€šè¿‡è°ƒç”¨ CFRunLoopWakeUp(rl) æ¥å”¤é†’å­çº¿ç¨‹çš„ run loopï¼Œé‚£ä¹ˆæ·»åŠ åˆ°å­çº¿ç¨‹ä¸­çš„æ ‡è®°ä¸ºå¾…å¤„ç†çš„ source0 å°±èƒ½å¾—åˆ°æ‰§è¡Œäº†ã€‚

&emsp;Cocoa Foundation å’Œ Core Foundation ä¸ºä½¿ç”¨ä¸ç«¯å£ç›¸å…³çš„å¯¹è±¡å’Œå‡½æ•°åˆ›å»ºåŸºäºç«¯å£çš„è¾“å…¥æºï¼ˆsource1ï¼‰æä¾›å†…ç½®æ”¯æŒã€‚ä¾‹å¦‚ï¼Œåœ¨ Cocoa Foundation ä¸­ï¼Œæˆ‘ä»¬æ ¹æœ¬ä¸éœ€è¦ç›´æ¥åˆ›å»º source1ï¼Œåªéœ€åˆ›å»ºä¸€ä¸ªç«¯å£å¯¹è±¡ï¼Œå¹¶ä½¿ç”¨ NSRunLoop  çš„å®ä¾‹æ–¹æ³•å°†è¯¥ç«¯å£æ·»åŠ åˆ° run loop ä¸­ã€‚port å¯¹è±¡ä¼šå¤„ç†æ‰€éœ€ source1 çš„åˆ›å»ºå’Œé…ç½®ã€‚å¦‚ä¸‹ä»£ç åœ¨å­çº¿ç¨‹ä¸­:
```c++
NSPort *port = [NSPort port];
[[NSRunLoop currentRunLoop] addPort:port forMode:NSDefaultRunLoopMode];
```
&emsp;å³å¯åœ¨å½“å‰ run loop çš„ NSDefaultRunLoopMode æ¨¡å¼çš„ sources1 é›†åˆä¸­æ·»åŠ ä¸€ä¸ª source1ï¼Œæ­¤æ—¶åªè¦åœ¨ä¸»çº¿ç¨‹ä¸­èƒ½æ‹¿åˆ° port æˆ‘ä»¬å°±å¯ä»¥å®ç°ä¸»çº¿å’Œå­çº¿çš„é€šä¿¡ï¼ˆå”¤é†’å­çº¿ç¨‹ï¼‰ã€‚

&emsp;åœ¨ä¸Šé¢ç¤ºä¾‹ä»£ç ä¸­æ‰“ä¸€ä¸ªæ–­ç‚¹ï¼Œç„¶ååœ¨æ§åˆ¶å°æ‰§è¡Œ po [NSRunLoop currentRunLoop]ï¼Œå¯çœ‹åˆ° kCFRunLoopDefaultMode æ¨¡å¼çš„ sources1 å“ˆå¸Œè¡¨ä¸­å¤šäº†ä¸€ä¸ª source1: 
```c++
...
sources1 = <CFBasicHash 0x28148ebe0 [0x20e729430]>{type = mutable set, count = 1,
entries =>
    2 : <CFRunLoopSource 0x282fd9980 [0x20e729430]>{signalled = No, valid = Yes, order = 200, context = <CFMachPort 0x282ddca50 [0x20e729430]>{valid = Yes, port = a20b, source = 0x282fd9980, callout = __NSFireMachPort (0x1df1ee1f0), context = <CFMachPort context 0x28148ec70>}}
}
...
```
&emsp;åœ¨ Core Foundation ä¸­åˆ™å¿…é¡»æ‰‹åŠ¨åˆ›å»ºç«¯å£åŠå…¶ source1ã€‚åœ¨è¿™ä¸¤ç§æƒ…å†µä¸‹ï¼Œéƒ½ä½¿ç”¨ä¸ç«¯å£ä¸é€æ˜ç±»å‹ï¼ˆCFMachPortRefã€CFMessagePortRef æˆ– CFSocketRefï¼‰ç›¸å…³è”çš„å‡½æ•°æ¥åˆ›å»ºé€‚å½“çš„å¯¹è±¡ã€‚

***

## 39. run loop ä¸äº‹ä»¶å¤„ç†ã€‚
&emsp;ç”¨æˆ·è§¦å‘äº‹ä»¶ï¼Œ IOKit.framework ç”Ÿæˆä¸€ä¸ª IOHIDEvent äº‹ä»¶å¹¶ç”± SpringBoard æ¥æ”¶ï¼ŒSpringBoard ä¼šåˆ©ç”¨ mach portï¼Œäº§ç”Ÿ source1ï¼Œæ¥å”¤é†’ç›®æ ‡ APP çš„ com.apple.uikit.eventfetch-thread çš„ RunLoopã€‚Eventfetch thread ä¼šå°† main runloop ä¸­ \__handleEventQueue æ‰€å¯¹åº”çš„ source0 è®¾ç½®ä¸º signalled == Yes çŠ¶æ€ï¼ŒåŒæ—¶å”¤é†’ main RunLoopã€‚mainRunLoop åˆ™è°ƒç”¨ \__handleEventQueue è¿›è¡Œäº‹ä»¶é˜Ÿåˆ—å¤„ç†ã€‚

&emsp;æ¥ä¸‹æ¥æˆ‘ä»¬é¡ºç€åˆšåˆšçš„äº‹ä»¶å“åº”çš„è¿‡ç¨‹å†ç»†åŒ–ä¸€ä¸ªåˆ†æ”¯ã€‚æˆ‘ä»¬å½“å‰çš„ App è¿›ç¨‹æ¥æ”¶åˆ°äº‹ä»¶ä»¥åï¼ˆSpringBoard åªæ¥æ”¶æŒ‰é”®(é”å±/é™éŸ³ç­‰)ã€è§¦æ‘¸ã€åŠ é€Ÿã€æ¥è¿‘ä¼ æ„Ÿå™¨ç­‰å‡ ç§ Eventï¼Œéšåç”¨ mach port è½¬å‘ç»™éœ€è¦çš„ App è¿›ç¨‹ï¼‰ï¼Œä¼šè°ƒç”¨ \__eventFetcherSourceCallback å’Œ \__eventQueueSourceCallback è¿›è¡Œåº”ç”¨å†…éƒ¨åˆ†å‘ï¼Œæ­¤æ—¶ä¼šå¯¹äº‹ä»¶åšä¸€ä¸ªç»†åŒ–ï¼Œä¼šæŠŠ IOHIDEvent å¤„ç†å¹¶åŒ…è£…æˆ UIEvent è¿›è¡Œå¤„ç†æˆ–åˆ†å‘ï¼Œå…¶ä¸­åŒ…æ‹¬è¯†åˆ« UIGesture/å¤„ç†å±å¹•æ—‹è½¬/å‘é€ç»™ UIWindow ç­‰ã€‚é€šå¸¸äº‹ä»¶æ¯”å¦‚ UIButton ç‚¹å‡»ã€touchesBegin/Move/End/Cancel äº‹ä»¶éƒ½æ˜¯åœ¨è¿™ä¸ªå›è°ƒä¸­å®Œæˆçš„ã€‚

***

## 40. run loop ä¸æ‰‹åŠ¿è¯†åˆ«ã€‚
&emsp;å½“ä¸Šé¢çš„ \_UIApplicationHandleEventQueue() è¯†åˆ«äº†ä¸€ä¸ªæ‰‹åŠ¿æ—¶ï¼Œå…¶é¦–å…ˆä¼šè°ƒç”¨ Cancel å°†å½“å‰çš„ touchesBegin/Move/End ç³»åˆ—å›è°ƒæ‰“æ–­ã€‚éšåç³»ç»Ÿå°†å¯¹åº”çš„ UIGestureRecognizer æ ‡è®°ä¸ºå¾…å¤„ç†ã€‚

&emsp;è‹¹æœæ³¨å†Œäº†ä¸€ä¸ª Observer ç›‘æµ‹ BeforeWaiting (Loop å³å°†è¿›å…¥ä¼‘çœ ) äº‹ä»¶ï¼Œè¿™ä¸ª Observer çš„å›è°ƒå‡½æ•°æ˜¯ \_UIGestureRecognizerUpdateObserver()ï¼Œå…¶å†…éƒ¨ä¼šè·å–æ‰€æœ‰åˆšè¢«æ ‡è®°ä¸ºå¾…å¤„ç†çš„ GestureRecognizerï¼Œå¹¶æ‰§è¡Œ GestureRecognizer çš„å›è°ƒã€‚

&emsp;å½“æœ‰ UIGestureRecognizer çš„å˜åŒ–(åˆ›å»º/é”€æ¯/çŠ¶æ€æ”¹å˜)æ—¶ï¼Œè¿™ä¸ªå›è°ƒéƒ½ä¼šè¿›è¡Œç›¸åº”å¤„ç†ã€‚

## 41. run loop ä¸ç•Œé¢åˆ·æ–°ã€‚
&emsp;å½“åœ¨æ“ä½œ UI æ—¶ï¼Œæ¯”å¦‚æ”¹å˜äº† Frameã€æ›´æ–°äº† UIView/CALayer çš„å±‚æ¬¡æ—¶ï¼Œæˆ–è€…æ‰‹åŠ¨è°ƒç”¨äº† UIView/CALayer çš„ setNeedsLayout/setNeedsDisplay æ–¹æ³•åï¼Œè¿™ä¸ª UIView/CALayer å°±è¢«æ ‡è®°ä¸ºå¾…å¤„ç†ï¼Œå¹¶è¢«æäº¤åˆ°ä¸€ä¸ªå…¨å±€çš„å®¹å™¨å»ã€‚

&emsp;è‹¹æœæ³¨å†Œäº†ä¸€ä¸ª Observer ç›‘å¬ BeforeWaiting(å³å°†è¿›å…¥ä¼‘çœ ) å’Œ Exit (å³å°†é€€å‡º Loop) äº‹ä»¶ï¼Œå›è°ƒå»æ‰§è¡Œä¸€ä¸ªå¾ˆé•¿çš„å‡½æ•°ï¼š\_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()ã€‚è¿™ä¸ªå‡½æ•°é‡Œä¼šéå†æ‰€æœ‰å¾…å¤„ç†çš„ UIView/CAlayer ä»¥æ‰§è¡Œå®é™…çš„ç»˜åˆ¶å’Œè°ƒæ•´ï¼Œå¹¶æ›´æ–° UI ç•Œé¢ã€‚

&emsp;è¿™ä¸ªå‡½æ•°å†…éƒ¨çš„è°ƒç”¨æ ˆå¤§æ¦‚æ˜¯è¿™æ ·çš„ï¼š
```c++
_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()
QuartzCore:CA::Transaction::observer_callback:
    CA::Transaction::commit();
        CA::Context::commit_transaction();
            CA::Layer::layout_and_display_if_needed();
                CA::Layer::layout_if_needed();
                    [CALayer layoutSublayers];
                        [UIView layoutSubviews];
                CA::Layer::display_if_needed();
                    [CALayer display];
                        [UIView drawRect];
```

&emsp;åœ¨æ§åˆ¶å°æ‰“å° main run loopï¼Œåœ¨å…¶ kCFRunLoopDefaultModeã€UITrackingRunLoopModeã€kCFRunLoopCommonModes æ¨¡å¼ä¸‹éƒ½æœ‰åŒä¸€ä¸ªå›è°ƒå‡½æ•°æ˜¯ \_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv çš„ CFRunLoopObserverï¼Œå…¶ activities å€¼ä¸º 0xa0ï¼ˆkCFRunLoopBeforeWaiting | kCFRunLoopExitï¼‰ï¼Œè¡¨ç¤ºåªç›‘å¬ main run loop çš„ä¼‘çœ å‰å’Œé€€å‡ºçŠ¶æ€ã€‚å…¶ order = 2000000 æ¯”ä¸Šé¢çš„æ‰‹åŠ¿è¯†åˆ«çš„ order = 0 çš„ CFRunLoopObserver çš„ä¼˜å…ˆçº§è¦ä½ã€‚

&emsp;å½“æˆ‘ä»¬éœ€è¦ç•Œé¢åˆ·æ–°ï¼Œå¦‚ UIView/CALayer è°ƒç”¨äº† setNeedsLayout/setNeedsDisplayï¼Œæˆ–æ›´æ–°äº† UIView çš„ frameï¼Œæˆ– UI å±‚æ¬¡ã€‚ 
å…¶å®ï¼Œç³»ç»Ÿå¹¶ä¸ä¼šç«‹åˆ»å°±å¼€å§‹åˆ·æ–°ç•Œé¢ï¼Œè€Œæ˜¯å…ˆæäº¤ UI åˆ·æ–°è¯·æ±‚ï¼Œå†ç­‰åˆ°ä¸‹ä¸€æ¬¡ main run loop å¾ªç¯æ—¶ï¼Œé›†ä¸­å¤„ç†ï¼ˆé›†ä¸­å¤„ç†çš„å¥½å¤„åœ¨äºå¯ä»¥åˆå¹¶ä¸€äº›é‡å¤æˆ–çŸ›ç›¾çš„ UI åˆ·æ–°ï¼‰ã€‚è€Œè¿™ä¸ªå®ç°æ–¹å¼ï¼Œåˆ™æ˜¯é€šè¿‡ç›‘å¬ main run loop çš„ before waitting å’Œ Exit é€šçŸ¥å®ç°çš„ã€‚

&emsp;\_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv å†…éƒ¨ä¼šè°ƒç”¨ CA::Transaction::observer_callback(__CFRunLoopObserver*, unsigned long, void*) åœ¨è¯¥å‡½æ•°ä¸­ï¼Œä¼šå°†æ‰€æœ‰çš„ç•Œé¢åˆ·æ–°è¯·æ±‚æäº¤ï¼Œåˆ·æ–°ç•Œé¢ï¼Œä»¥åŠè°ƒç”¨ç›¸å…³å›è°ƒã€‚

***

## 42. run loop ä¸å¡é¡¿ç›‘æµ‹ã€‚
&emsp;å¡é¡¿çš„å‘ˆç°æ–¹å¼å¤§æ¦‚å¯ä»¥ç†è§£ä¸ºæˆ‘ä»¬è§¦æ‘¸å±å¹•æ—¶ç³»ç»Ÿå›é¦ˆä¸åŠæ—¶æˆ–è€…è¿ç»­æ»‘åŠ¨å±å¹•æ—¶è‚‰çœ¼å¯è§çš„æ‰å¸§ï¼Œå›å½’åˆ°ç¨‹åºå±‚é¢çš„è¯å¯çŸ¥è¿™äº›æ„ŸçŸ¥çš„æ¥æºéƒ½æ˜¯ä¸»çº¿ç¨‹ï¼Œè€Œåˆ†ææœ‰æ²¡æœ‰å¡é¡¿å‘ç”Ÿåˆ™å¯ä»¥ä»ä¸»çº¿ç¨‹çš„ run loop å…¥æ‰‹ï¼Œå¯ä»¥é€šè¿‡ç›‘å¬ main run loop çš„æ´»åŠ¨å˜åŒ–ï¼Œä»è€Œå‘ç°ä¸»çº¿ç¨‹çš„è°ƒç”¨æ–¹æ³•å †æ ˆä¸­æ˜¯å¦æŸäº›æ–¹æ³•æ‰§è¡Œæ—¶é—´è¿‡é•¿è€Œå¯¼è‡´äº† run loop å¾ªç¯å‘¨æœŸè¢«æ‹‰é•¿ç»§è€Œå‘ç”Ÿäº†å¡é¡¿ï¼Œæ‰€ä»¥ç›‘æµ‹å¡é¡¿çš„æ–¹æ¡ˆæ˜¯ï¼š**é€šè¿‡ç›‘æ§ main run loop ä» kCFRunLoopBeforeSourcesï¼ˆæˆ–è€… kCFRunLoopBeforeTimersï¼‰ åˆ° kCFRunLoopAfterWaiting  çš„æ´»åŠ¨å˜åŒ–æ‰€ç”¨æ—¶é—´æ˜¯å¦è¶…è¿‡äº†æˆ‘ä»¬é¢„å®šçš„é˜ˆå€¼è¿›è€Œåˆ¤æ–­æ˜¯å¦å‡ºç°äº†å¡é¡¿ï¼Œå½“å‡ºç°å¡é¡¿æ—¶å¯ä»¥è¯»å‡ºå½“å‰å‡½æ•°è°ƒç”¨å †æ ˆå¸®åŠ©æˆ‘ä»¬æ¥åˆ†æä»£ç é—®é¢˜ã€‚**

&emsp;é¦–å…ˆç»™ main run loop æ·»åŠ ä¸€ä¸ª CFRunLoopObserverRef runLoopObserver æ¥å¸®åŠ©æˆ‘ä»¬ç›‘å¬ä¸»çº¿ç¨‹çš„æ´»åŠ¨çŠ¶æ€å˜åŒ–ï¼Œç„¶ååˆ›å»ºä¸€æ¡å­çº¿ç¨‹åœ¨å­çº¿ç¨‹é‡Œé¢ç”¨ä¸€ä¸ªæ­»å¾ªç¯ while(YES) æ¥ç­‰å¾…ç€ä¸»çº¿ç¨‹çš„çŠ¶æ€å˜åŒ–ï¼Œç­‰å¾…çš„æ–¹å¼æ˜¯åœ¨å­çº¿ç¨‹çš„ while å¾ªç¯å†…éƒ¨ç”¨ `long dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)` å‡½æ•°ï¼Œå®ƒçš„ timeout å‚æ•°åˆšå¥½å¯ä»¥è®¾ç½®ä¸€ä¸ªæˆ‘ä»¬æƒ³è¦è§‚å¯Ÿçš„ main run loop çš„ä¸åŒçš„æ´»åŠ¨çŠ¶æ€å˜åŒ–ä¹‹é—´çš„æ—¶é—´é•¿åº¦ï¼Œå½“ dispatch_semaphore_wait å‡½æ•°è¿”å›é 0 å€¼æ—¶è¡¨ç¤ºç­‰å¾…çš„æ—¶é—´è¶…è¿‡äº† timeoutï¼Œæ‰€ä»¥æˆ‘ä»¬åªéœ€è¦å…³æ³¨ dispatch_semaphore_wait å‡½æ•°è¿”å›é 0 å€¼çš„æƒ…å†µã€‚æˆ‘ä»¬ä½¿ç”¨ HCCMonitor çš„å•ä¾‹å¯¹è±¡åœ¨ runLoopObserver çš„å›è°ƒå‡½æ•°å’Œå­çº¿ç¨‹ä¹‹é—´è¿›è¡Œ "ä¼ å€¼"ï¼Œå½“ runLoopObserver çš„å›è°ƒå‡½æ•°æ‰§è¡Œæ—¶æˆ‘ä»¬è°ƒç”¨ dispatch_semaphore_signal å‡½æ•°ç»“æŸå­çº¿ç¨‹ while å¾ªç¯ä¸­çš„ dispatch_semaphore_wait ç­‰å¾…ï¼ŒåŒæ—¶ä½¿ç”¨å•ä¾‹å¯¹è±¡çš„ runLoopActivity æˆå‘˜å˜é‡è®°å½• main run loop æœ¬æ¬¡å˜åŒ–çš„æ´»åŠ¨çŠ¶æ€å€¼ï¼Œç„¶åå¦‚æœå­çº¿ç¨‹çš„ while å¾ªç¯ä¸­è¿ç»­ä¸‰æ¬¡å‡ºç° kCFRunLoopBeforeSources æˆ–è€…  kCFRunLoopAfterWaiting çŠ¶æ€å˜åŒ–ç­‰å¾…è¶…æ—¶äº†ï¼Œé‚£ä¹ˆå°±å¯è®¤ä¸ºæ˜¯ä¸»çº¿ç¨‹å¡é¡¿äº†ã€‚

&emsp;ç›‘æµ‹ kCFRunLoopBeforeSources æˆ–è€… kCFRunLoopAfterWaiting ä¸¤ä¸ªæ´»åŠ¨çŠ¶æ€å˜åŒ–ï¼Œå³ä¸€æ—¦å‘ç°è¿›å…¥ç¡çœ å‰çš„ kCFRunLoopBeforeSources çŠ¶æ€ï¼Œæˆ–è€…å”¤é†’åçš„çŠ¶æ€ kCFRunLoopAfterWaitingï¼Œåœ¨è®¾ç½®çš„æ—¶é—´é˜ˆå€¼å†…ä¸€ç›´æ²¡æœ‰å˜åŒ–ï¼Œå³å¯åˆ¤å®šä¸ºå¡é¡¿ã€‚

&emsp;åœ¨ run loop çš„æœ¬æ¬¡å¾ªç¯ä¸­ï¼Œä» kCFRunLoopBeforeSources åˆ° kCFRunLoopBeforeWaiting å¤„ç†äº† source/timer/block çš„äº‹æƒ…ï¼Œå¦‚æœæ—¶é—´èŠ±çš„å¤ªé•¿å¿…ç„¶å¯¼è‡´ä¸»çº¿ç¨‹å¡é¡¿ã€‚ä» kCFRunLoopBeforeWaiting åˆ° kCFRunLoopAfterWaiting çŠ¶æ€ï¼Œå¦‚æœæœ¬æ¬¡å”¤é†’èŠ±äº†å¤ªå¤šæ—¶é—´ä¹Ÿä¼šå¿…ç„¶é€ æˆå¡é¡¿ã€‚

***

## 43. run loop ä¸ GCDã€‚
&emsp;åœ¨ Run Loop å’Œ GCD çš„åº•å±‚åŒæ–¹å„è‡ªéƒ½ä¼šç›¸äº’ç”¨åˆ°å¯¹æ–¹ã€‚é¦–å…ˆæˆ‘ä»¬å…ˆçœ‹ä¸€ä¸‹è¯» run loop æºç çš„è¿‡ç¨‹ä¸­ç”¨åˆ° GCD çš„åœ°æ–¹ï¼Œå‰é¢æˆ‘ä»¬å­¦ä¹  GCD çš„æ—¶å€™å·²çŸ¥ä½¿ç”¨ `dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue)` å¯ä»¥æ„å»ºè®¡æ—¶å™¨ï¼Œä¸”å®ƒæ¯” NSTimer çš„ç²¾åº¦æ›´é«˜ã€‚

&emsp;åœ¨ run loop ä¸­æœ‰ä¸¤ä¸ªåœ°æ–¹ç”¨åˆ°äº† dispatch_sourceï¼Œä¸€æ˜¯åœ¨ run loop mode ä¸­æœ‰ä¸€ä¸ªä¸ \_timerPortï¼ˆmk_timer_createï¼‰å¯¹åº”çš„ \_timerSourceï¼Œå®ƒä»¬ä¸¤ä¸ªçš„ä½œç”¨æ˜¯ç›¸åŒçš„ï¼Œéƒ½æ˜¯ç”¨æ¥å½“åˆ°è¾¾ run loop mode çš„ \_timers æ•°ç»„ä¸­æœ€è¿‘çš„æŸä¸ªè®¡æ—¶å™¨çš„è§¦å‘æ—¶é—´æ—¶ç”¨æ¥å”¤é†’å½“å‰ run loop çš„ï¼Œç„¶åè¿˜æœ‰ä¸€ä¸ªåœ°æ–¹æ˜¯åœ¨ \__CFRunLoopRun å‡½æ•°ä¸­ç›´æ¥ä½¿ç”¨ dispatch_source æ„å»ºä¸€ä¸ªè®¡æ—¶å™¨ç”¨æ¥ä¸ºå…¥å‚ run loop çš„è¿è¡Œæ—¶é—´è®¡æ—¶çš„ï¼Œå½“å…¥å‚ run loop è¿è¡Œè¶…æ—¶æ—¶æ­¤è®¡æ—¶å™¨ä¾¿ä¼šè§¦å‘ã€‚

&emsp;åœ¨ \__CFRunLoopRun å‡½æ•°ä¸­æˆ‘ä»¬çœ‹åˆ°æ‰€æœ‰å¹³å°ä¸‹éƒ½æ˜¯ä½¿ç”¨ dispatch_source æ¥æ„å»ºè®¡æ—¶å™¨ä¸º run loop çš„è¿è¡Œæ—¶é—´è€Œè®¡æ—¶çš„ã€‚

&emsp;ï¼ˆä¸€ä¸ªé¢˜å¤–è¯ï¼šçœ‹åˆ°è¿™é‡Œæˆ‘ä»¬ä¼¼ä¹å¯ä»¥å¾—åˆ°ä¸€äº›ç†è§£å’Œå¯å‘ï¼ŒCFRunLoopTimerRef è™½ä¸€ç›´è¢«æˆ‘ä»¬ç§°ä¸ºè®¡æ—¶å™¨ï¼Œä½†å…¶å®å®ƒçš„è§¦å‘æ‰§è¡Œæ˜¯å®Œå…¨ä¾èµ– run loop mode ä¸­çš„ \_timerPort æˆ–è€… \_timerSource æ¥å”¤é†’å½“å‰ run loopï¼Œç„¶ååœ¨å½“å‰ run loop çš„æœ¬æ¬¡å¾ªç¯ä¸­åˆ¤æ–­æœ¬æ¬¡ run loop è¢«å”¤é†’çš„æ¥æºï¼Œå¦‚æœæ˜¯å› ä¸º timer ï¼Œåˆ™æ‰§è¡ŒæŸä¸ª CFRunLoopTimerRef çš„å›è°ƒäº‹ä»¶å¹¶æ›´æ–°æœ€è¿‘çš„ä¸‹æ¬¡æ‰§è¡Œæ—¶é—´ï¼Œæ‰€ä»¥è¿™é‡Œ CFRunLoopTimerRef è™½è¢«ç§°ä¸ºè®¡æ—¶å™¨å…¶å®å®ƒçš„è®¡æ—¶éƒ¨åˆ†æ˜¯ä¾é åˆ«äººæ¥åšçš„ï¼Œå®ƒæœ¬èº«å¹¶ä¸å…·å¤‡è®¡æ—¶åŠŸèƒ½ï¼Œåªæ˜¯æœ‰ä¸€ä¸ªå€¼è®°å½•è‡ªå·±çš„ä¸‹æ¬¡è§¦å‘æ—¶é—´è€Œå·²ã€‚ï¼‰

&emsp;å½“è°ƒç”¨ dispatch_async(dispatch_get_main_queue(), block) æ—¶ï¼ŒlibDispatch ä¼šå‘ä¸»çº¿ç¨‹çš„ run loop å‘é€æ¶ˆæ¯ï¼Œrun loop ä¼šè¢«å”¤é†’ï¼Œå¹¶ä»æ¶ˆæ¯ä¸­å–å¾—è¿™ä¸ª blockï¼Œå¹¶åœ¨å›è°ƒ \_\_CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE\_\_ é‡Œæ‰§è¡Œè¿™ä¸ª blockã€‚ä½†è¿™ä¸ªé€»è¾‘ä»…é™äº dispatch åˆ°ä¸»çº¿ç¨‹ï¼Œdispatch åˆ°å…¶ä»–çº¿ç¨‹ä»ç„¶æ˜¯ç”± libDispatch å¤„ç†çš„ã€‚ä¸ºä»€ä¹ˆå­çº¿ç¨‹æ²¡æœ‰è¿™ä¸ªå’Œ GCD äº¤äº’çš„é€»è¾‘ï¼ŸåŸå› æœ‰äºŒï¼š
1. ä¸»çº¿ç¨‹ run loop æ˜¯ä¸»çº¿ç¨‹çš„äº‹ä»¶ç®¡ç†è€…ã€‚run loop è´Ÿè´£ä½•æ—¶è®© run loop å¤„ç†ä½•ç§äº‹ä»¶ã€‚æ‰€æœ‰åˆ†å‘ç»™ä¸»çº¿ç¨‹çš„ä»»åŠ¡å¿…é¡»ç»Ÿä¸€äº¤ç»™ä¸»çº¿ç¨‹ run loop æ’é˜Ÿå¤„ç†ã€‚ä¸¾ä¾‹ï¼šUI æ“ä½œåªèƒ½åœ¨ä¸»çº¿ç¨‹ï¼Œä¸åœ¨ä¸»çº¿ç¨‹æ“ä½œ UI ä¼šå¸¦æ¥å¾ˆå¤š UI é”™ä¹±é—®é¢˜ä»¥åŠ UI æ›´æ–°å»¶è¿Ÿé—®é¢˜ã€‚
2. å­çº¿ç¨‹ä¸æ¥å— GCD çš„äº¤äº’ã€‚å› ä¸ºå­çº¿ç¨‹ä¸ä¸€å®šå¼€å¯äº† run loopã€‚

&emsp;ä¸Šé¢ä¸€æ®µç»“è®ºæˆ‘ä»¬åœ¨æ¢³ç† \__CFRunLoopRun å‡½æ•°æµç¨‹æ—¶å·²ç»çœ‹çš„ä¸€æ¸…äºŒæ¥šäº†ã€‚å¦‚å‡½æ•°å¼€å§‹æ—¶åˆ¤æ–­å½“å‰æ˜¯å¦æ˜¯ä¸»çº¿ç¨‹æ¥è·å–ä¸»é˜Ÿåˆ—çš„ port å¹¶èµ‹å€¼ç»™ dispatchPortï¼Œç„¶ååœ¨ run loop æœ¬æ¬¡å¾ªç¯ä¸­åˆ¤æ–­å”¤é†’æ¥æºæ˜¯ dispatchPort æ—¶ï¼Œæ‰§è¡Œæ·»åŠ åˆ°ä¸»é˜Ÿåˆ—ä¸­çš„ä»»åŠ¡ï¼ˆ_dispatch_main_queue_drainï¼‰ã€‚
```c++
...
        else if (livePort == dispatchPort) {
            CFRUNLOOP_WAKEUP_FOR_DISPATCH();
            __CFRunLoopModeUnlock(rlm);
            __CFRunLoopUnlock(rl);
            
            // TSD ç»™ __CFTSDKeyIsInGCDMainQ ç½®ä¸º 6 å’Œ ä¸‹é¢çš„ç½® 0 å¯¹åº”ï¼Œå¯ä»¥ç†è§£ä¸ºä¸€ä¸ªåŠ é”è¡Œä¸º!
            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)6, NULL);
            
#if DEPLOYMENT_TARGET_WINDOWS
            void *msg = 0;
#endif

            // å†…éƒ¨æ˜¯è°ƒç”¨ static void _dispatch_main_queue_drain(dispatch_queue_main_t dq) å‡½æ•°ï¼Œå³å¤„ç†ä¸»é˜Ÿåˆ—ä¸­çš„ä»»åŠ¡
            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);
            
            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)0, NULL);
            
            __CFRunLoopLock(rl);
            __CFRunLoopModeLock(rlm);
            
            sourceHandledThisLoop = true;
            didDispatchPortLastTime = true;
        }
...
```

***

## 44. run loop ä¸ FPSã€‚
&emsp;FPSï¼ˆFrames Per Secondï¼‰æ˜¯å›¾åƒé¢†åŸŸä¸­çš„å®šä¹‰ï¼Œæ˜¯æŒ‡ç”»é¢æ¯ç§’ä¼ è¾“å¸§æ•°ï¼Œé€šä¿—æ¥è®²å°±æ˜¯æŒ‡åŠ¨ç”»æˆ–è§†é¢‘çš„ç”»é¢æ•°ã€‚FPS æ˜¯æµ‹é‡ç”¨äºä¿å­˜ã€æ˜¾ç¤ºåŠ¨æ€è§†é¢‘çš„ä¿¡æ¯æ•°é‡ï¼Œæ¯ç§’é’Ÿå¸§æ•°è¶Šå¤šï¼Œæ‰€æ˜¾ç¤ºçš„åŠ¨ä½œå°±ä¼šè¶Šæµç•…ï¼ŒiPhone å±å¹•æœ€å¤§å¸§ç‡æ˜¯æ¯ç§’ 60 å¸§ï¼Œä¸€èˆ¬æˆ‘ä»¬çš„ APP çš„ FPS æ’å®šçš„ä¿æŒåœ¨ 50-60 ä¹‹é—´ï¼Œç”¨æˆ·æ»‘åŠ¨ä½“éªŒéƒ½æ˜¯æ¯”è¾ƒæµç•…çš„ã€‚å…³äºå±å¹•å¡é¡¿çš„ä¸€äº›åŸå› å¯ä»¥å‚è€ƒï¼š[iOS ä¿æŒç•Œé¢æµç•…çš„æŠ€å·§](https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/)

&emsp;YYKit ä¸‹çš„ YYFPSLabel æä¾›äº†ä¸€ç§ç›‘æµ‹ FPS çš„æ–¹æ¡ˆï¼Œå®ç°åŸç†æ˜¯æŠŠä¸€ä¸ª CADisplayLink å¯¹è±¡æ·»åŠ åˆ°ä¸»çº¿ç¨‹çš„ run loop çš„ NSRunLoopCommonModes æ¨¡å¼ä¸‹ï¼Œç„¶ååœ¨ CADisplayLink å¯¹è±¡çš„å›è°ƒå‡½æ•°ä¸­ç»Ÿè®¡æ¯ç§’é’Ÿå±å¹•çš„åˆ·æ–°æ¬¡æ•°ã€‚

***

## 45. ä»‹ç» CADisplayLinkã€‚
&emsp;CADisplayLink æ˜¯ä¸€ä¸ªå’Œå±å¹•åˆ·æ–°ç‡ä¸€è‡´çš„å®šæ—¶å™¨ï¼ˆä½†å®é™…å®ç°åŸç†æ›´å¤æ‚ï¼Œå’Œ NSTimer å¹¶ä¸ä¸€æ ·ï¼Œå…¶å†…éƒ¨å®é™…æ˜¯æ“ä½œäº†ä¸€ä¸ª Sourceï¼‰ã€‚å¦‚æœåœ¨ä¸¤æ¬¡å±å¹•åˆ·æ–°ä¹‹é—´æ‰§è¡Œäº†ä¸€ä¸ªé•¿ä»»åŠ¡ï¼Œé‚£å…¶ä¸­å°±ä¼šæœ‰ä¸€å¸§è¢«è·³è¿‡å»ï¼ˆå’Œ NSTimer ç›¸ä¼¼ï¼‰ï¼Œé€ æˆç•Œé¢å¡é¡¿çš„æ„Ÿè§‰ã€‚åœ¨å¿«é€Ÿæ»‘åŠ¨ TableView æ—¶ï¼Œå³ä½¿ä¸€å¸§çš„å¡é¡¿ä¹Ÿä¼šè®©ç”¨æˆ·æœ‰æ‰€å¯Ÿè§‰ã€‚

&emsp;CADisplayLink è¡¨ç¤ºä¸€ä¸ªç»‘å®šåˆ°æ˜¾ç¤º vsync çš„è®¡æ—¶å™¨çš„ç±»ã€‚ï¼ˆå…¶ä¸­ CA è¡¨ç¤ºçš„æ˜¯ Core Animationï¼ˆæ ¸å¿ƒåŠ¨ç”»ï¼‰ é¦–å­—æ¯ç¼©å†™ï¼ŒCoreAnimation.h æ˜¯ QuartzCore æ¡†æ¶ä¸­çš„ä¸€ä¸ªåŒ…å« QuartzCore æ¡†æ¶æ‰€æœ‰å¤´æ–‡ä»¶çš„æ–‡ä»¶ï¼‰

```c++
/** Class representing a timer bound to the display vsync. **/

API_AVAILABLE(ios(3.1), watchos(2.0), tvos(9.0)) API_UNAVAILABLE(macos)
@interface CADisplayLink : NSObject {
@private
  void *_impl;
}
```

&emsp;æˆ‘ä»¬åˆ›å»ºä¸€ä¸ª CADisplayLink å¯¹è±¡å¹¶æ·»åŠ åˆ°å½“å‰çº¿ç¨‹çš„ä¸»çº¿ç¨‹ä¸­ã€‚
```c++
- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view.
    
    CADisplayLink *displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(displayLinkAction:)];
    [displayLink addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];
}

- (void)displayLinkAction:(CADisplayLink *)displayLink {
    NSLog(@"ğŸ“§ğŸ“§ %@", displayLink);
    
    NSLog(@"duration: %lf timestamp: %lf targetTimestamp: %lf frameInterval: %d preferredFramesPerSecond: %d maximumFramesPerSecond: %d", displayLink.duration, displayLink.timestamp, displayLink.targetTimestamp, displayLink.frameInterval, displayLink.preferredFramesPerSecond, UIScreen.mainScreen.maximumFramesPerSecond);
}
// æ§åˆ¶å°æ‰“å°ï¼š
ğŸ“§ğŸ“§ <CADisplayLink: 0x6000008ec2c0>
duration: 0.016667 timestamp: 366093.060335 targetTimestamp: 366093.077002 frameInterval: 1 preferredFramesPerSecond: 0 maximumFramesPerSecond: 60
```
&emsp;ç›´æ¥æ‰“å° CADisplayLink å¯¹è±¡çš„å„ä¸ªå±æ€§ï¼Œå¯çœ‹åˆ° duration æ˜¯æˆ‘ä»¬ç†Ÿæ‚‰çš„ 0.016667 ç§’ï¼ˆ16.7 æ¯«ç§’ï¼‰ï¼ŒtargetTimestamp - timestamp çº¦ç­‰äº 16.7 æ¯«ç§’ï¼ŒpreferredFramesPerSecond çš„å€¼æ˜¯ 0ï¼Œå®é™…æ˜¯å±å¹•çš„æœ€å¤§åˆ·æ–°ç‡æ¯ç§’ 60 å¸§ï¼ŒiPhone ä¸‹ maximumFramesPerSecond æ˜¯ 60ã€‚ 

&emsp;åœ¨ä¸Šé¢çš„ displayLinkAction å‡½æ•°å†…æ‰“ä¸€ä¸ªæ–­ç‚¹ï¼Œè¿›å…¥æ–­ç‚¹åæ‰“å°å½“å‰å‡½æ•°è°ƒç”¨å †æ ˆï¼š
```c++
(lldb) bt
* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1
  * frame #0: 0x00000001007b3b1e Simple_iOS`-[ViewController displayLinkAction:](self=0x00007fc4ab601df0, _cmd="displayLinkAction:", displayLink=0x00006000013cc090) at ViewController.m:382:27
    frame #1: 0x00007fff2afeb266 QuartzCore`CA::Display::DisplayLink::dispatch_items(unsigned long long, unsigned long long, unsigned long long) + 640
    frame #2: 0x00007fff2b0c3e03 QuartzCore`display_timer_callback(__CFMachPort*, void*, long, void*) + 299
    frame #3: 0x00007fff23b9503d CoreFoundation`__CFMachPortPerform + 157
    frame #4: 0x00007fff23bd4bc9 CoreFoundation`__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__ + 41 // â¬…ï¸ çœ‹åˆ°æ˜¯æ‰§è¡Œ source1 çš„å›è°ƒå‡½æ•°
    frame #5: 0x00007fff23bd4228 CoreFoundation`__CFRunLoopDoSource1 + 472
    frame #6: 0x00007fff23bced64 CoreFoundation`__CFRunLoopRun + 2516
    frame #7: 0x00007fff23bce066 CoreFoundation`CFRunLoopRunSpecific + 438
    frame #8: 0x00007fff384c0bb0 GraphicsServices`GSEventRunModal + 65
    frame #9: 0x00007fff48092d4d UIKitCore`UIApplicationMain + 1621
    frame #10: 0x00000001007b486d Simple_iOS`main(argc=1, argv=0x00007ffeef44bd60) at main.m:76:12
    frame #11: 0x00007fff5227ec25 libdyld.dylib`start + 1
(lldb)
```
&emsp;çœ‹åˆ° CADisplayLink çš„å›è°ƒå‡½æ•°æ˜¯é€šè¿‡ source1 çš„å›è°ƒæ¥æ‰§è¡Œçš„ã€‚ç„¶åæ‰“å°å½“å‰çº¿ç¨‹çš„ run loop å¯çœ‹åˆ°åˆ›å»ºäº†ä¸€ä¸ªå›è°ƒå‡½æ•°æ˜¯ \_ZL22display_timer_callbackP12__CFMachPortPvlS1\_ çš„ source1ã€‚
```c++
...
0 : <CFRunLoopSource 0x600003b11140 [0x7fff80617cb0]>{signalled = No, valid = Yes, order = -1, context = <CFMachPort 0x6000039146e0 [0x7fff80617cb0]>{valid = Yes, port = 6507, source = 0x600003b11140, callout = _ZL22display_timer_callbackP12__CFMachPortPvlS1_ (0x7fff2b0c3cd8), context = <CFMachPort context 0x6000035200d0>}}
...
```
&emsp;é€šè¿‡ä»¥ä¸Šå¯çŸ¥ CADisplayLink çš„å†…éƒ¨æ˜¯ source1 æ¥é©±åŠ¨çš„ã€‚

***

## 46. YYFPSLabel æ˜¯å¦‚ä½•ç›‘æµ‹å¸§ç‡çš„ã€‚
&emsp; [YYFPSLabel](https://github.com/ibireme/YYText/blob/master/Demo/YYTextDemo/YYFPSLabel.m)
```c++
#import "YYFPSLabel.h"
//#import <YYKit/YYKit.h>
#import "YYText.h"
#import "YYWeakProxy.h"

#define kSize CGSizeMake(55, 20)

@implementation YYFPSLabel {
    CADisplayLink *_link;
    NSUInteger _count;
    NSTimeInterval _lastTime;
    UIFont *_font;
    UIFont *_subFont;
    
    NSTimeInterval _llll;
}

- (instancetype)initWithFrame:(CGRect)frame {
    if (frame.size.width == 0 && frame.size.height == 0) {
        frame.size = kSize;
    }
    self = [super initWithFrame:frame];
    
    self.layer.cornerRadius = 5;
    self.clipsToBounds = YES;
    self.textAlignment = NSTextAlignmentCenter;
    self.userInteractionEnabled = NO;
    self.backgroundColor = [UIColor colorWithWhite:0.000 alpha:0.700];
    
    _font = [UIFont fontWithName:@"Menlo" size:14];
    if (_font) {
        _subFont = [UIFont fontWithName:@"Menlo" size:4];
    } else {
        _font = [UIFont fontWithName:@"Courier" size:14];
        _subFont = [UIFont fontWithName:@"Courier" size:4];
    }
    
    // åˆ›å»ºä¸€ä¸ª CADisplayLink å¯¹è±¡æ·»åŠ åˆ° main run loop çš„ NSRunLoopCommonModes æ¨¡å¼ä¸‹ã€‚
    // å› ä¸º CADisplayLink å¯¹è±¡ä¼š retain targetï¼Œæ‰€ä»¥è¿™é‡Œç”¨äº†ä¸€ä¸ª [YYWeakProxy proxyWithTarget:self] åšä¸­é—´çš„æ¡¥æ¢ï¼Œ
    // self èµ‹å€¼ç»™ YYWeakProxy å¯¹è±¡çš„ weak å±æ€§ _targetï¼Œå³ self è¢« YYWeakProxy å¯¹è±¡å¼±å¼•ç”¨ï¼Œ
    // å¹¶é‡å†™ YYWeakProxy çš„ forwardingTargetForSelector: å‡½æ•°ï¼Œç›´æ¥è¿”å› _target å¯¹è±¡æ¥æ¥æ”¶å¤„ç†å‘é€ç»™ YYWeakProxy çš„æ¶ˆæ¯ï¼Œ
    // å³æŠŠ CADisplayLink çš„å›è°ƒå‡½æ•° tick: è½¬ç§»åˆ° YYFPSLabel ç±»æ¥å¤„ç†ã€‚
    
    //ï¼ˆself æŒæœ‰ _linkã€_link æŒæœ‰ YYWeakProxyã€YYWeakProxy å¼±å¼•ç”¨ selfï¼Œè¿™æ ·å°±ç ´å¼€äº†åŸæœ‰çš„å¼•ç”¨å¾ªç¯ï¼‰ 
    
    _link = [CADisplayLink displayLinkWithTarget:[YYWeakProxy proxyWithTarget:self] selector:@selector(tick:)];
    [_link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];
    
    return self;
}

- (void)dealloc {
    // é”€æ¯æ—¶ä¸€å®šè¦è°ƒç”¨ CADisplayLink çš„ invalidate å‡½æ•°
    [_link invalidate];
}

- (CGSize)sizeThatFits:(CGSize)size {
    return kSize;
}

- (void)tick:(CADisplayLink *)link {
    if (_lastTime == 0) {
    
        // åˆæ¬¡è°ƒç”¨ tick å‡½æ•°æ—¶ï¼Œ_lastTime è®°å½•ç¬¬ä¸€å¸§çš„æ—¶é—´æˆ³
        _lastTime = link.timestamp;
        
        return;
    }
    
    // ç»Ÿè®¡ tick è¢«è°ƒç”¨çš„æ¬¡æ•°
    _count++;
    
    // link.timestamp æ˜¯å½“å‰å¸§çš„æ—¶é—´æˆ³ï¼Œå‡å»ä¸Šä¸€æ¬¡ç»Ÿè®¡å¸§ç‡çš„æ—¶é—´æˆ³ï¼Œå½“æ—¶é—´é—´éš”å¤§äºç­‰äº 1 ç§’æ—¶æ‰è¿›è¡Œå¸§ç‡ç»Ÿè®¡ï¼Œ
    // å³ 1 ç§’é’Ÿç»Ÿè®¡ä¸€æ¬¡å¸§ç‡ï¼ˆä¹Ÿæ²¡å¿…è¦è¿‡äºé¢‘ç¹çš„ç»Ÿè®¡å¸§ç‡ï¼‰
    NSTimeInterval delta = link.timestamp - _lastTime;
    
    // æ—¶é—´å¤§äºç­‰äº 1 ç§’é’Ÿè®¡ç®—ä¸€æ¬¡å¸§ç‡ï¼Œåˆ·æ–°ä¸€æ¬¡ YYFPSLabel æ˜¾ç¤ºçš„å¸§ç‡å€¼
    if (delta < 1) return;
    
    // æ›´æ–° _lastTime ä¸ºå½“å‰å¸§çš„æ—¶é—´æˆ³
    _lastTime = link.timestamp;
    
    // tick è¢«è°ƒç”¨çš„æ¬¡æ•°é™¤ä»¥æ—¶é—´é—´éš”ï¼Œå³ä¸ºå½“å‰çš„å¸§ç‡
    float fps = _count / delta;
    
    // tick è¢«è°ƒç”¨çš„æ¬¡æ•°æ¸… 0ï¼ˆå¼€å§‹ä¸‹ä¸€è½®å¸§ç‡ç»Ÿè®¡ï¼‰
    _count = 0;
    
    CGFloat progress = fps / 60.0;
    UIColor *color = [UIColor colorWithHue:0.27 * (progress - 0.2) saturation:1 brightness:0.9 alpha:1];
    
    NSMutableAttributedString *text = [[NSMutableAttributedString alloc] initWithString:[NSString stringWithFormat:@"%d FPS",(int)round(fps)]];
    [text yy_setColor:color range:NSMakeRange(0, text.length - 3)];
    [text yy_setColor:[UIColor whiteColor] range:NSMakeRange(text.length - 3, 3)];
    text.yy_font = _font;
    [text yy_setFont:_subFont range:NSMakeRange(text.length - 4, 1)];
    
    self.attributedText = text;
}

@end
```
&emsp;tick: å‡½æ•°å†…éƒ¨å€ŸåŠ© CADisplayLink å¯¹è±¡ä¸­è®°å½•çš„æ¯ä¸€å¸§çš„æ—¶é—´æˆ³æ¥ç»Ÿè®¡å‡ºæ¯ç§’é’Ÿçš„å¸§ç‡ï¼Œè¶³å¤Ÿæˆ‘ä»¬æ—¥å¸¸å¼€å‘ä¸­ç›‘æµ‹æ»‘åŠ¨å¸§ç‡ã€‚

***

## 47. å±æ€§ä¿®é¥°ç¬¦çš„ä½œç”¨ã€‚
&emsp;å±æ€§ï¼ˆ@propertyï¼‰çš„æœ¬è´¨æ˜¯ç¼–è¯‘å™¨è‡ªåŠ¨å¸®æˆ‘ä»¬ç”Ÿæˆ:  `_Ivar` + `setter` + `getter`ï¼Œè€Œå±æ€§ä¿®é¥°ç¬¦åˆ™æ­£ä½œç”¨äºå„ä¸ªå±æ€§çš„ `setter` å’Œ `getter` å‡½æ•°ã€‚

&emsp;æˆ‘ä»¬åˆ›å»ºå¦‚ä¸‹ Person ç±»ï¼Œå¹¶å£°æ˜ä¸åŒä¿®é¥°ç¬¦çš„å±æ€§ã€‚
```c++
// Person.h å¦‚ä¸‹å£°æ˜ï¼ŒPerson.m æ–‡ä»¶ä»€ä¹ˆä¹Ÿä¸å†™

#import <Foundation/Foundation.h>
NS_ASSUME_NONNULL_BEGIN
@interface Person : NSObject

@property (nonatomic, strong) NSObject *objc_nonatomic_strong;
@property (nonatomic, retain) NSObject *objc_nonatomic_retain;
@property (nonatomic, copy) NSObject *objc_nonatomic_copy;
@property (nonatomic, weak) NSObject *objc_nonatomic_weak;
@property (nonatomic, unsafe_unretained) NSObject *objc_nonatomic_unsafe_unretained;
@property (nonatomic, assign) NSObject *objc_nonatomic_assign;

// readonly ä¿®é¥°çš„å±æ€§ï¼Œç¼–è¯‘å™¨ä»…è‡ªåŠ¨ç”Ÿæˆ getter å‡½æ•°
@property (nonatomic, strong, readonly) NSObject *objc_nonatomic_strong_readonly;

@property (atomic, strong) NSObject *objc_atomic_strong;
@property (atomic, retain) NSObject *objc_atomic_retain;
@property (atomic, copy) NSObject *objc_atomic_copy;
@property (atomic, weak) NSObject *objc_atomic_weak;
@property (atomic, unsafe_unretained) NSObject *objc_atomic_unsafe_unretained;
@property (atomic, assign) NSObject *objc_atomic_assign;

@end
NS_ASSUME_NONNULL_END
```
&emsp;é€‰æ‹©çœŸæœºè¿è¡Œæ¨¡å¼ï¼Œä¿è¯ç¼–è¯‘å‡ºçš„æ˜¯ `ARM` ä¸‹çš„æ±‡ç¼–æŒ‡ä»¤ï¼Œï¼ˆ`x86` çš„çœ‹ä¸å¤ªæ‡‚ï¼‰ç„¶ååœ¨ `xcode` å·¦ä¾§ç”¨é¼ æ ‡é€‰ä¸­ `Person.m` æ–‡ä»¶ï¼Œé€šè¿‡ `xcode` èœå•æ  `Product -> Perform Action -> Assemble "Person.m"` ç”Ÿæˆæ±‡ç¼–æŒ‡ä»¤ï¼Œå¯ä»¥çœ‹åˆ°æˆ‘ä»¬çš„æ‰€æœ‰å±æ€§æ‰€å¯¹åº”çš„ `setter getter` æ–¹æ³•çš„æ±‡ç¼–å®ç°ã€‚

&emsp;`atomic` ä»…ä»…æ˜¯å¯¹è¯»å†™å±æ€§æ—¶åŠ é”ï¼Œåœ¨å¤šçº¿ç¨‹ä¸‹å¯¹å±æ€§è¿›è¡Œå¤åˆè¿ç®—çš„è¯è¿˜æ˜¯éœ€è¦æˆ‘ä»¬è‡ªè¡ŒåŠ é”ä¿è¯çº¿ç¨‹å®‰å…¨ã€‚åŠ é”çš„è¿‡ç¨‹å¦‚ä¸‹ `objc_getProperty` å‡½æ•°ä¸­ä»å…¨å±€çš„å±æ€§é”åˆ—è¡¨ï¼ˆ`PropertyLocks`ï¼‰å†…å–å¾—ä¸€æŠŠé”ï¼Œè¿›è¡ŒåŠ é”å’Œè§£é”ã€‚

&emsp;`objc_nonatomic_strong` å±æ€§çš„ `getter` å‡½æ•°å†…éƒ¨æ²¡æœ‰è°ƒç”¨ä»»ä½•å‡½æ•°ï¼Œåªæ˜¯åœ°å€åç§»å–å€¼ã€‚

&emsp;`objc_nonatomic_strong` å±æ€§çš„ `setter` å‡½æ•°å†…éƒ¨çœ‹åˆ° `bl` æŒ‡ä»¤è·³è½¬åˆ° `objc_storeStrong` å‡½æ•°ï¼Œå®ƒå®ç°çš„äº‹æƒ…å°±æ˜¯ `retain` æ–°å€¼ï¼Œ`release` æ—§å€¼ã€‚

```c++
void
objc_storeStrong(id *location, id obj)
{
    // 1. å–å‡ºå±æ€§åŸæœ¬æŒ‡å‘çš„æ—§å€¼
    id prev = *location;
    
    // 2. å¦‚æœæ—§å€¼å’Œå…¥å‚ä¼ å…¥çš„æ–°å€¼ç›¸åŒï¼Œå°±æ²¡æœ‰èµ‹å€¼çš„å¿…è¦äº†ï¼Œç›´æ¥ return 
    if (obj == prev) {
        return;
    }
    
    // 3. å…ˆ retain æ–°å€¼ objï¼Œobj çš„å¼•ç”¨è®¡æ•° +1
    objc_retain(obj);
    
    // 4. æŠŠå±æ€§æŒ‡å‘æ–°å€¼
    *location = obj;
    
    // 5. é‡Šæ”¾æ—§å€¼
    objc_release(prev);
}
```
&emsp;`objc_nonatomic_retain` å±æ€§çš„ `setter` å’Œ `getter` å‡½æ•°å’Œ `objc_nonatomic_strong` ä¸€è‡´ã€‚

&emsp;`objc_nonatomic_copy` å±æ€§çš„ `getter` å‡½æ•°å†…éƒ¨çœ‹åˆ°æœ€å `b` æŒ‡ä»¤è·³è½¬åˆ°äº† `objc_getProperty` å‡½æ•°ã€‚

```c++
// ptrdiff_t offset
// ptrdiff_t æ˜¯ C/C++ æ ‡å‡†åº“ä¸­å®šä¹‰çš„ä¸€ä¸ªä¸æœºå™¨ç›¸å…³çš„æ•°æ®ç±»å‹ã€‚
// ptrdiff_t ç±»å‹å˜é‡é€šå¸¸ç”¨æ¥ä¿å­˜ä¸¤ä¸ªæŒ‡é’ˆå‡æ³•æ“ä½œçš„ç»“æœã€‚
// ptrdiff_t ç±»å‹åˆ™åº”ä¿è¯è¶³ä»¥å­˜æ”¾åŒä¸€æ•°ç»„ä¸­ä¸¤ä¸ªæŒ‡é’ˆä¹‹é—´çš„å·®è·,å®ƒæœ‰å¯èƒ½æ˜¯è´Ÿæ•°ã€‚

// offset æ˜¯æˆå‘˜å˜é‡è·ç¦»å¯¹è±¡èµ·å§‹åœ°å€çš„åç§»é‡ã€‚

id objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic) {
    // å¦‚æœ offset ä¸º 0ï¼Œåˆ™è¿”å›è¯¥å¯¹è±¡çš„æ‰€å±çš„ç±»å¯¹è±¡çš„åœ°å€
    if (offset == 0) {
        return object_getClass(self);
    }

    // Retain release world
    // self æŒ‡é’ˆåç§»æ‰¾åˆ°æˆå‘˜å˜é‡
    id *slot = (id*) ((char*)self + offset);
    
    // å¦‚æœ atomic ä¸º false åˆ™ç›´æ¥è¿”å›æˆå‘˜å˜é‡
    if (!atomic) return *slot;
        
    // Atomic retain release world
    
    // ä»å…¨å±€çš„å±æ€§é”åˆ—è¡¨å†…å–å¾—é”
    spinlock_t& slotlock = PropertyLocks[slot];
    // åŠ é”
    slotlock.lock();
    
    // retain
    id value = objc_retain(*slot);
    
    // è§£é”
    slotlock.unlock();
    
    // for performance, we (safely) issue the autorelease OUTSIDE of the spinlock.
    // æŠŠ value æ”¾è¿›è‡ªåŠ¨é‡Šæ”¾æ± ï¼Œæ˜¯ä¸ºäº†å®ƒçš„å¼•ç”¨è®¡æ•°ä¸ä¸Šé¢çš„ retain æ“ä½œä¿æŒå¹³è¡¡
    return objc_autoreleaseReturnValue(value);
}
```
&emsp;å¦‚æœå±æ€§ä¸æ˜¯ `atomic` ä¿®é¥°çš„è¯ä¸éœ€è¦å¯¹è¯»å–è¿‡ç¨‹åŠ é”ï¼Œ`objc_getProperty` å‡½æ•°çš„å‰åŠéƒ¨åˆ†å°±å·²ç» `return` æˆå‘˜å˜é‡äº†ï¼Œæˆå‘˜å˜é‡ä¾ç„¶æ˜¯é€šè¿‡ `self` æŒ‡é’ˆåç§»æ‰¾åˆ°å¹¶è¿”å›ã€‚å¦‚æœå±æ€§æ˜¯ `atomic` ä¿®é¥°çš„è¯ï¼Œä¼šé€šè¿‡ `PropertyLocks[slot]` å–å¾—ä¸€æŠŠé”ï¼Œè€ŒåŠ é”çš„å†…å®¹æ˜¯ `id value = objc_retain(*slot)` å¯¹æˆå‘˜å˜é‡æ‰§è¡Œä¸€æ¬¡ `retain` æ“ä½œå¼•ç”¨è®¡æ•° `+1`ï¼ˆä¿è¯ getter å‡½æ•°æ‰§è¡Œè¿‡ç¨‹ä¸­å¯¹è±¡ä¸ä¼šè¢«é‡Šæ”¾ï¼‰ï¼Œç„¶åä¸ºäº†æ€§èƒ½ï¼Œåœ¨è§£é”åæ‰è°ƒç”¨ `objc_autoreleaseReturnValue(value)` æŠŠæˆå‘˜å˜é‡æ”¾è¿›è‡ªåŠ¨é‡Šæ”¾æ± ï¼Œä¿è¯å’Œåˆšåˆšçš„ `retain` æ“ä½œæŠµæ¶ˆï¼Œä¿è¯æœ€ç»ˆæˆå‘˜å˜é‡èƒ½æ­£å¸¸é‡Šæ”¾é”€æ¯ã€‚ 

&emsp;`objc_nonatomic_copy` å±æ€§çš„ `setter` å‡½æ•°å†…éƒ¨çœ‹åˆ° `bl` æŒ‡ä»¤è·³è½¬åˆ°äº† `objc_setProperty_nonatomic_copy` å‡½æ•°ï¼Œå†…éƒ¨æ˜¯å¯¹å…¥å‚æ–°å€¼è¿›è¡Œ `copy` æ“ä½œã€‚ä¸‹é¢æˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹ `objc_setProperty_nonatomic_copy` å‡½æ•°å®ç°ã€‚

```c++
void objc_setProperty_nonatomic_copy(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
    // ç›´æ¥è°ƒç”¨ reallySetProperty å‡½æ•°
    // ä¸”åé¢ä¸‰ä¸ªå®å‚åˆ†åˆ«è¡¨ç¤ºï¼š
    
    // atomic: false
    // copy: true
    // mutableCopy: false
    
    reallySetProperty(self, _cmd, newValue, offset, false, true, false);
}
```

```c++
// atomic: false
// copy: true
// mutableCopy: false

static inline void reallySetProperty(id self, SEL _cmd, id newValue, ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy)
{
    // å¦‚æœ offset ä¸º 0ï¼Œåˆ™è°ƒç”¨ changeIsa ä¿®æ”¹å¯¹è±¡çš„ isa
    if (offset == 0) {
        object_setClass(self, newValue);
        return;
    }

    // ç”¨äºè®°å½•æ—§å€¼çš„ä¸´æ—¶å˜é‡ï¼Œä¸»è¦æ˜¯åœ¨æœ€åå¯¹æ—§å€¼è¿›è¡Œ release æ“ä½œï¼Œé‡Šæ”¾æ—§å€¼
    id oldValue;
    
    // æ ¹æ® offset å–å¾—å¯¹è±¡å½“å‰è¦è¿›è¡Œ setter çš„æˆå‘˜å˜é‡ï¼ˆæ—§å€¼ï¼‰
    id *slot = (id*) ((char*)self + offset);
    
    if (copy) {
        // å¦‚æœæ˜¯ copy çš„è¯ï¼Œå¯¹ newValue æ‰§è¡Œä¸€æ¬¡ copy æ“ä½œï¼Œè¿™é‡Œç›´æ¥æŠŠ copy ç»“æœèµ‹å€¼ç»™ newValue
        newValue = [newValue copyWithZone:nil];
    } else if (mutableCopy) {
        // å¦‚æœæ˜¯ mutableCopy çš„è¯ï¼Œå¯¹ newValue æ‰§è¡Œä¸€æ¬¡ mutableCopy æ“ä½œï¼Œè¿™é‡Œç›´æ¥æŠŠ mutableCopy ç»“æœèµ‹å€¼ç»™ newValue
        newValue = [newValue mutableCopyWithZone:nil];
    } else {
        // å¦‚æœæ—§å€¼å’Œæ–°å€¼ç›¸åŒçš„è¯ï¼Œåˆ™ç›´æ¥ return
        if (*slot == newValue) return;
        
        // retain æ–°å€¼
        newValue = objc_retain(newValue);
    }

    if (!atomic) {
        // å¦‚æœä¸æ˜¯ atomic çš„è¯ï¼Œä¸éœ€è¦åŠ é”ï¼ŒæŠŠ *slot èµ‹å€¼ç»™ oldValueï¼Œä¼šåœ¨å‡½æ•°æœ«å°¾é‡Šæ”¾ oldValue
        oldValue = *slot;
    
        // æŠŠæ–°å€¼èµ‹å€¼ç»™å¯¹è±¡çš„æˆå‘˜å˜é‡
        *slot = newValue;
    } else {
        // å¦‚æœæ˜¯ atomic çš„è¯ï¼Œåˆ™å¯¹èµ‹å€¼çš„è¿‡ç¨‹è¿›è¡ŒåŠ é”ï¼Œçœ‹åˆ° atomic ä¿®é¥°çš„å±æ€§åªæ˜¯å¯¹æ–°å€¼æ—§å€¼èµ‹å€¼çš„è¿‡ç¨‹è¿›è¡Œäº†åŠ é”ï¼Œå’Œ nonatomic ä¸åŠ é”ç›¸æ¯”ï¼Œè¿™ä¸ªåŠ é”çš„æ“ä½œå°±æ˜¯æ€§èƒ½æŸè€—çš„æ¥æºã€‚
        
        // çœ‹åˆ°è¿™é‡Œæˆ‘ä»¬ä¹Ÿå‘ç°äº†ï¼Œatomic åªæ˜¯å¯¹ setter å’Œ getter åŠ é”ï¼Œåªèƒ½ä¿è¯ setter å’Œ getter æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼Œä½†æ˜¯æˆ‘ä»¬æ—¥å¸¸å¼€å‘ä¸­å‡ ä¹éƒ½æ˜¯å¤åˆæ“ä½œï¼Œ
        // å¦‚ self.a = self.a + 1;
        // æ­¤æ“ä½œåŒ…å« getterã€setterã€åŠ æ“ä½œï¼Œatomic åªæ˜¯ç»™å•ä¸ª getterã€setter æ“ä½œåŠ é”äº†ï¼Œæ— æ³•ä¿è¯è¿™ç§å¤åˆæ“ä½œçš„çº¿ç¨‹å®‰å…¨ï¼Œå¦‚æœè¦å®ç°çº¿ç¨‹å®‰å…¨éœ€è¦é¢å¤–åŠ é”ã€‚
        
        // å¦‚ä¸‹ä¼ªä»£ç :
        // lock.lock();
        // self.a = self.a + 1;
        // lock.unlock();
        
        // ä»å…¨å±€çš„å±æ€§é”åˆ—è¡¨å†…å–å¾—é”
        spinlock_t& slotlock = PropertyLocks[slot];
        // åŠ é” 
        slotlock.lock();
        
        // æŠŠ *slot èµ‹å€¼ç»™ oldValueï¼Œä¼šåœ¨å‡½æ•°æœ«å°¾é‡Šæ”¾ oldValue
        oldValue = *slot;
        // æŠŠæ–°å€¼èµ‹å€¼ç»™å¯¹è±¡çš„æˆå‘˜å˜é‡
        *slot = newValue;
        
        // è§£é”
        slotlock.unlock();
    }

    // é‡Šæ”¾æ—§å€¼
    objc_release(oldValue);
}
```

&emsp;`objc_nonatomic_weak` å±æ€§çš„ `getter` å‡½æ•°å†…éƒ¨çœ‹åˆ° `bl` æŒ‡ä»¤è·³è½¬åˆ° `objc_loadWeakRetained` å‡½æ•°ï¼Œåœ¨ç»“å°¾å¤„ `b` æŒ‡ä»¤è·³è½¬åˆ° `objc_autoreleaseReturnValue`ï¼Œå³æˆ‘ä»¬ç†Ÿæ‚‰çš„ `objc_loadWeak` å‡½æ•°ã€‚`retain` å’Œ `autorelease` çš„é…å¯¹ä½¿ç”¨ï¼Œé˜²æ­¢è¯»å€¼è¿‡ç¨‹ä¸­å¯¹è±¡é‡Šæ”¾ï¼ŒåŒæ—¶è‡ªåŠ¨é‡Šæ”¾æ± çš„å»¶è¿Ÿé‡Šæ”¾ä¹Ÿèƒ½ä¿è¯å¯¹è±¡çš„æ­£å¸¸é”€æ¯ã€‚

```c++
id
objc_loadWeak(id *location)
{
    if (!*location) return nil;
    return objc_autorelease(objc_loadWeakRetained(location));
}
```

&emsp;`objc_nonatomic_weak` å±æ€§çš„ `setter` å‡½æ•°å†…éƒ¨çœ‹åˆ° `bl` æŒ‡ä»¤è·³è½¬åˆ°äº† `objc_storeWeak` å‡½æ•°ã€‚å³ `weak` ä¿®é¥°å¯¹å±æ€§è¯»å–è°ƒç”¨ `objc_loadWeak` èµ‹å€¼è°ƒç”¨ `objc_storeWeak` å‡½æ•°ã€‚

&emsp;`objc_nonatomic_unsafe_unretained` å±æ€§çš„ `getter` å‡½æ•°å’Œ `objc_nonatomic_strong` å±æ€§çš„ `getter` å‡½æ•° ä¸€æ ·ï¼Œå†…éƒ¨æ²¡æœ‰è°ƒç”¨ä»»ä½•å‡½æ•°ï¼Œåªæ˜¯åœ°å€åç§»å–å€¼ã€‚

&emsp;`objc_nonatomic_unsafe_unretained` å±æ€§çš„ `setter` å‡½æ•°çœ‹åˆ°å†…éƒ¨æ²¡æœ‰è°ƒç”¨ä»»ä½•å…¶å®ƒå‡½æ•°ï¼Œå°±æ˜¯çº¯ç²¹çš„å…¥å‚ã€åœ°å€åç§»ã€å­˜å‚¨å…¥å‚åˆ°æˆå‘˜å˜é‡çš„ä½ç½®ã€‚è¿™é‡Œä¹ŸéªŒè¯äº† `unsafe_unretained` çš„ `setter` çš„æœ¬è´¨ï¼Œå³ä¸ `retain` æ–°å€¼ä¹Ÿä¸ `release` æ—§å€¼ã€‚`setter` å’Œ `getter` å‡½æ•°éƒ½æ˜¯ç®€å•çš„æ ¹æ®åœ°å€å­˜å…¥å€¼å’Œè¯»å–å€¼ã€‚æ‰€ä»¥è¿™é‡Œä¹Ÿå¼•å‡ºå¦ä¸€ä¸ªé—®é¢˜ï¼Œèµ‹å€¼ç»™ `unsafe_unretained` å±æ€§çš„å¯¹è±¡å¹¶ä¸ä¼šè¢« `unsafe_unretained` å±æ€§æ‰€æŒæœ‰ï¼Œé‚£ä¹ˆå½“æ­¤å¯¹è±¡æ­£å¸¸é‡Šæ”¾é”€æ¯ä»¥åï¼Œä¹Ÿå¹¶æ²¡æœ‰æŠŠ `unsafe_unretained` å±æ€§ç½®ä¸º `nil`ï¼Œæ­¤æ—¶æˆ‘ä»¬å¦‚æœå†ç”¨ `unsafe_unretained` å±æ€§æ ¹æ®åœ°å€è¯»å–å¯¹è±¡ï¼Œä¼šç›´æ¥å¼•å‘é‡æŒ‡é’ˆè®¿é—®å¯¼è‡´ `crash`ã€‚

&emsp;`objc_nonatomic_assign` å±æ€§çš„ `setter` å’Œ `getter` å‡½æ•°å’Œ `objc_nonatomic_unsafe_unretained` å±æ€§å¦‚å‡ºä¸€è¾™ã€‚

&emsp;`objc_nonatomic_strong_readonly` å±æ€§åªç”Ÿæˆäº† `getter` å‡½æ•°ï¼Œä¹Ÿç¬¦åˆæˆ‘ä»¬çš„é¢„æœŸã€‚

&emsp;ä¸‹é¢æ˜¯ `atomic` ä¿®é¥°å¯¹å±æ€§ã€‚

```c++
// getter
...
...
// é›¶å¯„å­˜å™¨çš„å€¼å’Œ 0x1 åšæˆ–æ“ä½œï¼Œå¹¶æŠŠç»“æœå­˜å…¥ w3ï¼Œè¡¨ç¤º w3 = 1ï¼ŒåŒæ—¶è¡¨ç¤ºä¸‹é¢è°ƒç”¨ objc_getProperty å‡½æ•°æ˜¯ç¬¬ 4 ä¸ªå‚æ•° BOOL atomic æ˜¯ true
// x0 - x7 å¯„å­˜å™¨ä¿å­˜å‡½æ•°å‚æ•°
orr    w3, wzr, #0x1
...
b    _objc_getProperty
...

// setter
...
bl    _objc_setProperty_atomic
...
```

```c++
void objc_setProperty_atomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
    // atomic å‚æ•°ä½¿ç”¨çš„æ˜¯ true
    reallySetProperty(self, _cmd, newValue, offset, true, false, false);
}
```
&emsp;`objc_atomic_strong` å±æ€§åœ¨ `setter` å’Œ `getter` å‡½æ•°ä¸­éƒ½åŠ äº†é”ã€‚

&emsp;`objc_atomic_retain` å±æ€§ å’Œ `objc_atomic_strong` å±æ€§çš„ `setter` å’Œ `getter` å‡½æ•°å¦‚å‡ºä¸€è¾™ã€‚

&emsp;`objc_atomic_copy` å±æ€§çš„ `setter` å’Œ `getter` åŒæ ·ä¹Ÿæ˜¯è¿›è¡ŒåŠ é”ã€‚

```c++
// getter
...
orr    w3, wzr, #0x1 // ç¬¬ 4 ä¸ªå‚æ•° BOOL atomic æ˜¯ true
...
b    _objc_getProperty
...

// setter
bl    _objc_setProperty_atomic_copy
```

```c++
void objc_setProperty_atomic_copy(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
    // atomic å€¼ä½¿ç”¨çš„æ˜¯ true
    reallySetProperty(self, _cmd, newValue, offset, true, true, false);
}
```

&emsp;`objc_atomic_weak`ã€`objc_atomic_unsafe_unretained`ã€`objc_atomic_assign` å’Œå¯¹åº”çš„ `nonatomic` ä¿®é¥°çš„å±æ€§çš„ `setter` `getter` å‡½æ•°ç›¸åŒã€‚

## ğŸ‰ğŸ‰ğŸ‰ æœªå®Œå¾…ç»­...
