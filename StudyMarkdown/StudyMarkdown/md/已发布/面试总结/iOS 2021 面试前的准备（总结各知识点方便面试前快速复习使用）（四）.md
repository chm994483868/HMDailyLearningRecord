# iOS 2021 é¢è¯•å‰çš„å‡†å¤‡ï¼ˆæ€»ç»“å„çŸ¥è¯†ç‚¹æ–¹ä¾¿é¢è¯•å‰å¿«é€Ÿå¤ä¹ ä½¿ç”¨ï¼‰ï¼ˆå››ï¼‰

## 29. è§£é‡Š Thread Local Dataã€‚
&emsp;`pthread_getspecific` å’Œ `pthread_setspecific` è¿™ä¸¤ä¸ªæ¥å£åˆ†åˆ«ç”¨äºè·å–å’Œè®¾ç½®çº¿ç¨‹æœ¬åœ°å­˜å‚¨åŒºçš„æ•°æ®ï¼Œåœ¨ä¸åŒçš„çº¿ç¨‹ä¸‹ç›¸åŒçš„ `pthread_key_t` è¯»å–çš„ç»“æœæ˜¯ä¸åŒçš„ï¼Œå³çº¿ç¨‹çš„æœ¬åœ°å­˜å‚¨ç©ºé—´æ˜¯ç›¸äº’éš”ç¦»çš„ï¼Œè¿™ä¹Ÿæ˜¯çº¿ç¨‹æœ¬åœ°å­˜å‚¨çš„å…³é”®æ‰€åœ¨ã€‚

&emsp;ï¼ˆè¿™é‡Œè¿˜æœ‰ä¸€ä¸ªéšè—ç‚¹ï¼Œæˆ‘ä»¬ä¸èƒ½ä»¥é¢å‘å¯¹è±¡çš„æ€æƒ³çœ‹å¾…è¿™ä¸¤ä¸ªæ¥å£ï¼Œè°ƒç”¨ `pthread_getspecific` å’Œ `pthread_setspecific` æ—¶æˆ‘ä»¬æ˜¯ä¸éœ€è¦ä¼ å…¥ pthread_t å¯¹è±¡çš„ï¼Œå¦‚æœæˆ‘ä»¬æƒ³è¦åœ¨æŸæ¡çº¿ç¨‹å†…è¯»å–å…¶å­˜å‚¨ç©ºé—´çš„æ•°æ®ï¼Œé‚£ä¹ˆæˆ‘ä»¬åªèƒ½åœ¨å½“å‰çº¿ç¨‹å†…æ‰§è¡Œ `pthread_getspecific` å‡½æ•°ï¼Œå­˜å‚¨åŒç†ï¼Œå³æˆ‘ä»¬æƒ³è¦æ“ä½œå“ªæ¡çº¿ç¨‹ï¼Œé‚£ä¹ˆæˆ‘ä»¬åªèƒ½åœ¨å“ªæ¡çº¿ç¨‹å†…æ‰§è¡Œæ“ä½œã€‚ï¼‰

&emsp;æ¯ä¸ªçº¿ç¨‹é€€å‡ºæ—¶è°ƒç”¨ \__CFFinalizeRunLoop å‡½æ•°ã€‚
```c++
// Called for each thread as it exits
// æ¯ä¸ªçº¿ç¨‹é€€å‡ºæ—¶è°ƒç”¨

CF_PRIVATE void __CFFinalizeRunLoop(uintptr_t data) {
    CFRunLoopRef rl = NULL;
    
    if (data <= 1) {
        // å½“ data å°äºç­‰äº 1 å¼€å§‹æ‰§è¡Œé”€æ¯
        
        // static CFLock_t loopsLock = CFLockInit;
        // loopsLock æ˜¯ä¸€ä¸ªå…¨å±€çš„é”ï¼Œæ‰§è¡ŒåŠ é”
        __CFLock(&loopsLock);
        
        // ä» __CFRunLoops å…¨å±€å­—å…¸ä¸­è¯»å‡ºå½“å‰çº¿ç¨‹çš„ run loop å¯¹è±¡
        if (__CFRunLoops) {
            // ä»¥ pthreadPointer(pthread_self()) ä¸º key è¯»å– run loop
            rl = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(pthread_self()));
            
            // è¿™é‡Œçš„ retain æ˜¯ä¸ºäº†ä¸‹é¢ç»§ç»­ä½¿ç”¨ rlï¼Œè¿™é‡Œä» __CFRunLoops å­—å…¸ä¸­ç§»é™¤ rlï¼Œå®ƒçš„å¼•ç”¨è®¡æ•°ä¼šå‡ 1
            if (rl) CFRetain(rl);
            CFDictionaryRemoveValue(__CFRunLoops, pthreadPointer(pthread_self()));
        }
        
        __CFUnlock(&loopsLock);
    } else {
        // åˆå§‹æ—¶æ˜¯ PTHREAD_DESTRUCTOR_ITERATIONS-1 æ˜¯ 3ï¼Œé‚£ä¹ˆ __CFFinalizeRunLoop å‡½æ•°éœ€è¦è°ƒç”¨ä¸¤æ¬¡å‡ 1ï¼Œæ‰èƒ½çœŸæ­£çš„æ‰§è¡Œ run loop å¯¹è±¡çš„é”€æ¯å·¥ä½œ 
        _CFSetTSD(__CFTSDKeyRunLoopCntr, (void *)(data - 1), (void (*)(void *))__CFFinalizeRunLoop);
    }
    // è¿™é‡Œçš„åˆ¤æ–­ä¸»çº¿ç¨‹çš„ run loop æ˜¯ç»å¯¹ä¸èƒ½é”€æ¯çš„ï¼Œåªèƒ½é”€æ¯å­çº¿ç¨‹çš„ run loopï¼Œè¯è¯´é™¤äº†æˆ‘ä»¬è‡ªå·±å¼€è¾Ÿçš„å­çº¿ç¨‹å¤–ï¼Œç³»ç»Ÿä¼šåˆ›å»ºå¯åŠ¨äº† run loop çš„å­çº¿ç¨‹å—ï¼Ÿ
    if (rl && CFRunLoopGetMain() != rl) { // protect against cooperative threads
        // å¦‚æœ _counterpart å­˜åœ¨åˆ™è¿›è¡Œé‡Šæ”¾
        if (NULL != rl->_counterpart) {
            CFRelease(rl->_counterpart);
            rl->_counterpart = NULL;
        }
        
        // purge all sources before deallocation
        // åœ¨é”€æ¯ run loop ä¹‹å‰æ¸…é™¤æ‰€æœ‰æ¥æº
        
        // å–å¾— mode æ•°ç»„
        CFArrayRef array = CFRunLoopCopyAllModes(rl);
        
        // éå† mode æ•°ç»„ï¼Œç§»é™¤ mode ä¸­çš„æ‰€æœ‰ sources
        for (CFIndex idx = CFArrayGetCount(array); idx--;) {
            CFStringRef modeName = (CFStringRef)CFArrayGetValueAtIndex(array, idx);
            __CFRunLoopRemoveAllSources(rl, modeName);
        }
        
        // ç§»é™¤ common mode ä¸­çš„æ‰€æœ‰ sources
        __CFRunLoopRemoveAllSources(rl, kCFRunLoopCommonModes);
        CFRelease(array);
    }
    // é‡Šæ”¾ rl
    if (rl) CFRelease(rl);
}
```
&emsp;é”€æ¯ run loop å¯¹è±¡ä¹‹å‰ï¼Œè¦å…ˆå°†å…¶ä» \__CFRunLoops å…¨å±€å­—å…¸ä¸­ç§»é™¤ï¼ŒåŒæ—¶éå†å…¶æ‰€æœ‰çš„ modeï¼Œä¾æ¬¡ç§»é™¤æ¯ä¸ª mode ä¸­çš„æ‰€æœ‰ sourcesï¼Œæœ€åé”€æ¯ run loop å¯¹è±¡ã€‚mode é”€æ¯å‰åŒæ ·ä¹Ÿä¼šé‡Šæ”¾æ‰€æœ‰çš„ mode itemã€‚

***

## 30. run loop è¿è¡Œè¿‡ç¨‹ï¼ˆCFRunLoopRun å‡½æ•°æ‘˜è¦ï¼‰åˆ†æã€‚
&emsp;åœ¨æŒ‡å®šçš„æ¡ä»¶ä¸‹ï¼Œè¿è¡Œå¾ªç¯é€€å‡ºå¹¶è¿”å›ä»¥ä¸‹å€¼:
+ `kCFRunLoopRunFinished` è¿è¡Œå¾ªç¯æ¨¡å¼æ²¡æœ‰æºæˆ–è®¡æ—¶å™¨ã€‚ï¼ˆå½“ run loop å¯¹è±¡è¢«æ ‡è®°ä¸ºæ­£åœ¨é”€æ¯æ—¶ä¹Ÿä¼šè¿”å› kCFRunLoopRunFinishedï¼‰
+ `kCFRunLoopRunStopped` è¿è¡Œå¾ªç¯å·²ä½¿ç”¨ `CFRunLoopStop` å‡½æ•°åœæ­¢ã€‚
+ `kCFRunLoopRunTimedOut` æ—¶é—´é—´éš”ç§’æ•°ï¼ˆsecondsï¼‰è¿‡å»äº†ã€‚
+ `kCFRunLoopRunHandledSource` å·²å¤„ç†æºã€‚æ­¤é€€å‡ºæ¡ä»¶ä»…é€‚ç”¨äº `returnAfterSourceHandled` ä¸º `true` æ—¶ã€‚

&emsp;ä¸èƒ½ä¸º `mode` å‚æ•°æŒ‡å®š `kCFRunLoopCommonModes` å¸¸é‡ã€‚è¿è¡Œå¾ªç¯æ€»æ˜¯ä»¥ç‰¹å®šæ¨¡å¼è¿è¡Œã€‚åªæœ‰åœ¨é…ç½®è¿è¡Œå¾ªç¯è§‚å¯Ÿè€…æ—¶ï¼Œä»¥åŠä»…åœ¨å¸Œæœ›è¯¥è§‚å¯Ÿè€…ä»¥å¤šç§æ¨¡å¼è¿è¡Œçš„æƒ…å†µä¸‹ï¼Œæ‰èƒ½æŒ‡å®š common modeã€‚

```c++
void CFRunLoopRun(void) {    /* DOES CALLOUT */
    int32_t result;
    do {
    
        // è°ƒç”¨ CFRunLoopRunSpecific å‡½æ•°ï¼Œä»¥ kCFRunLoopDefaultMode å¯åŠ¨å½“å‰çº¿ç¨‹çš„ run loopï¼Œ
        // è¿è¡Œæ—¶é—´ä¼ å…¥çš„æ˜¯ 10^10 ç§’ï¼ˆ2777777 ä¸ªå°æ—¶ï¼‰ï¼Œ
        // returnAfterSourceHandled å‚æ•°ä¼ å…¥çš„æ˜¯ falseï¼Œ
        // æŒ‡ç¤º run loop æ˜¯åœ¨å¤„ç†ä¸€ä¸ªæºä¹‹åä¸é€€å‡ºå¹¶æŒç»­å¤„ç†äº‹ä»¶ã€‚
        
        result = CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);
        
        CHECK_FOR_FORK();
        
    } while (kCFRunLoopRunStopped != result && kCFRunLoopRunFinished != result);
}
```
&emsp;`CFRunLoopRunSpecific` å‡½æ•°å†…éƒ¨ä¼šè°ƒç”¨ `__CFRunLoopRun` å‡½æ•°ï¼Œç„¶åå¯ä»¥æŠŠ `result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);` æ­¤è¡Œçš„è°ƒç”¨çœ‹ä½œä¸€ä¸ªåˆ†ç•Œçº¿ã€‚è¡Œå‰æ˜¯ï¼Œåˆ™æ˜¯é¦–å…ˆåˆ¤æ–­ `rl` æ˜¯å¦è¢«æ ‡è®°ä¸ºæ­£åœ¨é”€æ¯ï¼Œå¦‚æœæ˜¯çš„è¯åˆ™ç›´æ¥è¿”å› kCFRunLoopRunFinishedï¼Œå¦åˆ™ç»§ç»­å¾€ä¸‹æ‰§è¡Œï¼Œä¼šæ ¹æ® `modeName` ä» `rl` çš„ `_modes` ä¸­æ‰¾åˆ°å…¶å¯¹åº”çš„ `CFRunLoopModeRef`ï¼Œå¦‚æœæœªæ‰¾åˆ°æˆ–è€… `CFRunLoopModeRef` çš„ sources0/sources1/timers/block ä¸ºç©ºï¼Œåˆ™ä¹Ÿæ˜¯ç›´æ¥è¿”å›  kCFRunLoopRunFinishedã€‚ç„¶åæ˜¯ä¿®æ”¹ `rl` çš„ `_perRunData` å’Œ `_currentMode` åŒæ—¶è¿˜ä¼šè®°å½•ä¹‹å‰çš„æ—§å€¼ï¼Œæ­¤æ—¶ä¸€åˆ‡å‡†å¤‡å°±ç»ªï¼Œåœ¨è°ƒç”¨ä¹‹å‰ä¼šæ ¹æ® `rl` çš„ `_currentMode` çš„ `_observerMask` åˆ¤æ–­æ˜¯å¦éœ€è¦å›è°ƒ run loop observer è§‚å¯Ÿè€…æ¥å‘Šè¯‰å®ƒä»¬ run loop è¦è¿›å…¥ kCFRunLoopEntry çŠ¶æ€äº†ï¼Œç„¶åè°ƒç”¨ `__CFRunLoopRun` å‡½æ•°æ­£å¼å¯åŠ¨ run loopã€‚

&emsp;`__CFRunLoopRun` å‡½æ•°è¿”å›ååˆ™æ˜¯ï¼Œé¦–å…ˆæ ¹æ® `rl` çš„ `_currentMode` çš„ `_observerMask` åˆ¤æ–­æ˜¯å¦éœ€è¦å›è°ƒ run loop observer è§‚å¯Ÿè€…æ¥å‘Šè¯‰å®ƒä»¬ run loop è¦è¿›å…¥ kCFRunLoopExit çŠ¶æ€äº†ã€‚ç„¶åæ˜¯æŠŠ run loop å¯¹è±¡æ¢å¤åˆ°ä¹‹å‰çš„ `_perRunData` å’Œ `_currentMode`ï¼ˆå¤„ç† run loop çš„åµŒå¥—ï¼‰ã€‚

&emsp;ä¸Šé¢æè¿°çš„å¯èƒ½ä¸å¤ªæ¸…æ™°ï¼Œçœ‹ä¸‹é¢çš„ä»£ç å’Œæ³¨é‡Šå·²ç»æå…¶æ¸…æ™°äº†ã€‚
```c++
SInt32 CFRunLoopRunSpecific(CFRunLoopRef rl,
                            CFStringRef modeName,
                            CFTimeInterval seconds,
                            Boolean returnAfterSourceHandled) {     /* DOES CALLOUT */
    CHECK_FOR_FORK();
    
    // ä» rl çš„ _cfinfo å­—æ®µä¸­å– rl æ˜¯å¦æ­£åœ¨é”€æ¯çš„æ ‡è®°å€¼ï¼Œå¦‚æœæ˜¯çš„è¯ï¼Œåˆ™ç›´æ¥è¿”å› kCFRunLoopRunFinished
    if (__CFRunLoopIsDeallocating(rl)) return kCFRunLoopRunFinished;
    
    // CFRunLoop åŠ é”
    __CFRunLoopLock(rl);
    
    // è°ƒç”¨ __CFRunLoopFindMode å‡½æ•°ä» rl çš„ _modes ä¸­æ‰¾åˆ°åå­—æ˜¯ modeName çš„ run loop modeï¼Œ
    // å¦‚æœæ‰¾ä¸åˆ°çš„è¯ç¬¬ä¸‰ä¸ªå‚æ•°ä¼ çš„æ˜¯ false åˆ™ä¸è¿›è¡Œæ–°å»º run loop modeï¼Œåˆ™ç›´æ¥è¿”å› NULLã€‚ 
    //ï¼ˆCFRunLoopMode åŠ é”ï¼‰
    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, modeName, false);
    
    // å¦‚æœ currentMode ä¸º NULL æˆ–è€… currentMode é‡Œé¢æ˜¯ç©ºçš„ä¸åŒ…å« sources0/sources1/timers/block åˆ™ return 
    if (NULL == currentMode || __CFRunLoopModeIsEmpty(rl, currentMode, rl->_currentMode)) {
        Boolean did = false;
        
        // å¦‚æœ currentMode å­˜åœ¨ï¼Œåˆ™è¿›è¡Œ CFRunLoopMode è§£é”ï¼Œ
        // å¯¹åº”äº†ä¸Šé¢ __CFRunLoopFindMode(rl, modeName, false) è°ƒç”¨å†…éƒ¨çš„ CFRunLoopMode åŠ é” 
        if (currentMode) __CFRunLoopModeUnlock(currentMode);
        
        // CFRunLoop è§£é”
        __CFRunLoopUnlock(rl);
        
        // è¿”å› kCFRunLoopRunFinished
        return did ? kCFRunLoopRunHandledSource : kCFRunLoopRunFinished;
    }
    
    // __CFRunLoopPushPerRunData å‡½æ•°å†…éƒ¨æ˜¯ä¿®æ”¹ rl çš„ _perRunData å­—æ®µçš„å„æˆå‘˜å˜é‡çš„å€¼ï¼Œå¹¶è¿”å›ä¹‹å‰çš„ _perRunDataï¼Œ
    //ï¼ˆå‡½æ•°å†…éƒ¨ä¿®æ”¹ _perRunData çš„å€¼å…¶å®æ˜¯åœ¨æ ‡è®° run loop ä¸åŒçŠ¶æ€ï¼‰
    //ï¼ˆè¿™é‡Œçš„ previousPerRun æ˜¯ç”¨äºä¸‹é¢çš„ __CFRunLoopRun å‡½æ•°è°ƒç”¨è¿”å›åï¼Œå½“å‰çš„ run loop å¯¹è±¡è¦å›åˆ°ä¹‹å‰çš„ _perRunDataï¼‰ã€‚
    volatile _per_run_data *previousPerRun = __CFRunLoopPushPerRunData(rl);
    
    // previousMode è®°å½• rl å½“å‰çš„ run loop modeï¼Œç›¸æ¯”å…¥å‚ä¼ å…¥çš„ modeName å–å¾—çš„ run loop mode è€Œè¨€ï¼Œå®ƒæ˜¯ä¹‹å‰çš„ run loop modeï¼Œ
    // è¿™ä¸ª previousMode ä¸»è¦ç”¨äºä¸‹é¢çš„é‚£è¡Œ __CFRunLoopRun å‡½æ•°è°ƒç”¨è¿”å›åï¼Œå½“å‰çš„ run loop å¯¹è±¡è¦å›åˆ°ä¹‹å‰çš„ run loop modeã€‚
    //ï¼ˆåŒä¸Šé¢çš„ previousPerRun æ•°æ®ï¼Œä¹Ÿè¦æŠŠå½“å‰çš„ run loop å¯¹è±¡å›åˆ°ä¹‹å‰çš„ _perRunData æ•°æ®çš„çŠ¶æ€ï¼‰
    CFRunLoopModeRef previousMode = rl->_currentMode;
    
    // æ›´æ–° rl çš„ _currentMode ä¸ºå…¥å‚ modeName å¯¹åº”çš„ run loop mode 
    rl->_currentMode = currentMode;
    
    // ä¸´æ—¶å˜é‡ resultï¼Œç”¨äºå½“å‡½æ•°è¿”å›æ—¶è®°å½• run loop ä¸åŒçš„é€€å‡ºåŸå› 
    int32_t result = kCFRunLoopRunFinished;
    
    // åˆ¤æ–­å¦‚æœ currentMode çš„ _observerMask å­—æ®µä¸­åŒ…å« kCFRunLoopEntry çš„å€¼ï¼ˆ_observerMask å†…è®°å½•äº†éœ€è¦è§‚å¯Ÿ run loop å“ªäº›çŠ¶æ€å˜åŒ–ï¼‰ï¼Œ
    // åˆ™å‘Šè¯‰ currentMode çš„ run loop observer å‘ç”Ÿäº†ä¸€ä¸ª run loop å³å°†è¿›å…¥å¾ªç¯çš„çŠ¶æ€å˜åŒ–ã€‚ 
    if (currentMode->_observerMask & kCFRunLoopEntry) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);
    
    // å¯åŠ¨ run loopï¼Œ__CFRunLoopRun å‡½æ•°è¶…é•¿ï¼Œå¯èƒ½æ˜¯çœ‹æºç ä»¥æ¥æœ€é•¿çš„ä¸€ä¸ªå‡½æ•°ï¼Œä¸‹é¢ä¼šé€è¡Œè¿›è¡Œç»†è‡´çš„åˆ†æ
    // â™»ï¸â™»ï¸â™»ï¸â™»ï¸â™»ï¸â™»ï¸
    result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);
    
    // â¬†ï¸â¬†ï¸â¬†ï¸ __CFRunLoopRun å‡½æ•°å¥½åƒä¹Ÿæ˜¯ä¸ä¼šè¿”å›çš„ï¼Œå½“å®ƒè¿”å›æ—¶å°±ä»£è¡¨å½“å‰çš„ run loop è¦é€€å‡ºäº†ã€‚ 
    
    // åŒä¸Šçš„ kCFRunLoopEntry è¿›å…¥å¾ªç¯çš„å›è°ƒï¼Œè¿™é‡Œåˆ™æ˜¯é€€å‡º run loop çš„å›è°ƒã€‚
    // å¦‚æœ currentMode çš„ _observerMask ä¸­åŒ…å« kCFRunLoopExit çš„å€¼ï¼Œ
    // å³ run loop observer éœ€è¦è§‚å¯Ÿ run loop çš„ kCFRunLoopExit é€€å‡ºçŠ¶æ€åˆ‡æ¢
    if (currentMode->_observerMask & kCFRunLoopExit ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);
    
    // CFRunLoopMode è§£é”
    __CFRunLoopModeUnlock(currentMode);
    
    // é”€æ¯ rl å½“å‰çš„ _perRunDataï¼Œå¹¶æŠŠ previousPerRun é‡æ–°èµ‹å€¼ç»™ rl çš„ _perRunData 
    __CFRunLoopPopPerRunData(rl, previousPerRun);
    
    // å›åˆ°ä¹‹å‰çš„ _currentMode 
    rl->_currentMode = previousMode;
    
    // CFRunLoop è§£é”
    __CFRunLoopUnlock(rl);
    
    // è¿”å› result ç»“æœ
    return result;
}
```
&emsp;è¿™é‡Œéœ€è¦æ³¨æ„çš„ä¸€ä¸ªç‚¹æ˜¯ `CFRunLoopRunSpecific` å‡½æ•°æœ€ååˆæŠŠä¹‹å‰çš„ `previousPerRun` å’Œ `previousMode` é‡æ–°èµ‹å€¼ç»™ run loop çš„ `_perRunData` å’Œ `_currentMode`ï¼Œå®ƒä»¬æ­£æ˜¯ç”¨æ¥å¤„ç† run loop çš„åµŒå¥—è¿è¡Œçš„ã€‚

&emsp;`__CFRunLoopModeIsEmpty` å‡½æ•°å†…éƒ¨ä¸»è¦ç”¨äºåˆ¤æ–­ souces0/source1/timers æ˜¯å¦ä¸ºç©ºï¼ŒåŒæ—¶è¿˜æœ‰åˆ¤æ–­ rl  çš„ block é“¾è¡¨ä¸­åŒ…å«çš„ block æ˜¯å¦èƒ½åœ¨æŒ‡å®šçš„ rlm ä¸‹æ‰§è¡Œã€‚

&emsp;`__CFRunLoopDoObservers` å‡½æ•°æ˜¯ä¸€ä¸ªæé‡è¦çš„å‡½æ•°ï¼Œå®ƒç”¨äºå›è°ƒ run loop å‘ç”Ÿäº†çŠ¶æ€å˜åŒ–ã€‚

&emsp;å½“ run loop çš„çŠ¶æ€å°†è¦ï¼ˆæ³¨æ„è¿™é‡Œæ˜¯å°†è¦ã€å°†è¦ã€å°†è¦... kCFRunLoopExit åˆ™é™¤å¤–ï¼Œé€€å‡ºå›è°ƒæ˜¯çœŸçš„é€€å‡ºå®Œæˆä»¥åçš„å›è°ƒï¼‰å‘ç”Ÿå˜åŒ–æ—¶ï¼Œé¦–å…ˆæ ¹æ® run loop å½“å‰çš„ run loop mode çš„ `_observerMask` æ˜¯å¦åŒ…å«äº†æ­¤çŠ¶æ€çš„å˜åŒ–ï¼Œé‚£ä¹ˆå°±å¯ä»¥è°ƒç”¨ `__CFRunLoopDoObservers` å‡½æ•°æ‰§è¡Œ run loop çŠ¶æ€å˜åŒ–çš„å›è°ƒï¼Œæˆ‘ä»¬åœ¨æ­¤çŠ¶æ€å˜åŒ–é‡Œé¢å¯ä»¥åšå¾ˆå¤šé‡è¦çš„äº‹æƒ…ï¼Œåé¢å­¦ä¹  run loop çš„ä½¿ç”¨åœºæ™¯æ—¶æˆ‘ä»¬å†è¯¦ç»†å­¦ä¹ ã€‚ï¼ˆè¿™é‡Œå›é¡¾ä¸€ä¸‹å‰é¢çœ‹è¿‡çš„ run loop éƒ½æœ‰å“ªäº›çŠ¶æ€å˜åŒ–ï¼šå³å°†è¿›å…¥ run loopã€å³å°†å¤„ç† source äº‹ä»¶ã€å³å°†å¤„ç† timer äº‹ä»¶ã€å³å°†ä¼‘çœ ã€ä¼‘çœ å³å°†ç»“æŸã€run loop é€€å‡ºï¼‰

&emsp;run loop observer çš„å›è°ƒå‡½æ•°ã€‚
```c++
static void __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__() __attribute__((noinline));
static void __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(CFRunLoopObserverCallBack func,
                                                                          CFRunLoopObserverRef observer,
                                                                          CFRunLoopActivity activity,
                                                                          void *info) {
    // å°±æ˜¯ç®€å•çš„å¸¦ç€å‚æ•°è°ƒç”¨ func å‡½æ•°                                                                      
    if (func) {
        func(observer, activity, info);
    }
    
    asm __volatile__(""); // thwart tail-call optimization
}
```

&emsp;\_\_CFRunLoopRun å†…å±‚çš„ do while å¾ªç¯ä¸»è¦æ˜¯ç”¨äº "ä¿æŒ" run looop çš„ç¡çœ çŠ¶æ€çš„ï¼Œç›´åˆ°éœ€è¦è¢«å”¤é†’äº†æ‰ä¼šè·³å‡ºè¿™ä¸ª do while å¾ªç¯ã€‚åªæœ‰åœ¨ä¸‹é¢çš„äº‹ä»¶å‘ç”Ÿæ—¶æ‰ä¼šè¿›è¡Œå”¤é†’ï¼š
1. åŸºäºç«¯å£çš„è¾“å…¥æºï¼ˆport-based input sourceï¼‰ï¼ˆsource1ï¼‰çš„äº‹ä»¶åˆ°è¾¾ã€‚
2. CFRunLoopMode ä¸­çš„ timers è§¦å‘ã€‚ï¼ˆCFRunLoopMode å¯æ·»åŠ å¤šä¸ª timerï¼Œå®ƒä»¬å…±ç”¨ä¸€ä¸ª _timerPort å”¤é†’ run loopï¼Œå¹¶ä¸”ä¼šè®¡ç®—æ‰€æœ‰ timer ä¸­æœ€è¿‘çš„ä¸‹æ¬¡è¦è§¦å‘çš„ timer çš„æ—¶é—´ï¼‰
3. ä¸º run loop è®¾ç½®çš„è¶…æ—¶æ—¶é—´è¿‡æœŸã€‚
4. run loop è¢«æ˜¾å¼å”¤é†’ã€‚ï¼ˆè¢«å…¶ä»–ä»€ä¹ˆè°ƒç”¨è€…æ‰‹åŠ¨å”¤é†’ï¼‰

&emsp;`CFRunLoopWakeUp` å‡½æ•°å†…éƒ¨ï¼Œé€šè¿‡ run loop çš„ `_wakeUpPort` å”¤é†’ç«¯å£æ¥å”¤é†’ run loop å¯¹è±¡ã€‚

&emsp;`__CFRunLoopDoBlocks` å‡½æ•°å†…éƒ¨æ˜¯éå† run loop çš„ block çš„é“¾è¡¨ï¼Œåœ¨æŒ‡å®šçš„ rlm ä¸‹æ‰§è¡Œ blockï¼Œæ‰§è¡Œå®ŒèŠ‚ç‚¹çš„ block ä»¥åä¼šæŠŠè¯¥èŠ‚ç‚¹ä»é“¾è¡¨ä¸­ç§»é™¤ï¼Œæœ€åæ›´æ–°é“¾è¡¨çš„å¤´èŠ‚ç‚¹å’Œå°¾èŠ‚ç‚¹ã€‚

&emsp;`__CFRunLoopDoSources0` å‡½æ•°æ˜¯éå†æ”¶é›† rlm çš„ \_source0 æŠŠ Validã€Signaled çš„ CFRunLoopSourceRef æ”¶é›†èµ·æ¥ï¼Œç„¶åæ‰§è¡Œä»¥ source0 çš„ info ä¸ºå‚æ•°æ‰§è¡Œ source0 çš„ perform å‡½æ•°ï¼Œä¸”ä¼šæŠŠ CFRunLoopSourceRef ç½®ä¸º UnsetSignaledï¼Œç­‰å¾…è¢«å†æ¬¡æ ‡è®°å¹¶æ‰§è¡Œã€‚

&emsp;`__CFRunLoopDoTimers` å‡½æ•°æ‰§è¡Œ CFRunLoopTimerRef çš„å›è°ƒå‡½æ•°å¹¶æ›´æ–°å…¶ `_fireTSR` å’Œ `_nextFireDate`ã€‚

***

## 31. mach_msg å‡½æ•°ã€‚
&emsp;Run Loop æœ€æ ¸å¿ƒçš„äº‹æƒ…å°±æ˜¯ä¿è¯çº¿ç¨‹åœ¨æ²¡æœ‰æ¶ˆæ¯æ—¶ä¼‘çœ ä»¥é¿å…ç³»ç»Ÿèµ„æºå ç”¨ï¼Œæœ‰æ¶ˆæ¯æ—¶èƒ½å¤ŸåŠæ—¶å”¤é†’ã€‚Run Loop çš„è¿™ä¸ªæœºåˆ¶å®Œå…¨ä¾é ç³»ç»Ÿå†…æ ¸æ¥å®Œæˆï¼Œå…·ä½“æ¥è¯´æ˜¯è‹¹æœæ“ä½œç³»ç»Ÿæ ¸å¿ƒç»„ä»¶ Darwin ä¸­çš„ Mach æ¥å®Œæˆçš„ã€‚**Mach ä¸ BSDã€File Systemã€Machã€Networking å…±åŒä½äº Kernel and Device Drivers å±‚ã€‚**

&emsp;åœ¨ Mach ä¸­ï¼Œæ‰€æœ‰çš„ä¸œè¥¿éƒ½æ˜¯é€šè¿‡è‡ªå·±çš„å¯¹è±¡å®ç°çš„ï¼Œè¿›ç¨‹ã€çº¿ç¨‹å’Œè™šæ‹Ÿå†…å­˜éƒ½è¢«ç§°ä¸º â€œå¯¹è±¡â€ï¼Œå’Œå…¶ä»–æ¶æ„ä¸åŒï¼Œ Mach çš„å¯¹è±¡é—´ä¸èƒ½ç›´æ¥è°ƒç”¨ï¼Œåªèƒ½é€šè¿‡æ¶ˆæ¯ä¼ é€’çš„æ–¹å¼å®ç°å¯¹è±¡é—´çš„é€šä¿¡ã€‚â€œæ¶ˆæ¯â€ï¼ˆmach msgï¼‰æ˜¯ Mach ä¸­æœ€åŸºç¡€çš„æ¦‚å¿µï¼Œæ¶ˆæ¯åœ¨ä¸¤ä¸ªç«¯å£ (mach port) ä¹‹é—´ä¼ é€’ï¼Œè¿™å°±æ˜¯ Mach çš„ IPC (è¿›ç¨‹é—´é€šä¿¡) çš„æ ¸å¿ƒã€‚

&emsp;Mach æ˜¯ Darwin çš„æ ¸å¿ƒï¼Œå¯ä»¥è¯´æ˜¯å†…æ ¸çš„æ ¸å¿ƒï¼Œæä¾›äº†è¿›ç¨‹é—´é€šä¿¡ï¼ˆIPCï¼‰ã€å¤„ç†å™¨è°ƒåº¦ç­‰åŸºç¡€æœåŠ¡ã€‚åœ¨ Mach ä¸­ï¼Œè¿›ç¨‹ã€çº¿ç¨‹é—´çš„é€šä¿¡æ˜¯ä»¥æ¶ˆæ¯ï¼ˆmach msgï¼‰çš„æ–¹å¼æ¥å®Œæˆçš„ï¼Œè€Œæ¶ˆæ¯åˆ™æ˜¯åœ¨ä¸¤ä¸ª mach port ä¹‹é—´è¿›è¡Œä¼ é€’ï¼ˆæˆ–è€…è¯´æ˜¯é€šè¿‡ mach port è¿›è¡Œæ¶ˆæ¯çš„ä¼ é€’ï¼‰ï¼ˆè¿™ä¹Ÿæ­£æ˜¯ Source1 ä¹‹æ‰€ä»¥ç§°ä¹‹ä¸º Port-based Source çš„åŸå› ï¼Œå› ä¸ºå®ƒå°±æ˜¯ä¾é  mach msg å‘é€æ¶ˆæ¯åˆ°æŒ‡å®šçš„ mach port æ¥å”¤é†’ run loopï¼‰ã€‚

&emsp;ä¸ºäº†å®ç°æ¶ˆæ¯çš„å‘é€å’Œæ¥æ”¶ï¼Œmach_msg å‡½æ•°å®é™…ä¸Šæ˜¯è°ƒç”¨äº†ä¸€ä¸ª Mach é™·é˜± (trap)ï¼Œå³å‡½æ•° mach_msg_trapï¼Œé™·é˜±è¿™ä¸ªæ¦‚å¿µåœ¨ Mach ä¸­ç­‰åŒäºç³»ç»Ÿè°ƒç”¨ã€‚å½“åœ¨ç”¨æˆ·æ€è°ƒç”¨ mach_msg_trap æ—¶ä¼šè§¦å‘é™·é˜±æœºåˆ¶ï¼Œåˆ‡æ¢åˆ°å†…æ ¸æ€ï¼›å†…æ ¸æ€ä¸­å†…æ ¸å®ç°çš„ mach_msg å‡½æ•°ä¼šå®Œæˆå®é™…çš„å·¥ä½œã€‚

&emsp;run loop çš„æ ¸å¿ƒå°±æ˜¯ä¸€ä¸ª mach_msg ï¼Œrun loop è°ƒç”¨è¿™ä¸ªå‡½æ•°å»æ¥æ”¶æ¶ˆæ¯ï¼Œå¦‚æœæ²¡æœ‰åˆ«äººå‘é€ port æ¶ˆæ¯è¿‡æ¥ï¼Œå†…æ ¸ä¼šå°†çº¿ç¨‹ç½®äºç­‰å¾…çŠ¶æ€ã€‚ä¾‹å¦‚åœ¨æ¨¡æ‹Ÿå™¨é‡Œè·‘èµ·ä¸€ä¸ª iOS çš„ Appï¼Œç„¶ååœ¨ App é™æ­¢æ—¶ç‚¹å‡»æš‚åœï¼Œä¼šçœ‹åˆ°ä¸»çº¿ç¨‹è°ƒç”¨æ ˆæ˜¯åœç•™åœ¨ mach_msg_trap è¿™ä¸ªåœ°æ–¹

&emsp;ï¼ˆmach_msg å‡½æ•°å¯ä»¥è®¾ç½® timeout å‚æ•°ï¼Œå¦‚æœåœ¨ timeout åˆ°æ¥ä¹‹å‰æ²¡æœ‰è¯»åˆ° msgï¼Œå½“å‰çº¿ç¨‹çš„ run loop ä¼šå¤„äºä¼‘çœ çŠ¶æ€ã€‚ï¼‰

&emsp;æ¶ˆæ¯çš„å‘é€å’Œæ¥æ”¶ç»Ÿä¸€ä½¿ç”¨ `mach_msg` å‡½æ•°ï¼Œè€Œ `mach_msg` çš„æœ¬è´¨æ˜¯è°ƒç”¨äº† `mach_msg_trap`ï¼Œè¿™ç›¸å½“äºä¸€ä¸ªç³»ç»Ÿè°ƒç”¨ï¼Œä¼šè§¦å‘å†…æ ¸æ€ä¸ç”¨æˆ·æ€çš„åˆ‡æ¢ã€‚

&emsp;ç‚¹å‡» App å›¾æ ‡ï¼ŒApp å¯åŠ¨å®Œæˆåå¤„äºé™æ­¢çŠ¶æ€ï¼ˆä¸€èˆ¬å¦‚æœæ²¡æœ‰ timer éœ€è¦ä¸€éä¸€éæ‰§è¡Œçš„è¯ï¼‰ï¼Œæ­¤æ—¶ä¸»çº¿ç¨‹çš„ run loop ä¼šè¿›å…¥ä¼‘çœ çŠ¶æ€ï¼Œé€šè¿‡åœ¨ä¸»çº¿ç¨‹çš„ run loop æ·»åŠ  CFRunLoopObserverRef åœ¨å›è°ƒå‡½æ•°ä¸­å¯çœ‹åˆ°ä¸»çº¿ç¨‹çš„ run loop çš„æœ€åæ´»åŠ¨çŠ¶æ€æ˜¯ kCFRunLoopBeforeWaitingï¼Œæ­¤æ—¶ç‚¹å‡» Xcode æ§åˆ¶å°åº•éƒ¨çš„ Pause program execution æŒ‰é’®ï¼Œä» Xcode å·¦ä¾§çš„ Debug navigator å¯çœ‹åˆ°ä¸»çº¿ç¨‹çš„è°ƒç”¨æ ˆåœåœ¨äº† mach_msg_trapã€‚

&emsp;\_timerPort æ˜¯ \__CFRunLoopMode çš„ä¸€ä¸ªæˆå‘˜å˜é‡ã€‚åœ¨ macOS ä¸‹åŒæ—¶æ”¯æŒ dispatch_source å’Œ mk æ„å»º timerï¼Œåœ¨ iOS ä¸‹åˆ™åªæ”¯æŒä½¿ç”¨ mkã€‚è¿™é‡Œæˆ‘ä»¬åªå…³æ³¨ \_timerPortã€‚æˆ‘ä»¬åœ¨ Cocoa Foundation å±‚ä¼šé€šè¿‡æ‰‹åŠ¨åˆ›å»ºå¹¶æ·»åŠ è®¡æ—¶å™¨ NSTimer åˆ°  run loop çš„æŒ‡å®š run loop mode ä¸‹ï¼ŒåŒæ ·åœ¨ Core Foundation å±‚ä¼šé€šè¿‡åˆ›å»º CFRunLoopTimerRef å®ä¾‹å¹¶æŠŠå®ƒæ·»åŠ åˆ° run loop çš„æŒ‡å®š run loop mode ä¸‹ï¼Œå†…éƒ¨å®ç°æ˜¯åˆ™æ˜¯æŠŠ CFRunLoopTimerRef å®ä¾‹æ·»åŠ åˆ° run loop mode çš„ \_timers é›†åˆä¸­ï¼Œå½“ \_timers é›†åˆä¸­çš„è®¡æ—¶å™¨éœ€è¦æ‰§è¡Œæ—¶åˆ™æ­£æ˜¯é€šè¿‡ \_timerPort æ¥å”¤é†’ run loopï¼Œä¸” run loop mode çš„ \_timers é›†åˆä¸­çš„æ‰€æœ‰è®¡æ—¶å™¨å…±ç”¨è¿™ä¸€ä¸ª \_timerPortã€‚

&emsp;è¿™é‡Œæˆ‘ä»¬å¯ä»¥åšä¸€ä¸ªéªŒè¯ï¼Œæˆ‘ä»¬ä¸ºä¸»çº¿ç¨‹æ·»åŠ ä¸€ä¸ª CFRunLoopOberver è§‚å¯Ÿ main run loop çš„çŠ¶æ€å˜åŒ–å’Œä¸€ä¸ª 1 ç§’æ‰§è¡Œä¸€æ¬¡çš„ NSTimerã€‚ç¨‹åºè¿è¡Œåå¯çœ‹åˆ°ä¸€ç›´å¦‚ä¸‹çš„é‡å¤æ‰“å°ï¼š(ä»£ç è¿‡äºç®€å•ï¼Œè¿™é‡Œå°±ä¸è´´å‡ºæ¥äº†)
```c++
...
â°â°â° timer å›è°ƒ...
ğŸ¯... kCFRunLoopBeforeTimers
ğŸ¯... kCFRunLoopBeforeSources
ğŸ¯... kCFRunLoopBeforeWaiting
ğŸ¯... kCFRunLoopAfterWaiting
â°â°â° timer å›è°ƒ...
ğŸ¯... kCFRunLoopBeforeTimers
ğŸ¯... kCFRunLoopBeforeSources
ğŸ¯... kCFRunLoopBeforeWaiting
ğŸ¯... kCFRunLoopAfterWaiting
...
```
&emsp;è®¡æ—¶å™¨åˆ°äº†è§¦å‘æ—¶é—´å”¤é†’ run loopï¼ˆkCFRunLoopAfterWaitingï¼‰æ‰§è¡Œè®¡æ—¶å™¨çš„å›è°ƒï¼Œè®¡æ—¶å™¨å›è°ƒæ‰§è¡Œå®Œæ¯•å run loop åˆè¿›å…¥ä¼‘çœ çŠ¶æ€ï¼ˆkCFRunLoopBeforeWaitingï¼‰ç„¶ååˆ°è¾¾ä¸‹æ¬¡è®¡æ—¶å™¨è§¦å‘æ—¶é—´æ—¶ run loop å†æ¬¡è¢«å”¤é†’ï¼Œå¦‚æœä¸æ‰‹åŠ¨åœæ­¢è®¡æ—¶å™¨çš„è¯åˆ™ä¼šè¿™æ ·ä¸€ç›´æ— é™é‡å¤ä¸‹å»ã€‚ 

## 32. å›é¡¾ run loop mode itemï¼ˆSource0 å’Œ Source1 çš„åŒºåˆ«ï¼‰ã€‚
&emsp;æˆ‘ä»¬é¦–å…ˆå†æ¬¡å›é¡¾ä¸€ä¸‹ Source/Timer/Observerï¼Œå› ä¸º run loop æ­£æ˜¯é€šè¿‡è¿™äº› run loop mode item æ¥å‘å¤–æä¾›åŠŸèƒ½æ”¯æŒçš„ã€‚

1. CFRunLoopSourceRef æ˜¯äº‹ä»¶äº§ç”Ÿçš„åœ°æ–¹ã€‚Source æœ‰ä¸¤ä¸ªç‰ˆæœ¬ï¼šSource0 å’Œ Source1ã€‚
+ Source0 åªåŒ…å«äº†ä¸€ä¸ªå›è°ƒï¼ˆå‡½æ•°æŒ‡é’ˆï¼‰ï¼Œå®ƒå¹¶ä¸èƒ½ä¸»åŠ¨è§¦å‘äº‹ä»¶ã€‚ä½¿ç”¨æ—¶ï¼Œä½ éœ€è¦å…ˆè°ƒç”¨ CFRunLoopSourceSignal(source)ï¼Œå°†è¿™ä¸ª Source æ ‡è®°ä¸ºå¾…å¤„ç†ï¼Œç„¶åæ‰‹åŠ¨è°ƒç”¨ CFRunLoopWakeUp(runloop) æ¥å”¤é†’ run loopï¼Œè®©å…¶å¤„ç†è¿™ä¸ªäº‹ä»¶ã€‚
+ Source1 åŒ…å«äº†ä¸€ä¸ª mach_port å’Œä¸€ä¸ªå›è°ƒï¼ˆå‡½æ•°æŒ‡é’ˆï¼‰ï¼Œè¢«ç”¨äºé€šè¿‡å†…æ ¸å’Œå…¶ä»–çº¿ç¨‹ç›¸äº’å‘é€æ¶ˆæ¯ï¼ˆmach_msgï¼‰ï¼Œè¿™ç§ Source èƒ½ä¸»åŠ¨å”¤é†’ run loop çš„çº¿ç¨‹ã€‚

&emsp;Source0 ä¸­ä»…æœ‰ä¸€äº›å›è°ƒå‡½æ•°ä¼šåœ¨ run loop çš„æœ¬æ¬¡å¾ªç¯ä¸­æ‰§è¡Œï¼Œè€Œ Source1 ä¸­æœ‰ mach port å¯ç”¨æ¥ä¸»åŠ¨å”¤é†’ run loopã€‚

2. CFRunLoopTimerRef æ˜¯åŸºäºæ—¶é—´çš„è§¦å‘å™¨ï¼Œå®ƒå’Œ NSTimer æ˜¯ toll-free bridged çš„ï¼Œå¯ä»¥æ··ç”¨ã€‚å…¶åŒ…å«ä¸€ä¸ªæ—¶é—´é•¿åº¦å’Œä¸€ä¸ªå›è°ƒï¼ˆå‡½æ•°æŒ‡é’ˆï¼‰ã€‚å½“å…¶åŠ å…¥åˆ° run loop æ—¶ï¼Œrun loop ä¼šæ³¨å†Œå¯¹åº”çš„æ—¶é—´ç‚¹ï¼Œå½“æ—¶é—´ç‚¹åˆ°æ—¶ï¼Œrun loopä¼šè¢«å”¤é†’ä»¥æ‰§è¡Œé‚£ä¸ªå›è°ƒã€‚
3. CFRunLoopObserverRef æ˜¯è§‚å¯Ÿè€…ï¼Œæ¯ä¸ª Observer éƒ½åŒ…å«äº†ä¸€ä¸ªå›è°ƒï¼ˆå‡½æ•°æŒ‡é’ˆï¼‰ï¼Œå½“ run loop çš„çŠ¶æ€å‘ç”Ÿå˜åŒ–æ—¶ï¼Œè§‚å¯Ÿè€…å°±èƒ½é€šè¿‡è¿™ä¸ªå›è°ƒæ¥æ”¶åˆ°ã€‚

## 33. run loop æ§åˆ¶è‡ªåŠ¨é‡Šæ”¾æ± çš„ push å’Œ popã€‚
&emsp;è‡ªåŠ¨é‡Šæ”¾æ± ä»€ä¹ˆæ—¶å€™æ‰§è¡Œ pop æ“ä½œæŠŠæ± ä¸­çš„å¯¹è±¡çš„éƒ½æ‰§è¡Œä¸€æ¬¡ release  å‘¢ï¼Ÿè¿™é‡Œè¦åˆ†ä¸¤ç§æƒ…å†µï¼š
+ ä¸€ç§æ˜¯æˆ‘ä»¬æ‰‹åŠ¨ä»¥ `@autoreleasepool {...}`  çš„å½¢å¼æ·»åŠ çš„è‡ªåŠ¨é‡Šæ”¾æ± ï¼Œä½¿ç”¨ clang -rewrite-objc è½¬æ¢ä¸º C++ åå…¶å®æ˜¯
```c++
struct __AtAutoreleasePool {
  __AtAutoreleasePool() {atautoreleasepoolobj = objc_autoreleasePoolPush();}
  ~__AtAutoreleasePool() {objc_autoreleasePoolPop(atautoreleasepoolobj);}
  void * atautoreleasepoolobj;
};

/* @autoreleasepool */ 
{ 
    // ç›´æ¥æ„å»ºäº†ä¸€ä¸ª __AtAutoreleasePool å®ä¾‹ï¼Œ
    // æ„é€ å‡½æ•°è°ƒç”¨äº† AutoreleasePoolPage çš„ push å‡½æ•°ï¼Œæ„å»ºäº†ä¸€ä¸ªè‡ªåŠ¨é‡Šæ”¾æ± ã€‚
    __AtAutoreleasePool __autoreleasepool;
    // ...
}
```
&emsp;å¯çœ‹åˆ° `__autoreleasepool` æ˜¯è¢«åŒ…è£¹åœ¨ä¸€å¯¹ `{}` ä¹‹ä¸­çš„ï¼Œå½“å‡ºäº†å³è¾¹èŠ±æ‹¬å·æ—¶è‡ªåŠ¨é‡Šæ”¾æ± ä¾¿ä¼šæ‰§è¡Œ pop æ“ä½œï¼Œä¹Ÿå¯ç†è§£ä¸ºå¦‚ä¸‹ä»£ç :
```c++
void *pool = objc_autoreleasePoolPush();
// {}ä¸­çš„ä»£ç 
objc_autoreleasePoolPop(pool);
```
&emsp;åœ¨åŸå§‹ main å‡½æ•°ä¸­ï¼Œæ‰“ä¸€ä¸ªæ–­ç‚¹ï¼Œå¹¶å¼€å¯ Debug Workflow çš„ Always Show Disassembly å¯çœ‹åˆ°å¯¹åº”çš„æ±‡ç¼–ä»£ç ï¼š
```c++
int main(int argc, char * argv[]) {
    NSString * appDelegateClassName;
    @autoreleasepool {
        // Setup code that might create autoreleased objects goes here.
        // appDelegateClassName = NSStringFromClass([AppDelegate class]);
    } // â¬…ï¸ åœ¨è¿™é‡Œæ‰“ä¸€ä¸ªæ–­ç‚¹
    return UIApplicationMain(argc, argv, nil, appDelegateClassName);
}
```
&emsp;ç”±äºä¸Šé¢ä»£ç ä¸­è‡ªåŠ¨é‡Šæ”¾æ± ä»€ä¹ˆä¹Ÿæ²¡æœ‰æ”¾ï¼ŒPush å®Œä¾¿æ¥ç€ Pop äº†ã€‚
```c++
...
0x101319b78 <+32>:  bl     0x101319eb8               ; symbol stub for: objc_autoreleasePoolPush
0x101319b7c <+36>:  bl     0x101319eac               ; symbol stub for: objc_autoreleasePoolPop
...
```
+ ä¸€ç§æ˜¯ç”± run loop åˆ›å»ºçš„è‡ªåŠ¨é‡Šæ”¾æ± ã€‚ibireme å¤§ä½¬å¦‚æ˜¯è¯´:
> &emsp;App å¯åŠ¨åï¼Œè‹¹æœåœ¨ä¸»çº¿ç¨‹ RunLoop é‡Œæ³¨å†Œäº†ä¸¤ä¸ª Observerï¼Œå…¶å›è°ƒéƒ½æ˜¯ \_wrapRunLoopWithAutoreleasePoolHandler()ã€‚
> &emsp;ç¬¬ä¸€ä¸ª Observer ç›‘è§†çš„äº‹ä»¶æ˜¯ Entry(å³å°†è¿›å…¥Loop)ï¼Œå…¶å›è°ƒå†…ä¼šè°ƒç”¨ \_objc_autoreleasePoolPush() åˆ›å»ºè‡ªåŠ¨é‡Šæ”¾æ± ã€‚å…¶ order æ˜¯-2147483647ï¼Œä¼˜å…ˆçº§æœ€é«˜ï¼Œä¿è¯åˆ›å»ºé‡Šæ”¾æ± å‘ç”Ÿåœ¨å…¶ä»–æ‰€æœ‰å›è°ƒä¹‹å‰ã€‚
> &emsp;ç¬¬äºŒä¸ª Observer ç›‘è§†äº†ä¸¤ä¸ªäº‹ä»¶ï¼š BeforeWaiting(å‡†å¤‡è¿›å…¥ä¼‘çœ ) æ—¶è°ƒç”¨ \_objc_autoreleasePoolPop() å’Œ \_objc_autoreleasePoolPush() é‡Šæ”¾æ—§çš„æ± å¹¶åˆ›å»ºæ–°æ± ï¼›Exit(å³å°†é€€å‡ºLoop) æ—¶è°ƒç”¨ \_objc_autoreleasePoolPop() æ¥é‡Šæ”¾è‡ªåŠ¨é‡Šæ”¾æ± ã€‚è¿™ä¸ª Observer çš„ order æ˜¯ 2147483647ï¼Œä¼˜å…ˆçº§æœ€ä½ï¼Œä¿è¯å…¶é‡Šæ”¾æ± å­å‘ç”Ÿåœ¨å…¶ä»–æ‰€æœ‰å›è°ƒä¹‹åã€‚
> &emsp;åœ¨ä¸»çº¿ç¨‹æ‰§è¡Œçš„ä»£ç ï¼Œé€šå¸¸æ˜¯å†™åœ¨è¯¸å¦‚äº‹ä»¶å›è°ƒã€Timer å›è°ƒå†…çš„ã€‚è¿™äº›å›è°ƒä¼šè¢« RunLoop åˆ›å»ºå¥½çš„ AutoreleasePool ç¯ç»•ç€ï¼Œæ‰€ä»¥ä¸ä¼šå‡ºç°å†…å­˜æ³„æ¼ï¼Œå¼€å‘è€…ä¹Ÿä¸å¿…æ˜¾ç¤ºåˆ›å»º Pool äº†ã€‚[æ·±å…¥ç†è§£RunLoop](https://blog.ibireme.com/2015/05/18/runloop/)

&emsp;ä¸‹é¢æˆ‘ä»¬è¯•ç€éªŒè¯ä¸€ä¸‹ä¸Šé¢çš„ç»“è®ºï¼Œåœ¨ application:didFinishLaunchingWithOptions: å‡½æ•°ä¸­æ·»åŠ ä¸€ä¸ªæ–­ç‚¹ï¼Œåœ¨æ§åˆ¶å°æ‰“å° po [NSRunLoop mainRunLoop]ï¼Œå¯çœ‹åˆ°åœ¨ main run loop çš„ kCFRunLoopDefaultMode å’Œ UITrackingRunLoopMode æ¨¡å¼ä¸‹çš„ observers ä¸­å‡æœ‰å¦‚ä¸‹ä¸¤ä¸ª CFRunLoopObserverã€‚
```c++
"<CFRunLoopObserver 0x600001c30320 [0x7fff80617cb0]>{valid = Yes, activities = 0x1, repeats = Yes, order = -2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x7fff4808bf54), context = <CFArray 0x60000235dc20 [0x7fff80617cb0]>{type = mutable-small, count = 0, values = ()}}"

"<CFRunLoopObserver 0x600001c30280 [0x7fff80617cb0]>{valid = Yes, activities = 0xa0, repeats = Yes, order = 2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x7fff4808bf54), context = <CFArray 0x60000235dc20 [0x7fff80617cb0]>{type = mutable-small, count = 0, values = ()}}"
```
&emsp;order æ˜¯ -2147483647 çš„ CFRunLoopObserver ä¼˜å…ˆçº§æœ€é«˜ï¼Œä¼šåœ¨å…¶å®ƒæ‰€æœ‰ CFRunLoopObserver ä¹‹å‰å›è°ƒï¼Œç„¶åå®ƒçš„ activities æ˜¯ 0x1ï¼Œå¯¹åº” kCFRunLoopEntry = (1UL << 0)ï¼Œå³åªè§‚å¯Ÿ kCFRunLoopEntry çŠ¶æ€ï¼Œå›è°ƒå‡½æ•°æ˜¯ \_wrapRunLoopWithAutoreleasePoolHandlerï¼Œæ·»åŠ ä¸€ä¸ª \_wrapRunLoopWithAutoreleasePoolHandler ç¬¦å·æ–­ç‚¹ï¼Œæ·»åŠ ä¸€ä¸ª objc_autoreleasePoolPush ç¬¦å·æ–­ç‚¹ï¼Œè¿è¡Œç¨‹åºï¼Œå¹¶åœ¨æ§åˆ¶å° bt æ‰“å°å‡½æ•°å †æ ˆï¼Œç¡®å®èƒ½çœ‹åˆ°å¦‚ä¸‹çš„å‡½æ•°è°ƒç”¨ï¼š
```c++
(lldb) bt
* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 3.1
  * frame #0: 0x00000001dd971864 libobjc.A.dylib`objc_autoreleasePoolPush // push æ„å»ºè‡ªåŠ¨é‡Šæ”¾æ± 
    frame #1: 0x00000001de78d61c CoreFoundation`_CFAutoreleasePoolPush + 16
    frame #2: 0x000000020af66324 UIKitCore`_wrapRunLoopWithAutoreleasePoolHandler + 56
    frame #3: 0x00000001de7104fc CoreFoundation`__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__ + 32 // æ‰§è¡Œ run loop observer å›è°ƒå‡½æ•°ï¼Œ
    frame #4: 0x00000001de70b224 CoreFoundation`__CFRunLoopDoObservers + 412
    frame #5: 0x00000001de70af9c CoreFoundation`CFRunLoopRunSpecific + 412
    frame #6: 0x00000001e090c79c GraphicsServices`GSEventRunModal + 104
    frame #7: 0x000000020af6cc38 UIKitCore`UIApplicationMain + 212
    frame #8: 0x0000000100a75b90 Simple_iOS`main(argc=1, argv=0x000000016f38f8e8) at main.m:77:12
    frame #9: 0x00000001de1ce8e0 libdyld.dylib`start + 4
(lldb) 
```
&emsp;åœ¨ä¸»çº¿ç¨‹ä¸­ç¡®å®çœ‹åˆ°äº† `__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__` æ‰§è¡Œ CFRunLoopObserver çš„å›è°ƒå‡½æ•°è°ƒç”¨äº† `_wrapRunLoopWithAutoreleasePoolHandler` å‡½æ•°æ¥ç€è°ƒç”¨äº† `objc_autoreleasePoolPush` åˆ›å»ºè‡ªåŠ¨é‡Šæ”¾æ± ã€‚

&emsp;order æ˜¯ 2147483647 çš„ CFRunLoopObserver ä¼˜å…ˆçº§æœ€ä½ï¼Œä¼šåœ¨å…¶å®ƒæ‰€æœ‰ CFRunLoopObserver ä¹‹åå›è°ƒï¼Œç„¶åå®ƒçš„ activities æ˜¯ 0xa0ï¼ˆ0b10100000ï¼‰ï¼Œå¯¹åº” kCFRunLoopBeforeWaiting = (1UL << 5) å’Œ kCFRunLoopExit = (1UL << 7)ï¼Œå³è§‚å¯Ÿ run loop çš„å³å°†è¿›å…¥ä¼‘çœ å’Œ run loop é€€å‡ºçš„ä¸¤ä¸ªçŠ¶æ€å˜åŒ–ï¼Œå›è°ƒå‡½æ•°çš„è¯ä¹Ÿæ˜¯ \_wrapRunLoopWithAutoreleasePoolHandlerï¼Œæˆ‘ä»¬å†æ·»åŠ ä¸€ä¸ª objc_autoreleasePoolPop ç¬¦å·æ–­ç‚¹ï¼Œæ­¤æ—¶éœ€è¦æˆ‘ä»¬æ·»åŠ ä¸€äº›æµ‹è¯•ä»£ç ï¼Œæˆ‘ä»¬æ·»åŠ ä¸€ä¸ª main run loop çš„è§‚å¯Ÿè€…ï¼Œç„¶åå†æ·»åŠ ä¸€ä¸ªä¸»çº¿ç¨‹çš„ main run loop çš„ timerï¼Œç¨‹åºå¯åŠ¨åæˆ‘ä»¬å¯çœ‹åˆ°æ§åˆ¶å°å¦‚ä¸‹å¾ªç¯æ‰“å°:
```c++
 ğŸ¯... kCFRunLoopAfterWaiting
 â°â°â° timer å›è°ƒ...
 ğŸ¯... kCFRunLoopBeforeTimers
 ğŸ¯... kCFRunLoopBeforeSources
 ğŸ¯... kCFRunLoopBeforeWaiting
 ğŸ¯... kCFRunLoopAfterWaiting
 â°â°â° timer å›è°ƒ...
```
&emsp;ä¸»çº¿ç¨‹è¿›å…¥äº†ä¸€ç§ â€œä¼‘çœ --è¢« timer å”¤é†’æ‰§è¡Œå›è°ƒ--ä¼‘çœ â€ çš„å¾ªç¯ä¹‹ä¸­ï¼Œæ­¤æ—¶æˆ‘ä»¬æ‰“å¼€ `_wrapRunLoopWithAutoreleasePoolHandler` æ–­ç‚¹å‘ç°ç¨‹åºè¿›å…¥ï¼Œç„¶åå†æ‰“å¼€ objc_autoreleasePoolPop æ–­ç‚¹ï¼Œç„¶åç‚¹å‡» Continue program execution æŒ‰é’®ï¼Œæ­¤æ—¶ä¼šè¿›å…¥ objc_autoreleasePoolPop æ–­ç‚¹ï¼Œåœ¨æ§åˆ¶å° bt æ‰“å°å‡½æ•°è°ƒç”¨æ ˆï¼š
```c++
(lldb) bt
* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1
  * frame #0: 0x00000001dd9718f8 libobjc.A.dylib`objc_autoreleasePoolPop
    frame #1: 0x00000001de78cba0 CoreFoundation`_CFAutoreleasePoolPop + 28
    frame #2: 0x000000020af66360 UIKitCore`_wrapRunLoopWithAutoreleasePoolHandler + 116
    frame #3: 0x00000001de7104fc CoreFoundation`__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__ + 32
    frame #4: 0x00000001de70b224 CoreFoundation`__CFRunLoopDoObservers + 412
    frame #5: 0x00000001de70b7a0 CoreFoundation`__CFRunLoopRun + 1228
    frame #6: 0x00000001de70afb4 CoreFoundation`CFRunLoopRunSpecific + 436
    frame #7: 0x00000001e090c79c GraphicsServices`GSEventRunModal + 104
    frame #8: 0x000000020af6cc38 UIKitCore`UIApplicationMain + 212
    frame #9: 0x0000000100bc9b2c Simple_iOS`main(argc=1, argv=0x000000016f23b8e8) at main.m:76:12
    frame #10: 0x00000001de1ce8e0 libdyld.dylib`start + 4
(lldb)
```
&emsp;ç¡®å®çœ‹åˆ°äº† \_wrapRunLoopWithAutoreleasePoolHandler è°ƒç”¨äº† objc_autoreleasePoolPopã€‚

&emsp;è¿™æ ·æ•´ä½“ä¸‹æ¥ï¼šEntry-->push â¡ï¸ BeforeWaiting--->pop-->push â¡ï¸ Exit-->popï¼ŒæŒ‰ç…§è¿™æ ·çš„é¡ºåºï¼Œä¿è¯äº†åœ¨æ¯æ¬¡ run loop å¾ªç¯ä¸­éƒ½è¿›è¡Œä¸€æ¬¡ push å’Œ popã€‚

&emsp;ä»ä¸Šé¢ run loop observer å·¥ä½œä¾¿çŸ¥ï¼Œæ¯ä¸€æ¬¡ loopï¼Œä¾¿ä¼šæœ‰ä¸€æ¬¡ pop å’Œ pushï¼Œå› æ­¤æˆ‘ä»¬å¾—å‡ºï¼š

1. å¦‚æœæ‰‹åŠ¨æ·»åŠ  autoreleasePoolï¼ŒautoreleasePool ä½œç”¨åŸŸé‡Œçš„è‡ªåŠ¨é‡Šæ”¾å¯¹è±¡ä¼šåœ¨å‡º pool ä½œç”¨åŸŸçš„é‚£ä¸€åˆ»é‡Šæ”¾ã€‚
2. å¦‚æœæ˜¯ run loop è‡ªåŠ¨æ·»åŠ çš„ autoreleasePoolï¼Œé¦–å…ˆåœ¨ run loop å¾ªç¯å¼€å¯æ—¶ push ä¸€ä¸ªæ–°çš„è‡ªåŠ¨é‡Šæ”¾æ± ï¼Œç„¶ååœ¨æ¯ä¸€æ¬¡ run loop å¾ªç¯å°†è¦è¿›å…¥ä¼‘çœ æ—¶ autoreleasePool æ‰§è¡Œ pop æ“ä½œé‡Šæ”¾è¿™æ¬¡å¾ªç¯ä¸­æ‰€æœ‰çš„è‡ªåŠ¨é‡Šæ”¾å¯¹è±¡ï¼Œå¹¶åŒæ—¶å† push ä¸€ä¸ªæ–°çš„è‡ªåŠ¨é‡Šæ”¾æ± åœ¨ä¸‹ä¸€ä¸ª loop å¾ªç¯ä¸­ä½¿ç”¨ï¼Œè¿™æ ·ä¿è¯ run loop çš„æ¯æ¬¡å¾ªç¯ä¸­çš„åˆ›å»ºçš„è‡ªåŠ¨é‡Šæ”¾å¯¹è±¡éƒ½å¾—åˆ°é‡Šæ”¾ï¼Œç„¶ååœ¨ run loop åˆ‡æ¢ mode é€€å‡ºæ—¶ï¼Œå†æ‰§è¡Œæœ€åä¸€æ¬¡ popï¼Œä¿è¯åœ¨ run loop çš„è¿è¡Œè¿‡ç¨‹ä¸­è‡ªåŠ¨é‡Šæ”¾æ± çš„ push å’Œ pop æˆå¯¹å‡ºç°ã€‚

***

## 34. NSTimer çš„ç®€å•ä»‹ç»å’ŒNSTimer çš„å¾ªç¯å¼•ç”¨é—®é¢˜ã€‚
&emsp;NSTimer å¯ä»¥é—®çš„é—®é¢˜è¿˜æŒºå¤šçš„ï¼ŒåŒäº‹å»è…¾è®¯é¢è¯•æ—¶å°±è¢«é—®åˆ° NSTimer æ˜¯æ€ä¹ˆæ‰§è¡Œçš„ï¼Œä¸‹é¢æœ‰ç»“åˆ run loop çš„è¯¦ç»†è®²è§£ã€‚

&emsp;NSTimer.h ä¸­æä¾›äº†ä¸€ç»„ NSTimer çš„åˆ›å»ºæ–¹æ³•ï¼Œå…¶ä¸­ä¸åŒæ„é€ å‡½æ•°çš„ NSInvocationã€SELã€block ç±»å‹çš„å‚æ•°åˆ†åˆ«ä»£è¡¨ NSTimer å¯¹è±¡çš„ä¸åŒçš„å›è°ƒæ–¹å¼ã€‚å…¶ä¸­ block  çš„å›è°ƒå½¢å¼æ˜¯ iOS 10.0 åæ–°å¢çš„ï¼Œå¯ä»¥å¸®åŠ©æˆ‘ä»¬é¿å… NSTimer å¯¹è±¡å’Œå…¶ target å‚æ•°çš„å¾ªç¯å¼•ç”¨é—®é¢˜ï¼Œ`timerWithTimeInterval...` å’Œ `initWithFireDate` è¿”å›çš„ NSTimer å¯¹è±¡è¿˜éœ€è¦æˆ‘ä»¬æ‰‹åŠ¨æ·»åŠ åˆ°å½“å‰çº¿ç¨‹çš„ run loop ä¸­ï¼Œ`scheduledTimerWithTimeInterval...` æ„å»ºçš„ NSTimer å¯¹è±¡åˆ™æ˜¯é»˜è®¤æ·»åŠ åˆ°å½“å‰çº¿ç¨‹çš„ run loop çš„ NSDefaultRunLoopMode æ¨¡å¼ä¸‹çš„ï¼ˆå¿…è¦çš„æƒ…å†µä¸‹æˆ‘ä»¬è¿˜è¦å†è¡¥ä¸€è¡ŒæŠŠ timer æ·»åŠ åˆ°å½“å‰çº¿ç¨‹çš„ run loop çš„ NSRunLoopCommonModes æ¨¡å¼ä¸‹ï¼‰ã€‚

&emsp;block å›è°ƒçš„å½¢å¼éƒ½æœ‰ä¸€ä¸ª `API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0));` æ ‡æ³¨ï¼Œè¡¨ç¤ºæ˜¯ iOS 10 åæ–°å¢çš„ã€‚

&emsp;ä¸‹é¢äº”ä¸ªæ–¹æ³•è¿”å›çš„ NSTimer å¯¹è±¡éœ€è¦æ‰‹åŠ¨è°ƒç”¨ NSRunLoop çš„ `-(void)addTimer:(NSTimer *)timer forMode:(NSRunLoopMode)mode;` å‡½æ•°æ·»åŠ åˆ°æŒ‡å®š run loop çš„æŒ‡å®š mode ä¸‹ã€‚
```c++
+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)ti invocation:(NSInvocation *)invocation repeats:(BOOL)yesOrNo;
+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo;
+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)interval repeats:(BOOL)repeats block:(void (^)(NSTimer *timer))block API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0));
- (instancetype)initWithFireDate:(NSDate *)date interval:(NSTimeInterval)interval repeats:(BOOL)repeats block:(void (^)(NSTimer *timer))block API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0));
- (instancetype)initWithFireDate:(NSDate *)date interval:(NSTimeInterval)ti target:(id)t selector:(SEL)s userInfo:(nullable id)ui repeats:(BOOL)rep NS_DESIGNATED_INITIALIZER;
```
&emsp;ä¸‹é¢ä¸‰ä¸ªæ–¹æ³•è¿”å›çš„ NSTimer å¯¹è±¡ä¼šè¢«è‡ªåŠ¨æ·»åŠ åˆ°å½“å‰çº¿ç¨‹çš„ run loop çš„ default mode ä¸‹ã€‚
```c++
+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)ti invocation:(NSInvocation *)invocation repeats:(BOOL)yesOrNo;
+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo;
+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)interval repeats:(BOOL)repeats block:(void (^)(NSTimer *timer))block API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0));
```
&emsp;å¦‚æœä½¿ç”¨ `scheduledTimerWithTimeInterval...` åˆ™éœ€è¦æ³¨æ„ run loop çš„ mode åˆ‡æ¢åˆ° UITrackingRunLoopMode æ¨¡å¼æ—¶ï¼Œè®¡æ—¶å™¨ä¼šåœæ­¢å›è°ƒï¼Œå½“æ»‘åŠ¨åœæ­¢ run loop åˆ‡å›åˆ° kCFRunLoopDefaultMode æ¨¡å¼æ—¶è®¡æ—¶å™¨åˆå¼€å§‹æ­£å¸¸å›è°ƒï¼Œå¿…è¦æƒ…å†µä¸‹æˆ‘ä»¬éœ€è¦æŠŠ timer æ·»åŠ åˆ°  NSRunLoopCommonModes æ¨¡å¼ä¸‹å¯ä¿è¯ run loop çš„ mode åˆ‡æ¢ä¸å½±å“è®¡æ—¶å™¨çš„å›è°ƒï¼ˆæ­¤æ—¶çš„è®¡æ—¶å™¨å¯¹è±¡ä¼šè¢«åŒæ—¶æ·»åŠ åˆ°å¤šä¸ª common æ ‡è®°çš„ run loop mode çš„ \_timers ä¸­ï¼‰ã€‚

&emsp;è¿˜æœ‰ä¸€ä¸ªçŸ¥è¯†ç‚¹éœ€è¦æ³¨æ„ä¸€ä¸‹ï¼Œæ·»åŠ åˆ° run loop æŒ‡å®š mode ä¸‹çš„ NSTimer ä¼šè¢« mode æ‰€æŒæœ‰ï¼Œå› ä¸ºå®ƒä¼šè¢«åŠ å…¥åˆ° run loop mode çš„ \_timers ä¸­å»ï¼Œå¦‚æœ mode name æ˜¯ NSRunLoopCommonModes çš„è¯ï¼ŒåŒæ—¶è¿˜ä¼šè¢«åŠ å…¥åˆ° run loop çš„ \_commonModeItems ä¸­ï¼Œæ‰€ä»¥å½“ä¸å†éœ€è¦ä½¿ç”¨  NSTimer å¯¹è±¡è®¡æ—¶æ—¶å¿…é¡»è°ƒç”¨ invalidate å‡½æ•°æŠŠå®ƒä» \_timers å’Œ \_commonModeItems é›†åˆä¸­ç§»é™¤ã€‚å¦‚ä¸‹ä»£ç åœ¨ ARC ä¸‹æ‰“å°å„ä¸ªè®¡æ—¶å™¨çš„å¼•ç”¨è®¡æ•°å¯è¿›è¡Œè¯å®ï¼š
```c++
// timer é»˜è®¤æ·»åŠ åˆ° run loop çš„ NSDefaultRunLoopMode ä¸‹ï¼Œå¼•ç”¨è®¡æ•°åº”è¯¥æ˜¯ 3 (è§‰å¾—è¿™é‡Œåº”è¯¥æ˜¯ 2 å‘€ï¼Ÿ)
NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) { }]; // 3

// èµ·å§‹å¼•ç”¨è®¡æ•°æ˜¯ 1
NSTimer *timer2 = [[NSTimer alloc] initWithFireDate:[NSDate date] interval:1 repeats:YES block:^(NSTimer * _Nonnull timer) { }]; // 1
// æŠŠ timer2 æ·»åŠ åˆ° run loop çš„ NSDefaultRunLoopMode æ—¶å¼•ç”¨è®¡æ•° +1  
// è¢« timer2 å’Œ NSDefaultRunLoopMode çš„ _timers æŒæœ‰
[[NSRunLoop currentRunLoop] addTimer:timer2 forMode:NSDefaultRunLoopMode]; // 2

NSTimer *timer3 = [NSTimer timerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) { }]; // 1
[[NSRunLoop currentRunLoop] addTimer:timer3 forMode:NSDefaultRunLoopMode]; // 2

// æŠŠ timer3 æ·»åŠ åˆ° run loop çš„ NSRunLoopCommonModes æ—¶å¼•ç”¨è®¡æ•° +3 
// è¢« timer3ã€UITrackingRunLoopMode çš„ _timersã€NSDefaultRunLoopMode çš„ _timersã€run loop çš„ _commonModeItems æŒæœ‰
[[NSRunLoop currentRunLoop] addTimer:timer3 forMode:NSRunLoopCommonModes]; // 4

// timer3 è°ƒç”¨ invalidate å‡½æ•°åå¼•ç”¨è®¡æ•°å˜å› 1
// è¢«ä»ä¸¤ä¸ª _timers å’Œ _commonModeItems ä¸­ç§»é™¤å -3
[timer3 invalidate]; // 1
```

&emsp;NSTimer åˆ›å»ºæ—¶ä¼šæŒæœ‰ä¼ å…¥çš„ target:
```c++
+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo;
- (instancetype)initWithFireDate:(NSDate *)date interval:(NSTimeInterval)ti target:(id)t selector:(SEL)s userInfo:(nullable id)ui repeats:(BOOL)rep NS_DESIGNATED_INITIALIZER;
+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo;
```
&emsp;ä½¿ç”¨ä»¥ä¸Šä¸‰ä¸ªå‡½æ•°æ„å»ºæˆ–åˆå§‹åŒ– NSTimer å¯¹è±¡æ—¶ï¼ŒNSTimer å¯¹è±¡ä¼šæŒæœ‰ä¼ å…¥çš„ target çš„ï¼Œå› ä¸º NSTimer å¯¹è±¡å›è°ƒæ—¶è¦æ‰§è¡Œ target çš„ aSelector å‡½æ•°ï¼Œå¦‚æœæ­¤æ—¶ target åŒæ—¶ä¹ŸæŒæœ‰ NSTimer å¯¹è±¡çš„è¯åˆ™ä¼šæ„æˆå¾ªç¯å¼•ç”¨å¯¼è‡´å†…å­˜æ³„æ¼ï¼Œä¸€èˆ¬åœ¨ ViewController ä¸­æ·»åŠ  NSTimer å±æ€§ä¼šé‡åˆ°æ­¤é—®é¢˜ã€‚è§£å†³è¿™ä¸ªé—®é¢˜çš„æ–¹æ³•é€šå¸¸æœ‰ä¸¤ç§ï¼šä¸€ç§æ˜¯å°† target åˆ†ç¦»å‡ºæ¥ç‹¬ç«‹æˆä¸€ä¸ªå¯¹è±¡ï¼ˆåœ¨è¿™ä¸ªå¯¹è±¡ä¸­å¼±å¼•ç”¨ NSTimer å¹¶å°†å¯¹è±¡æœ¬èº«ä½œä¸º NSTimer çš„ targetï¼‰ï¼Œæ§åˆ¶å™¨é€šè¿‡è¿™ä¸ªå¯¹è±¡é—´æ¥ä½¿ç”¨ NSTimerï¼›å¦ä¸€ç§æ–¹å¼çš„æ€è·¯ä»ç„¶æ˜¯è½¬ç§» targetï¼Œåªæ˜¯å¯ä»¥ç›´æ¥å¢åŠ  NSTimer æ‰©å±•ï¼ˆåˆ†ç±»ï¼‰ï¼Œè®© NSTimer ç±»å¯¹è±¡åšä¸º targetï¼ŒåŒæ—¶å¯ä»¥å°†æ“ä½œ selector å°è£…åˆ° block ä¸­ï¼Œç¤ºä¾‹ä»£ç å¦‚ä¸‹ã€‚ï¼ˆç±»å¯¹è±¡å…¨å±€å”¯ä¸€ä¸”ä¸éœ€è¦ä¹Ÿä¸èƒ½é‡Šæ”¾ï¼‰[iOSåˆ¨æ ¹é—®åº•-æ·±å…¥ç†è§£RunLoop](https://www.cnblogs.com/kenshincui/p/6823841.html)
```c++
#import "NSTimer+Block.h"

@implementation NSTimer (Block)

- (instancetype)initWithFireDate:(NSDate *)date interval:(NSTimeInterval)seconds repeats:(BOOL)repeats block:(void (^)(void))block {
    // target ä¼ å…¥çš„æ˜¯ self.class å³ NSTimer ç±»å¯¹è±¡ï¼Œç„¶åè®¡æ—¶å™¨çš„å›è°ƒå‡½æ•°å°±æ˜¯ NSTimer ç±»å¯¹è±¡çš„ runBlock: å‡½æ•°ï¼ŒrunBlock æ˜¯ä¸€ä¸ªç±»æ–¹æ³•ï¼Œ
    // æŠŠå›è°ƒçš„ block æ”¾åœ¨ userInfo ä¸­ï¼Œç„¶ååœ¨è®¡æ—¶å™¨çš„è§¦å‘å‡½æ•° runBlock: ä¸­æ ¹æ® NSTimer å¯¹è±¡è¯»å‡ºå…¶ userInfo å³ä¸º blockï¼Œæ‰§è¡Œå³å¯ã€‚
    return [self initWithFireDate:date interval:seconds target:self.class selector:@selector(runBlock:) userInfo:block repeats:repeats];
}

+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)seconds repeats:(BOOL)repeats block:(void (^)(void))block {
    // self å³ä¸º NSTimer ç±»å¯¹è±¡
    return [self scheduledTimerWithTimeInterval:seconds target:self selector:@selector(runBlock:) userInfo:block repeats:repeats];
}

+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)seconds repeats:(BOOL)repeats block:(void (^)(void))block {
    // self å³ä¸º NSTimer ç±»å¯¹è±¡
    return [self timerWithTimeInterval:seconds target:self selector:@selector(runBlock:) userInfo:block repeats:repeats];
}

#pragma mark - Private methods

+ (void)runBlock:(NSTimer *)timer {
    // ä»å…¥å‚ timer å¯¹è±¡ä¸­è¯»å‡º block æ‰§è¡Œ
    if ([timer.userInfo isKindOfClass:NSClassFromString(@"NSBlock")]) {
        void (^block)(void) = timer.userInfo;
        block();
    }
}

@end
```
&emsp;iOS 10.0 ä»¥åè‹¹æœä¹Ÿæä¾›äº† block å½¢å¼çš„ NSTimer æ„å»ºå‡½æ•°ï¼Œæˆ‘ä»¬ç›´æ¥ä½¿ç”¨å³å¯ã€‚ï¼ˆå¤§æ¦‚ç°åœ¨è¿˜æœ‰ iOS 10.0 ä¹‹å‰çš„ç”¨æˆ·å—ï¼‰

&emsp;çœ‹åˆ°è¿™é‡Œä¼šå‘ç°è®¡æ—¶å™¨æ˜¯ä¸èƒ½æš‚åœçš„ï¼Œinvalidate å‡½æ•°æ˜¯ç§»é™¤è®¡æ•°å™¨ä½¿ç”¨çš„ï¼Œæ‰€ä»¥æ— è®ºæ˜¯é‡å¤æ‰§è¡Œçš„è®¡æ—¶å™¨è¿˜æ˜¯ä¸€æ¬¡æ€§çš„è®¡æ—¶å™¨åªè¦è°ƒç”¨ invalidate æ–¹æ³•åˆ™ä¼šå˜å¾—æ— æ•ˆï¼Œåªæ˜¯ä¸€æ¬¡æ€§çš„è®¡æ—¶å™¨æ‰§è¡Œå®Œæ“ä½œåä¼šè‡ªåŠ¨è°ƒç”¨ invalidate æ–¹æ³•ã€‚æ‰€ä»¥æƒ³è¦æš‚åœå’Œæ¢å¤è®¡æ—¶å™¨çš„åªèƒ½ invalidate æ—§è®¡æ—¶å™¨ç„¶åå†æ–°å»ºè®¡æ—¶å™¨ï¼Œä¸”å½“æˆ‘ä»¬ä¸å†éœ€è¦ä½¿ç”¨è®¡æ—¶å™¨æ—¶å¿…é¡»è°ƒç”¨ invalidate æ–¹æ³•ã€‚

***

## 35. NSTimerï¼ˆCFRunLoopTimerRefï¼‰çš„æ‰§è¡Œæµç¨‹ã€‚
&emsp;CFRunLoopTimerRef ä¸ NSTimer æ˜¯å¯ä»¥ toll-free bridgedï¼ˆå…è´¹æ¡¥æ¥è½¬æ¢ï¼‰çš„ã€‚å½“ timer åŠ åˆ° run loop çš„æ—¶å€™ï¼Œrun loop ä¼šæ³¨å†Œå¯¹åº”çš„è§¦å‘æ—¶é—´ç‚¹ï¼Œæ—¶é—´åˆ°äº†ï¼Œrun loop è‹¥å¤„äºä¼‘çœ åˆ™ä¼šè¢«å”¤é†’ï¼Œæ‰§è¡Œ timer å¯¹åº”çš„å›è°ƒå‡½æ•°ã€‚ä¸‹é¢æˆ‘ä»¬æ²¿ç€ CFRunLoopTimerRef çš„æºç æ¥å®Œæ•´åˆ†æä¸€ä¸‹è®¡æ—¶å™¨çš„æµç¨‹ã€‚

&emsp;é¦–å…ˆæ˜¯ CFRunLoopTimerRef çš„åˆ›å»ºå‡½æ•°ï¼š(è¯¦ç»†åˆ†æå¯å‚è€ƒå‰é¢çš„ï¼š[iOS ä»æºç è§£æRun Loop (å››)ï¼šSourceã€Timerã€Observer åˆ›å»ºä»¥åŠæ·»åŠ åˆ° mode çš„è¿‡ç¨‹](https://juejin.cn/post/6908639874857828366))
```c++
CFRunLoopTimerRef CFRunLoopTimerCreate(CFAllocatorRef allocator,
                                       CFAbsoluteTime fireDate,
                                       CFTimeInterval interval,
                                       CFOptionFlags flags,
                                       CFIndex order,
                                       CFRunLoopTimerCallBack callout,
                                       CFRunLoopTimerContext *context);
```
&emsp;`allocator` æ˜¯ CF ä¸‹ä¸ºæ–°å¯¹è±¡åˆ†é…å†…å­˜çš„åˆ†é…å™¨ï¼Œå¯ä¼  NULL æˆ– kCFAllocatorDefaultã€‚

&emsp;`fireDate` æ˜¯è®¡æ—¶å™¨ç¬¬ä¸€æ¬¡è§¦å‘å›è°ƒçš„æ—¶é—´ç‚¹ï¼Œç„¶ååç»­æ²¿ç€ `interval` é—´éš”æ—¶é—´è¿ç»­å›è°ƒã€‚

&emsp;`interval` æ˜¯è®¡æ—¶å™¨çš„è¿ç»­å›è°ƒçš„æ—¶é—´é—´éš”ï¼Œå¦‚æœä¸º 0 æˆ–è´Ÿæ•°ï¼Œè®¡æ—¶å™¨å°†è§¦å‘ä¸€æ¬¡ï¼Œç„¶åè‡ªåŠ¨å¤±æ•ˆã€‚

&emsp;`order` ä¼˜å…ˆçº§ç´¢å¼•ï¼ŒæŒ‡ç¤º CFRunLoopModeRef çš„ _timers ä¸­ä¸åŒè®¡æ—¶å™¨çš„å›è°ƒæ‰§è¡Œé¡ºåºã€‚å½“å‰å¿½ç•¥æ­¤å‚æ•°ï¼Œä¼ é€’ 0ã€‚

&emsp;`callout` è®¡æ—¶å™¨è§¦å‘æ—¶è°ƒç”¨çš„å›è°ƒå‡½æ•°ã€‚

&emsp;`context` ä¿å­˜è®¡æ—¶å™¨çš„ä¸Šä¸‹æ–‡ä¿¡æ¯çš„ç»“æ„ã€‚è¯¥å‡½æ•°å°†ä¿¡æ¯ä»ç»“æ„ä¸­å¤åˆ¶å‡ºæ¥ï¼Œå› æ­¤ä¸Šä¸‹æ–‡æ‰€æŒ‡å‘çš„å†…å­˜ä¸éœ€è¦åœ¨å‡½æ•°è°ƒç”¨ä¹‹åç»§ç»­å­˜åœ¨ã€‚å¦‚æœå›è°ƒå‡½æ•°ä¸éœ€è¦ä¸Šä¸‹æ–‡çš„ä¿¡æ¯æŒ‡é’ˆæ¥è·Ÿè¸ªçŠ¶æ€ï¼Œåˆ™å¯ä»¥ä¸º NULLã€‚å…¶ä¸­çš„ `void * info` å­—æ®µå†…å®¹æ˜¯ `callout` å‡½æ•°æ‰§è¡Œæ—¶çš„å‚æ•°ã€‚

&emsp;CFRunLoopTimerCreate å‡½æ•°ä¸­æ¯”è¾ƒé‡è¦çš„æ˜¯å¯¹è§¦å‘æ—¶é—´çš„è®¾ç½®ï¼š
```c++
...
// #define TIMER_DATE_LIMIT    4039289856.0
// å¦‚æœå…¥å‚ fireDate è¿‡å¤§ï¼Œåˆ™ç½®ä¸º TIMER_DATE_LIMIT
if (TIMER_DATE_LIMIT < fireDate) fireDate = TIMER_DATE_LIMIT;

// ä¸‹æ¬¡è§¦å‘çš„æ—¶é—´
memory->_nextFireDate = fireDate;
memory->_fireTSR = 0ULL;

// å–å¾—å½“å‰æ—¶é—´
uint64_t now2 = mach_absolute_time();
CFAbsoluteTime now1 = CFAbsoluteTimeGetCurrent();

if (fireDate < now1) {
    // å¦‚æœç¬¬ä¸€æ¬¡è§¦å‘çš„æ—¶é—´å·²ç»è¿‡äº†ï¼Œåˆ™æŠŠ _fireTSR ç½®ä¸ºå½“å‰
    memory->_fireTSR = now2;
} else if (TIMER_INTERVAL_LIMIT < fireDate - now1) {
    // å¦‚æœç¬¬ä¸€æ¬¡è§¦å‘çš„æ—¶é—´ç‚¹ä¸å½“å‰æ˜¯æ—¶é—´å·®è·è¶…è¿‡äº† TIMER_INTERVAL_LIMITï¼Œåˆ™æŠŠ _fireTSR ç½®ä¸º TIMER_INTERVAL_LIMIT
    memory->_fireTSR = now2 + __CFTimeIntervalToTSR(TIMER_INTERVAL_LIMIT);
} else {
    // è¿™é‡Œåˆ™æ˜¯æ­£å¸¸çš„ï¼Œå¦‚æœç¬¬ä¸€æ¬¡è§¦å‘çš„æ—¶é—´è¿˜æ²¡æœ‰åˆ°ï¼Œåˆ™æŠŠè§¦å‘æ—¶é—´è®¾ç½®ä¸ºå½“å‰æ—¶é—´å’Œç¬¬ä¸€æ¬¡è§¦å‘æ—¶é—´ç‚¹çš„å·®å€¼
    memory->_fireTSR = now2 + __CFTimeIntervalToTSR(fireDate - now1);
}
...
```
&emsp;è¿™ä¸€éƒ¨åˆ†ä»£ç ä¿è¯è®¡æ—¶å™¨ç¬¬ä¸€æ¬¡è§¦å‘çš„æ—¶é—´ç‚¹æ­£å¸¸ã€‚ä¸‹é¢çœ‹ä¸€ä¸‹æŠŠåˆ›å»ºå¥½çš„ CFRunLoopModeRef æ·»åŠ åˆ°æŒ‡å®šçš„ run loop çš„æŒ‡å®šçš„ run loop mode ä¸‹ã€‚

&emsp;CFRunLoopAddTimer å‡½æ•°ä¸»è¦å®ŒæˆæŠŠ CFRunLoopTimerRef rlt æ’å…¥åˆ° CFRunLoopRef rl çš„ CFStringRef modeName æ¨¡å¼ä¸‹çš„ \_timer é›†åˆä¸­ï¼Œå¦‚æœ modeName æ˜¯ kCFRunLoopCommonModes çš„è¯ï¼Œåˆ™æŠŠ rlt æ’å…¥åˆ° rl çš„ \_commonModeItems ä¸­ï¼Œç„¶åè°ƒç”¨ \__CFRunLoopAddItemToCommonModes å‡½æ•°æŠŠ rlt æ·»åŠ åˆ°æ‰€æœ‰è¢«æ ‡è®°ä¸º common çš„ mode çš„ \_timer ä¸­ï¼ŒåŒæ—¶ä¹Ÿä¼šæŠŠ modeName æ·»åŠ åˆ° rlt çš„ \_rlModes ä¸­ï¼Œè®°å½• rlt éƒ½èƒ½åœ¨é‚£ç§ run loop mode ä¸‹æ‰§è¡Œã€‚ 
```c++
void CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef rlt, CFStringRef modeName);
```
&emsp;ä¸Šé¢æ·»åŠ å®Œæˆåï¼Œä¼šè°ƒç”¨ \__CFRepositionTimerInMode å‡½æ•°ï¼Œç„¶åè°ƒç”¨ \__CFArmNextTimerInModeï¼Œå†è°ƒç”¨ mk_timer_arm å‡½æ•°æŠŠ CFRunLoopModeRef çš„ \_timerPort å’Œä¸€ä¸ªæ—¶é—´ç‚¹æ³¨å†Œåˆ°ç³»ç»Ÿä¸­ï¼Œç­‰å¾…ç€ mach_msg å‘æ¶ˆæ¯å”¤é†’ä¼‘çœ ä¸­çš„ run loop èµ·æ¥æ‰§è¡Œåˆ°è¾¾æ—¶é—´çš„è®¡æ—¶å™¨ã€‚

&emsp;åŒä¸€ä¸ª run loop mode ä¸‹çš„å¤šä¸ª timer å…±äº«åŒä¸€ä¸ª \_timerPortï¼Œè¿™æ˜¯ä¸€ä¸ªå¾ªç¯çš„æµç¨‹ï¼šæ³¨å†Œ timer(mk_timer_arm)â€”æ¥æ”¶ timer(mach_msg)â€”æ ¹æ®å¤šä¸ª timer è®¡ç®—ç¦»å½“å‰æœ€è¿‘çš„ä¸‹æ¬¡å›è°ƒçš„è§¦å‘æ—¶é—´ç‚¹â€”æ³¨å†Œ timer(mk_timer_arm)ã€‚

&emsp;åœ¨ä½¿ç”¨ CFRunLoopAddTimer æ·»åŠ  timer æ—¶çš„è°ƒç”¨å †æ ˆå¦‚ä¸‹ï¼š
```c++
CFRunLoopAddTimer
__CFRepositionTimerInMode
    __CFArmNextTimerInMode
        mk_timer_arm
```
&emsp;ç„¶å mach_msg æ”¶åˆ° timer äº‹ä»¶æ—¶çš„è°ƒç”¨å †æ ˆå¦‚ä¸‹ï¼š
```c++
__CFRunLoopRun
__CFRunLoopDoTimers
    __CFRunLoopDoTimer
        __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__
__CFArmNextTimerInMode
    mk_timer_arm 
```
&emsp;æ¯æ¬¡è®¡æ—¶å™¨éƒ½ä¼šè°ƒç”¨ \__CFArmNextTimerInMode å‡½æ•°ï¼Œæ³¨å†Œè®¡æ—¶å™¨çš„ä¸‹æ¬¡å›è°ƒã€‚ä¼‘çœ ä¸­çš„ run loop é€šè¿‡å½“å‰çš„ run loop mode çš„ \_timerPort ç«¯å£å”¤é†’åï¼Œåœ¨æœ¬æ¬¡ run loop å¾ªç¯ä¸­åœ¨ \__CFRunLoopDoTimers å‡½æ•°ä¸­å¾ªç¯è°ƒç”¨ \__CFRunLoopDoTimer å‡½æ•°ï¼Œæ‰§è¡Œè¾¾åˆ°è§¦å‘æ—¶é—´çš„ timer çš„ \_callout å‡½æ•°ã€‚`__CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(rlt->_callout, rlt, context_info);` æ˜¯æ‰§è¡Œè®¡æ—¶å™¨çš„ \_callout å‡½æ•°ã€‚

***

## 36. NSTimer çš„ä¸å‡†æ—¶é—®é¢˜ã€‚
&emsp;é€šè¿‡ä¸Šé¢çš„ NSTimer æ‰§è¡Œæµç¨‹å¯çœ‹åˆ°è®¡æ—¶å™¨çš„è§¦å‘å›è°ƒå®Œå…¨ä¾èµ– run loop çš„è¿è¡Œï¼ˆmacOS å’Œ iOS ä¸‹éƒ½æ˜¯ä½¿ç”¨ mk_timer æ¥å”¤é†’ run loopï¼‰ï¼Œä½¿ç”¨ NSTimer ä¹‹å‰å¿…é¡»æ³¨å†Œåˆ° run loopï¼Œä½†æ˜¯ run loop ä¸ºäº†èŠ‚çœèµ„æºå¹¶ä¸ä¼šåœ¨éå¸¸å‡†ç¡®çš„æ—¶é—´ç‚¹è°ƒç”¨è®¡æ—¶å™¨ï¼Œå¦‚æœä¸€ä¸ªä»»åŠ¡æ‰§è¡Œæ—¶é—´è¾ƒé•¿ï¼ˆä¾‹å¦‚æœ¬æ¬¡ run loop å¾ªç¯ä¸­ source0 äº‹ä»¶æ‰§è¡Œæ—¶é—´è¿‡é•¿æˆ–è€…è®¡æ—¶å™¨è‡ªèº«å›è°ƒæ‰§è¡Œæ—¶é—´è¿‡é•¿ï¼Œéƒ½ä¼šå¯¼è‡´è®¡æ—¶å™¨ä¸‹æ¬¡æ­£å¸¸æ—¶é—´ç‚¹çš„å›è°ƒè¢«å»¶åæˆ–è€…å»¶åæ—¶é—´è¿‡é•¿çš„è¯åˆ™ç›´æ¥å¿½ç•¥è¿™æ¬¡å›è°ƒï¼ˆè®¡æ—¶å™¨å›è°ƒæ‰§è¡Œä¹‹å‰ä¼šåˆ¤æ–­å½“å‰çš„æ‰§è¡ŒçŠ¶æ€ !__CFRunLoopTimerIsFiring(rlt)ï¼Œå¦‚æœæ˜¯è®¡æ—¶å™¨è‡ªèº«å›è°ƒæ‰§è¡Œæ—¶é—´è¿‡é•¿å¯¼è‡´ä¸‹æ¬¡å›è°ƒè¢«å¿½ç•¥çš„æƒ…å†µå¤§æ¦‚ä¸æ­¤æ ‡è¯†æœ‰å…³ ï¼‰ï¼‰ï¼Œé‚£ä¹ˆå½“é”™è¿‡ä¸€ä¸ªæ—¶é—´ç‚¹ååªèƒ½ç­‰åˆ°ä¸‹ä¸€ä¸ªæ—¶é—´ç‚¹æ‰§è¡Œï¼Œå¹¶ä¸ä¼šå»¶åæ‰§è¡Œï¼ˆNSTimer æä¾›äº†ä¸€ä¸ª tolerance å±æ€§ç”¨äºè®¾ç½®å®½å®¹åº¦ï¼Œå³å½“å‰æ—¶é—´ç‚¹å·²ç»è¿‡äº†è®¡æ—¶å™¨çš„æœ¬æ¬¡è§¦å‘ç‚¹ï¼Œä½†æ˜¯è¶…è¿‡çš„æ—¶é—´é•¿åº¦å°äº tolerance çš„è¯ï¼Œé‚£ä¹ˆæœ¬æ¬¡è®¡æ—¶å™¨å›è°ƒè¿˜å¯ä»¥æ­£å¸¸æ‰§è¡Œï¼Œä¸è¿‡æ˜¯ä¸å‡†æ—¶çš„å»¶åæ‰§è¡Œã€‚ tolerance çš„å€¼é»˜è®¤æ˜¯ 0ï¼Œæœ€å¤§å€¼çš„è¯æ˜¯è®¡æ—¶å™¨é—´éš”æ—¶é—´ \_interval çš„ä¸€åŠï¼Œå¯ä»¥æ ¹æ®è‡ªèº«çš„æƒ…å†µé…Œæƒ…è®¾ç½® tolerance çš„å€¼ï¼Œï¼ˆå…¶å®è¿˜æ˜¯è§‰å¾—å¦‚æœè‡ªå·±çš„è®¡æ—¶å™¨ä¸å‡†æ—¶äº†è¿˜æ˜¯åº”è¯¥ä»è‡ªå·±å†™çš„ä»£ç ä¸­æ‰¾åŸå› ï¼Œè‡ªå·±å»æ‰¾è¯¥ä¼˜åŒ–çš„ç‚¹ï¼Œæˆ–è€…æ˜¯ä¸»çº¿å®åœ¨ä¼˜åŒ–ä¸åŠ¨çš„è¯å°±æŠŠè®¡æ—¶å™¨æ”¾åˆ°å­çº¿ç¨‹ä¸­å»ï¼‰ï¼‰ã€‚

&emsp;ï¼ˆNSTimer ä¸æ˜¯ä¸€ç§å®æ—¶æœºåˆ¶ï¼Œä»¥ main run loop æ¥è¯´å®ƒè´Ÿè´£äº†æ‰€æœ‰çš„ä¸»çº¿ç¨‹äº‹ä»¶ï¼Œä¾‹å¦‚ UI ç•Œé¢çš„æ“ä½œï¼Œè´Ÿè´£çš„è¿ç®—ä½¿å½“å‰ run loop æŒç»­çš„æ—¶é—´è¶…è¿‡äº†è®¡æ—¶å™¨çš„é—´éš”æ—¶é—´ï¼Œé‚£ä¹ˆè®¡æ—¶å™¨ä¸‹ä¸€æ¬¡å›è°ƒå°±è¢«å»¶åï¼Œè¿™æ ·å°±é€ æˆ timer çš„ä¸å‡†æ—¶ï¼Œè®¡æ—¶å™¨æœ‰ä¸ªå±æ€§å«åš tolerance (å®½å®¹åº¦)ï¼Œæ ‡ç¤ºäº†å½“æ—¶é—´ç‚¹åˆ°åï¼Œå®¹è®¸æœ‰å¤šå°‘æœ€å¤§è¯¯å·®ã€‚å¦‚æœå»¶åæ—¶é—´è¿‡é•¿çš„è¯ä¼šç›´æ¥å¯¼è‡´è®¡æ—¶å™¨æœ¬æ¬¡å›è°ƒè¢«å¿½ç•¥ã€‚ï¼‰

&emsp;åœ¨è‹¹æœçš„ Timer æ–‡æ¡£ä¸­å¯çœ‹åˆ°å…³äºè®¡æ—¶ç²¾åº¦çš„æè¿°ï¼š[Timer Programming Topics](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Timers/Articles/timerConcepts.html#//apple_ref/doc/uid/20000806-SW2)
> &emsp;Timing Accuracy
> &emsp;A timer is not a real-time mechanism; it fires only when one of the run loop modes to which the timer has been added is running and able to check if the timerâ€™s firing time has passed. Because of the various input sources a typical run loop manages, the effective resolution of the time interval for a timer is limited to on the order of 50-100 milliseconds. If a timerâ€™s firing time occurs while the run loop is in a mode that is not monitoring the timer or during a long callout, the timer does not fire until the next time the run loop checks the timer. Therefore, the actual time at which the timer fires potentially can be a significant period of time after the scheduled firing time.
> &emsp;
> &emsp;A repeating timer reschedules itself based on the scheduled firing time, not the actual firing time. For example, if a timer is scheduled to fire at a particular time and every 5 seconds after that, the scheduled firing time will always fall on the original 5 second time intervals, even if the actual firing time gets delayed. If the firing time is delayed so far that it passes one or more of the scheduled firing times, the timer is fired only once for that time period; the timer is then rescheduled, after firing, for the next scheduled firing time in the future.

&emsp;è®¡æ—¶å™¨ä¸æ˜¯ä¸€ç§å®æ—¶æœºåˆ¶ï¼›ä»…å½“å·²æ·»åŠ è®¡æ—¶å™¨çš„ run loop mode ä¹‹ä¸€æ­£åœ¨è¿è¡Œå¹¶ä¸”èƒ½å¤Ÿæ£€æŸ¥è®¡æ—¶å™¨çš„è§¦å‘æ—¶é—´æ˜¯å¦ç»è¿‡æ—¶ï¼Œå®ƒæ‰ä¼šè§¦å‘ã€‚ç”±äºå…¸å‹çš„ run loop ç®¡ç†ç€å„ç§è¾“å…¥æºï¼Œå› æ­¤è®¡æ—¶å™¨æ—¶é—´é—´éš”çš„æœ‰æ•ˆåˆ†è¾¨ç‡è¢«é™åˆ¶åœ¨ 50-100 æ¯«ç§’çš„æ•°é‡çº§ã€‚å¦‚æœåœ¨è¿è¡Œå¾ªç¯å¤„äºä¸ç›‘è§†è®¡æ—¶å™¨çš„æ¨¡å¼ä¸‹æˆ–é•¿æ—¶é—´è°ƒç”¨æœŸé—´ï¼Œè®¡æ—¶å™¨çš„è§¦å‘æ—¶é—´å‘ç”Ÿï¼Œåˆ™ç›´åˆ°ä¸‹ä¸€æ¬¡è¿è¡Œå¾ªç¯æ£€æŸ¥è®¡æ—¶å™¨æ—¶ï¼Œè®¡æ—¶å™¨æ‰ä¼šå¯åŠ¨ã€‚å› æ­¤ï¼Œè®¡æ—¶å™¨å¯èƒ½å®é™…è§¦å‘çš„æ—¶é—´å¯èƒ½æ˜¯åœ¨è®¡åˆ’çš„è§¦å‘æ—¶é—´ä¹‹åçš„ç›¸å½“é•¿çš„ä¸€æ®µæ—¶é—´ã€‚

&emsp;é‡å¤è®¡æ—¶å™¨ä¼šæ ¹æ®è®¡åˆ’çš„è§¦å‘æ—¶é—´è€Œä¸æ˜¯å®é™…çš„è§¦å‘æ—¶é—´é‡æ–°å®‰æ’è‡ªèº«çš„æ—¶é—´ã€‚ä¾‹å¦‚ï¼Œå¦‚æœè®¡åˆ’å°†è®¡æ—¶å™¨åœ¨ç‰¹å®šæ—¶é—´è§¦å‘ï¼Œç„¶åæ¯5ç§’è§¦å‘ä¸€æ¬¡ï¼Œåˆ™å³ä½¿å®é™…è§¦å‘æ—¶é—´è¢«å»¶è¿Ÿï¼Œè®¡åˆ’çš„è§¦å‘æ—¶é—´ä¹Ÿå°†å§‹ç»ˆè½åœ¨åŸå§‹çš„5ç§’æ—¶é—´é—´éš”ä¸Šã€‚å¦‚æœè§¦å‘æ—¶é—´å»¶è¿Ÿå¾—å¤ªè¿œï¼Œä»¥è‡³äºè¶…è¿‡äº†è®¡åˆ’çš„è§¦å‘æ—¶é—´ä¸­çš„ä¸€ä¸ªæˆ–å¤šä¸ªï¼Œåˆ™è®¡æ—¶å™¨åœ¨è¯¥æ—¶é—´æ®µä»…è§¦å‘ä¸€æ¬¡ï¼›è®¡æ—¶å™¨ä¼šåœ¨è§¦å‘åé‡æ–°å®‰æ’ä¸ºå°†æ¥çš„ä¸‹ä¸€ä¸ªè®¡åˆ’çš„è§¦å‘æ—¶é—´ã€‚

&emsp;å¦‚ä¸‹ä»£ç ç”³è¯·ä¸€æ¡å­çº¿ç¨‹ç„¶åå¯åŠ¨å®ƒçš„ run loopï¼Œå¯è§‚å¯Ÿ timer å›è°ƒçš„æ—¶é—´ç‚¹ã€‚
```c++
- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view.
    
    NSThread *thread = [[NSThread alloc] initWithBlock:^{
    [NSTimer scheduledTimerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) {
    //  sleep(1);
        NSLog(@"â°â°â° timer å›è°ƒ...");
    }];
    
    // 2 ç§’ååœ¨ thread çº¿ç¨‹ä¸­æ‰§è¡Œ caculate å‡½æ•°
    [self performSelector:@selector(caculate) withObject:nil afterDelay:2];
    
    [[NSRunLoop currentRunLoop] run];
    }];
    [thread start];
}

- (void)caculate {
    NSLog(@"ğŸ‘˜ğŸ‘˜ %@", [NSThread currentThread]);
    sleep(2);
}
```
&emsp;è¿è¡Œä»£ç æ ¹æ®æ‰“å°æ—¶é—´å¯çœ‹åˆ°å‰ä¸¤ç§’è®¡æ—¶å™¨æ­£å¸¸æ‰§è¡Œï¼Œç„¶å caculate çš„æ‰§è¡Œå¯¼è‡´å®šæ—¶å™¨æ‰§è¡Œè¢«å»¶åä¸¤ç§’ï¼Œä¸¤ç§’ä»¥åè®¡æ—¶å™¨ç»§ç»­æ­£å¸¸çš„æ¯ç§’æ‰§è¡Œä¸€æ¬¡ã€‚å¦‚æœæŠŠè®¡æ—¶å™¨çš„å›è°ƒä¸­çš„  sleep(1) æ³¨é‡Šæ‰“å¼€ï¼Œä¼šå‘ç°è®¡æ—¶å™¨æ˜¯æ¯ä¸¤ç§’æ‰§è¡Œä¸€æ¬¡ã€‚

*** 

## 37. performSelector ç³»åˆ—å‡½æ•°
&emsp;å½“è°ƒç”¨ NSObject çš„ performSelecter:afterDelay: åï¼Œå®é™…ä¸Šå…¶å†…éƒ¨ä¼šåˆ›å»ºä¸€ä¸ª Timer å¹¶æ·»åŠ åˆ°å½“å‰çº¿ç¨‹çš„ run loop ä¸­ã€‚æ‰€ä»¥å¦‚æœå½“å‰çº¿ç¨‹æ²¡æœ‰ run loopï¼Œåˆ™è¿™ä¸ªæ–¹æ³•ä¼šå¤±æ•ˆã€‚

&emsp;åœ¨ NSObject çš„ NSDelayedPerforming åˆ†ç±»ä¸‹å£°æ˜äº†å¦‚ä¸‹å‡½æ•°ã€‚ 
```c++
@interface NSObject (NSDelayedPerforming)
// æŒ‡å®š NSRunLoopMode
- (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay inModes:(NSArray<NSRunLoopMode> *)modes;
// é»˜è®¤åœ¨ NSDefaultRunLoopMode
- (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay;

+ (void)cancelPreviousPerformRequestsWithTarget:(id)aTarget selector:(SEL)aSelector object:(nullable id)anArgument;
+ (void)cancelPreviousPerformRequestsWithTarget:(id)aTarget;
@end
```

&emsp;performSelector:withObject:afterDelay:inModes: åœ¨å»¶è¿Ÿä¹‹åä½¿ç”¨æŒ‡å®šçš„æ¨¡å¼åœ¨å½“å‰çº¿ç¨‹ä¸Šè°ƒç”¨æ¥æ”¶æ–¹ï¼ˆNSObject åŠå…¶å­ç±»å¯¹è±¡ï¼‰çš„æ–¹æ³•ã€‚

&emsp;`aSelector`ï¼šä¸€ä¸ªé€‰æ‹©å™¨ï¼Œç”¨äºæ ‡è¯†è¦è°ƒç”¨çš„æ–¹æ³•ã€‚è¯¥æ–¹æ³•åº”è¯¥æ²¡æœ‰æ˜æ˜¾çš„è¿”å›å€¼ï¼ˆvoidï¼‰ï¼Œå¹¶ä¸”åº”è¯¥é‡‡ç”¨ id ç±»å‹çš„å•ä¸ªå‚æ•°ï¼Œæˆ–è€…ä¸å¸¦å‚æ•°ã€‚

&emsp;`anArgument`ï¼šè°ƒç”¨æ—¶ä¼ é€’ç»™æ–¹æ³•çš„å‚æ•°ã€‚å¦‚æœè¯¥æ–¹æ³•ä¸æ¥å—å‚æ•°ï¼Œåˆ™ä¼ é€’ nilã€‚

&emsp;`delay`ï¼šå‘é€æ¶ˆæ¯ä¹‹å‰çš„æœ€çŸ­æ—¶é—´ã€‚æŒ‡å®šå»¶è¿Ÿ 0 ä¸ä¸€å®šä¼šå¯¼è‡´é€‰æ‹©å™¨ç«‹å³æ‰§è¡Œã€‚é€‰æ‹©å™¨ä»åœ¨çº¿ç¨‹çš„ run loop ä¸­æ’é˜Ÿå¹¶å°½å¿«æ‰§è¡Œã€‚

&emsp;`modes`ï¼šä¸€ä¸ªå­—ç¬¦ä¸²æ•°ç»„ï¼Œç”¨äºæ ‡è¯†ä¸æ‰§è¡Œé€‰æ‹©å™¨çš„ timer å…³è”çš„æ¨¡å¼ã€‚æ­¤æ•°ç»„å¿…é¡»è‡³å°‘åŒ…å«ä¸€ä¸ªå­—ç¬¦ä¸²ã€‚å¦‚æœä¸ºæ­¤å‚æ•°æŒ‡å®š nil æˆ–ç©ºæ•°ç»„ï¼Œåˆ™æ­¤æ–¹æ³•å°†è¿”å›è€Œä¸æ‰§è¡ŒæŒ‡å®šçš„é€‰æ‹©å™¨ã€‚

&emsp;æ­¤æ–¹æ³•è®¾ç½®ä¸€ä¸ª timerï¼Œä»¥ä¾¿åœ¨å½“å‰çº¿ç¨‹çš„ run loop ä¸Šæ‰§è¡Œ aSelector æ¶ˆæ¯ã€‚timer é…ç½®åœ¨ modes å‚æ•°æŒ‡å®šçš„æ¨¡å¼ä¸‹è¿è¡Œã€‚å½“ timer è§¦å‘æ—¶ï¼Œçº¿ç¨‹å°è¯•ä» run loop ä¸­å–å‡ºæ¶ˆæ¯å¹¶æ‰§è¡Œé€‰æ‹©å™¨ã€‚å¦‚æœ run loop æ­£åœ¨è¿è¡Œå¹¶ä¸”å¤„äºæŒ‡å®šçš„æ¨¡å¼ä¹‹ä¸€ï¼Œåˆ™å®ƒæˆåŠŸï¼›å¦åˆ™ï¼Œ timer å°†ç­‰å¾…ç›´åˆ° run loop å¤„äºè¿™äº›æ¨¡å¼ä¹‹ä¸€ã€‚å…³äºå®ƒä¼šåœ¨å½“å‰ run loop çš„ run loop mode ä¸‹æ·»åŠ ä¸€ä¸ª timer å¯é€šè¿‡å¦‚ä¸‹ä»£ç éªŒè¯ï¼š
```c++
    NSThread *thread = [[NSThread alloc] initWithBlock:^{
        NSLog(@"ğŸ§—â€â™€ï¸ğŸ§—â€â™€ï¸ ....");

        [NSTimer scheduledTimerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) {
            NSLog(@"â°â°â° timer å›è°ƒ...");
        }];

        [self performSelector:@selector(caculate) withObject:nil afterDelay:2]; // â¬…ï¸ æ–­ç‚¹ 1
        
        NSRunLoop *runloop = [NSRunLoop currentRunLoop]; // â¬…ï¸ æ–­ç‚¹ 2
        [runloop run];
    }];
    [thread start];
```
&emsp;åˆ†åˆ«åœ¨æ‰§è¡Œåˆ°ä»¥ä¸Šä¸¤ä¸ªæ–­ç‚¹æ—¶ï¼Œåœ¨æ§åˆ¶å°é€šè¿‡ `po [NSRunLoop currentRunLoop]` æ‰“å°:
```c++
// æ–­ç‚¹ 1 å¤„ï¼špo [NSRunLoop currentRunLoop]
...
    timers = <CFArray 0x28314e9a0 [0x20e729430]>{type = mutable-small, count = 1, values = (
    0 : <CFRunLoopTimer 0x28204df80 [0x20e729430]>{valid = Yes, firing = No, interval = 1, tolerance = 0, next fire date = 631096717 (-14.273319 @ 16571855540445), callout = (NSTimer) [_NSTimerBlockTarget fire:] (0x1df20764c / 0x1df163018) (/System/Library/Frameworks/Foundation.framework/Foundation), context = <CFRunLoopTimer context 0x28154b900>}
)
...
// æ–­ç‚¹ 2 å¤„ï¼špo [NSRunLoop currentRunLoop]
...
    timers = <CFArray 0x28314e9a0 [0x20e729430]>{type = mutable-small, count = 2, values = (
    0 : <CFRunLoopTimer 0x28204df80 [0x20e729430]>{valid = Yes, firing = No, interval = 1, tolerance = 0, next fire date = 631096717 (-32.979197 @ 16571855540445), callout = (NSTimer) [_NSTimerBlockTarget fire:] (0x1df20764c / 0x1df163018) (/System/Library/Frameworks/Foundation.framework/Foundation), context = <CFRunLoopTimer context 0x28154b900>}
    1 : <CFRunLoopTimer 0x28204db00 [0x20e729430]>{valid = Yes, firing = No, interval = 0, tolerance = 0, next fire date = 631096747 (-2.84795797 @ 16572578697099), callout = (Delayed Perform) ViewController caculate (0x1df1f4094 / 0x10093ab88) (/var/containers/Bundle/Application/C2E33DEA-1FB0-48A0-AEDD-2D13AF564389/Simple_iOS.app/Simple_iOS), context = <CFRunLoopTimer context 0x28003d4c0>}
)
...
```
&emsp;å¯çœ‹åˆ° performSelector:withObject:afterDelay: æ·»åŠ äº†ä¸€ä¸ª timerã€‚

&emsp;å¦‚æœå¸Œæœ›åœ¨ run loop å¤„äºé»˜è®¤æ¨¡å¼ä»¥å¤–çš„æ¨¡å¼æ—¶ä½¿æ¶ˆæ¯å‡ºåˆ—ï¼Œè¯·ä½¿ç”¨ `performSelector:withObject:afterDelay:inModes:` æ–¹æ³•ã€‚å¦‚æœä¸ç¡®å®šå½“å‰çº¿ç¨‹æ˜¯å¦ä¸ºä¸»çº¿ç¨‹ï¼Œå¯ä»¥ä½¿ç”¨ `performSelectorOnMainThread:withObject:waitUntilDone:` æˆ– `performSelectorOnMainThread:withObject:waitUntilDone:modes:` æ–¹æ³•æ¥ç¡®ä¿é€‰æ‹©å™¨åœ¨ä¸»çº¿ç¨‹ä¸Šæ‰§è¡Œã€‚è¦å–æ¶ˆæ’é˜Ÿçš„æ¶ˆæ¯ï¼Œè¯·ä½¿ç”¨ `cancelPreviousPerformRequestsWithTarget:` æˆ– `cancelPreviousPerformRequestsWithTarget:selector:object:` æ–¹æ³•ã€‚

&emsp;æ­¤æ–¹æ³•å‘å…¶å½“å‰ä¸Šä¸‹æ–‡çš„ runloop æ³¨å†Œï¼Œå¹¶ä¾èµ–äºå®šæœŸè¿è¡Œçš„ runloop æ‰èƒ½æ­£ç¡®æ‰§è¡Œã€‚ä¸€ä¸ªå¸¸è§çš„ä¸Šä¸‹æ–‡æ˜¯å½“è°ƒåº¦é˜Ÿåˆ—è°ƒç”¨æ—¶ï¼Œä½ å¯èƒ½è°ƒç”¨æ­¤æ–¹æ³•å¹¶æœ€ç»ˆæ³¨å†Œåˆ°ä¸€ä¸ªä¸è‡ªåŠ¨å®šæœŸè¿è¡Œçš„ runloopã€‚å¦‚æœåœ¨è°ƒåº¦é˜Ÿåˆ—ä¸Šè¿è¡Œæ—¶éœ€è¦æ­¤ç±»åŠŸèƒ½ï¼Œåˆ™åº”ä½¿ç”¨ dispatch_after å’Œç›¸å…³æ–¹æ³•æ¥è·å¾—æ‰€éœ€çš„è¡Œä¸ºã€‚ï¼ˆç±»ä¼¼çš„è¿˜æœ‰ NSTimer ä¸å‡†æ—¶æ—¶ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨ dispatch_source æ¥æ›¿ä»£ï¼‰

## ğŸ‰ğŸ‰ğŸ‰ æœªå®Œå¾…ç»­...
