# iOS 2021 é¢è¯•å‰çš„å‡†å¤‡ï¼ˆæ€»ç»“å„çŸ¥è¯†ç‚¹æ–¹ä¾¿é¢è¯•å‰å¿«é€Ÿå¤ä¹ ä½¿ç”¨ï¼‰ï¼ˆä¸‰ï¼‰

> &emsp;åšä¸»å‰æœŸé€šè¯»äº† Apple çš„äº”ä»½æºç  [objc4-781](https://opensource.apple.com/tarballs/objc4/)ã€[libdispatch-1173.40.5](https://opensource.apple.com/tarballs/libdispatch/)ã€[CF-1151.16](https://opensource.apple.com/tarballs/CF/)ã€[libmalloc-283.100.6](https://opensource.apple.com/tarballs/libmalloc/)ã€[libclosure-74](https://opensource.apple.com/source/libclosure/) åŸºæœ¬å¯¹ iOS çš„å¤§éƒ¨åˆ†åº•å±‚åŸç†éƒ½æœ‰äº†ä¸€ä¸ªåŸºç¡€çš„è®¤çŸ¥ï¼Œç„¶åç®—æ³•éƒ¨åˆ†çš„è¯æ˜¯ä¸“æ³¨åˆ·äº†ä¸¤é ã€Šå‰‘æŒ‡ Offerã€‹ï¼ˆåœ¨ IDE é‡Œå¯ä»¥å®Œæˆé»˜å†™ï¼Œå®Œå…¨æ‰‹å†™çš„è¯å¯èƒ½è¿˜éœ€è¦ä¸€äº›ç»ƒä¹ ï¼‰ã€‚é‚£ä¹ˆæ—¢ç„¶æ˜¯é¢è¯•è‚¯å®šå…ä¸äº†è¦åˆ·é¢˜ï¼Œé¢˜ç›®çš„è¯å°±ä»ç½‘ç»œæœé›†å„ä½å¤§ä½¬é¢è¯•æ—¶çš„é¢˜ç›®ä»¥åŠæœ¬äººé¢è¯•æ—¶è¢«é—®åˆ°çš„é¢˜ç›®ï¼Œç„¶åè¯•ç€ä»è‡ªå·±çš„ç†è§£ä¸Šç»™é¢˜ç›®ä½œå‡ºè§£ç­”ï¼Œå¦‚æœ‰é”™è¯¯çš„åœ°æ–¹è¿˜æœ›å¤§å®¶è¿›è¡ŒæŒ‡æ­£ã€‚   

## 21. dispatch_semaphore çš„å®ç°åŸç†ã€‚
&emsp;dispatch_semaphore æ˜¯ GCD ä¸­æä¾›çš„ä¸€ä¸ªå¾ˆå¸¸ç”¨çš„æ“ä½œï¼Œé€šå¸¸ç”¨äºä¿è¯èµ„æºçš„å¤šçº¿ç¨‹å®‰å…¨æ€§å’Œæ§åˆ¶ä»»åŠ¡çš„å¹¶å‘æ•°é‡ã€‚å…¶æœ¬è´¨å®é™…ä¸Šæ˜¯åŸºäº mach å†…æ ¸çš„ä¿¡å·é‡æ¥å£æ¥å®ç°çš„ã€‚

&emsp;`dispatch_semaphore_t` æ˜¯æŒ‡å‘ `dispatch_semaphore_s` ç»“æ„ä½“çš„æŒ‡é’ˆã€‚é¦–å…ˆçœ‹ä¸€ä¸‹åŸºç¡€çš„æ•°æ®ç»“æ„ã€‚
```c++
struct dispatch_queue_s;

DISPATCH_CLASS_DECL(semaphore, OBJECT);
struct dispatch_semaphore_s {
    DISPATCH_OBJECT_HEADER(semaphore);
    
    // å¯çœ‹åˆ°ä¸ŠåŠéƒ¨åˆ†çš„å®å®šä¹‰å’Œå…¶å®ƒçš„ GCD ç±»æ˜¯ç›¸åŒçš„ï¼Œæ¯•ç«Ÿå¤§å®¶éƒ½æ˜¯ç»§æ‰¿è‡ª dispatch_object_sï¼Œé‡ç‚¹æ˜¯ä¸‹é¢ä¸¤ä¸ªæ–°çš„æˆå‘˜å˜é‡ï¼Œ
    // dsema_value å’Œ dsema_orig æ˜¯ä¿¡å·é‡æ‰§è¡Œä»»åŠ¡çš„å…³é”®ï¼Œæ‰§è¡Œä¸€æ¬¡ dispatch_semaphore_wait æ“ä½œï¼Œdsema_value çš„å€¼å°±åšä¸€æ¬¡å‡æ“ä½œã€‚
    
    long volatile dsema_value;
    long dsema_orig;
    _dispatch_sema4_t dsema_sema;
};
```
&emsp;`dispatch_semaphore_s` ç»“æ„ä½“ä¸­ï¼š`dsema_orig` æ˜¯ä¿¡å·é‡çš„åˆå§‹å€¼ï¼Œ`dsema_value` æ˜¯ä¿¡å·é‡çš„å½“å‰å€¼ï¼Œä¿¡å·é‡çš„ç›¸å…³ API æ­£æ˜¯é€šè¿‡æ“ä½œ `dsema_value` æ¥å®ç°å…¶åŠŸèƒ½çš„ã€‚

&emsp;`dispatch_semaphore_create` ç”¨åˆå§‹å€¼ï¼ˆ`long value`ï¼‰åˆ›å»ºæ–°çš„è®¡æ•°ä¿¡å·é‡ã€‚å½“ä¸¤ä¸ªçº¿ç¨‹éœ€è¦åè°ƒç‰¹å®šäº‹ä»¶çš„å®Œæˆæ—¶ï¼Œå°†å€¼ä¼ é€’ä¸ºé›¶éå¸¸æœ‰ç”¨ã€‚ä¼ é€’å¤§äºé›¶çš„å€¼å¯¹äºç®¡ç†æœ‰é™çš„èµ„æºæ± éå¸¸æœ‰ç”¨ï¼Œè¯¥èµ„æºæ± çš„å¤§å°ç­‰äºè¯¥å€¼ï¼ˆä¾‹å¦‚æˆ‘ä»¬æœ‰å¤šä¸ªæ–‡ä»¶è¦ä»æœåŠ¡å™¨ä¸‹è½½ä¸‹æ¥ï¼Œç„¶åç”¨ dispatch_semaphore é™åˆ¶åªèƒ½å¹¶å‘äº”æ¡çº¿ç¨‹ï¼ˆ`dispatch_semaphore_create(5)`ï¼‰è¿›è¡Œä¸‹è½½ï¼‰ã€‚

&emsp;å‚æ•° `value`ï¼šä¿¡å·é‡çš„èµ·å§‹å€¼ï¼Œä¼ é€’å°äºé›¶çš„å€¼å°†å¯¼è‡´è¿”å› `NULL`ã€‚è¿”å›å€¼ `result`ï¼šæ–°åˆ›å»ºçš„ä¿¡å·é‡ï¼Œå¤±è´¥æ—¶ä¸º `NULL`ã€‚

&emsp;`dispatch_semaphore_wait` ç­‰å¾…ï¼ˆå‡å°‘ï¼‰ä¿¡å·é‡ã€‚
```c++
long
dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)
{
    // åŸå­æ“ä½œ dsema çš„æˆå‘˜å˜é‡ dsema_value çš„å€¼å‡ 1
    long value = os_atomic_dec2o(dsema, dsema_value, acquire);
    
    // å¦‚æœå‡ 1 åä»ç„¶å¤§äºç­‰äº 0ï¼Œåˆ™ç›´æ¥ return 
    if (likely(value >= 0)) {
        return 0;
    }
    
    // å¦‚æœå°äº 0ï¼Œåˆ™è°ƒç”¨ _dispatch_semaphore_wait_slow å‡½æ•°è¿›è¡Œé˜»å¡ç­‰å¾…
    return _dispatch_semaphore_wait_slow(dsema, timeout);
}
```
&emsp;å‡å°‘è®¡æ•°ä¿¡å·é‡ï¼Œå¦‚æœç»“æœå€¼å°äºé›¶ï¼Œæ­¤å‡½æ•°å°†ç­‰å¾…ä¿¡å·å‡ºç°ï¼Œç„¶åè¿”å›ã€‚ï¼ˆå¯ä»¥ä½¿æ€»ä¿¡å·é‡å‡ 1ï¼Œä¿¡å·æ€»é‡å°äº 0 æ—¶å°±ä¼šä¸€ç›´ç­‰å¾…ï¼ˆé˜»å¡æ‰€åœ¨çº¿ç¨‹ï¼‰ï¼Œå¦åˆ™å°±å¯ä»¥æ­£å¸¸æ‰§è¡Œã€‚ï¼‰`dsema`ï¼šä¿¡å·é‡ï¼Œåœ¨æ­¤å‚æ•°ä¸­ä¼ é€’ `NULL` çš„ç»“æœæ˜¯æœªå®šä¹‰çš„ã€‚`timeout`ï¼šä½•æ—¶è¶…æ—¶ï¼ˆdispatch_timeï¼‰ï¼Œä¸ºæ–¹ä¾¿èµ·è§ï¼Œæœ‰ `DISPATCH_TIME_NOW` å’Œ `DISPATCH_TIME_FOREVER` å¸¸é‡ã€‚å‡½æ•°è¿”å›å€¼ `result`ï¼ŒæˆåŠŸè¿”å›é›¶ï¼Œå¦‚æœå‘ç”Ÿè¶…æ—¶åˆ™è¿”å›éé›¶ï¼ˆ`_DSEMA4_TIMEOUT`ï¼‰ã€‚

&emsp;å½“ `timeout` æ˜¯ `DISPATCH_TIME_FOREVER` æ—¶ï¼Œdo while å¾ªç¯ä¸€ç›´ç­‰ä¸‹å»ï¼Œç›´åˆ° `sema` çš„å€¼è¢«ä¿®æ”¹ä¸ºä¸ç­‰äº `KERN_ABORTED`ã€‚
```c++
void
_dispatch_sema4_wait(_dispatch_sema4_t *sema)
{
    kern_return_t kr;
    do {
        kr = semaphore_wait(*sema);
    } while (kr == KERN_ABORTED);
    
    DISPATCH_SEMAPHORE_VERIFY_KR(kr);
}
```
&emsp;å…¶ä¸­è°ƒç”¨äº† mach å†…æ ¸çš„ä¿¡å·é‡æ¥å£ `semaphore_wait` å’Œ `semaphore_timedwait` è¿›è¡Œ wait æ“ä½œã€‚æ‰€ä»¥ï¼ŒGCD çš„ä¿¡å·é‡å®é™…ä¸Šæ˜¯åŸºäº mach å†…æ ¸çš„ä¿¡å·é‡æ¥å£æ¥å®ç°ã€‚`semaphore_timedwait` å‡½æ•°å³å¯ä»¥æŒ‡å®šè¶…æ—¶æ—¶é—´ã€‚

&emsp;`dispatch_semaphore_signal` å‘ä¿¡å·ï¼ˆå¢åŠ ï¼‰ä¿¡å·é‡ã€‚å¦‚æœå…ˆå‰çš„å€¼å°äºé›¶ï¼Œåˆ™æ­¤å‡½æ•°åœ¨è¿”å›ä¹‹å‰å”¤é†’ç­‰å¾…çš„çº¿ç¨‹ã€‚å¦‚æœçº¿ç¨‹è¢«å”¤é†’ï¼Œæ­¤å‡½æ•°å°†è¿”å›éé›¶å€¼ã€‚å¦åˆ™ï¼Œè¿”å›é›¶ã€‚
```c++
long
dispatch_semaphore_signal(dispatch_semaphore_t dsema)
{
    // åŸå­æ“ä½œ dsema çš„æˆå‘˜å˜é‡ dsema_value çš„å€¼åŠ  1
    long value = os_atomic_inc2o(dsema, dsema_value, release);
    
    if (likely(value > 0)) {
        // å¦‚æœ value å¤§äº 0 è¡¨ç¤ºç›®å‰æ²¡æœ‰çº¿ç¨‹éœ€è¦å”¤é†’ï¼Œç›´æ¥ return 0
        return 0;
    }
    
    // å¦‚æœè¿‡åº¦é‡Šæ”¾ï¼Œå¯¼è‡´ value çš„å€¼ä¸€ç›´å¢åŠ åˆ° LONG_MINï¼ˆæº¢å‡ºï¼‰ï¼Œåˆ™ crash 
    if (unlikely(value == LONG_MIN)) {
        DISPATCH_CLIENT_CRASH(value, "Unbalanced call to dispatch_semaphore_signal()");
    }
    
    // value å°äºç­‰äº 0 æ—¶ï¼Œè¡¨ç¤ºç›®å‰æœ‰çº¿ç¨‹éœ€è¦å”¤é†’
    return _dispatch_semaphore_signal_slow(dsema);
}
```

&emsp;`_dispatch_semaphore_signal_slow` å†…éƒ¨è°ƒç”¨ `_dispatch_sema4_signal(&dsema->dsema_sema, 1)` å”¤é†’ä¸€æ¡çº¿ç¨‹ã€‚
```c++
DISPATCH_NOINLINE
long _dispatch_semaphore_signal_slow(dispatch_semaphore_t dsema) {
    _dispatch_sema4_create(&dsema->dsema_sema, _DSEMA4_POLICY_FIFO);
    
    // count ä¼  1ï¼Œå”¤é†’ä¸€æ¡çº¿ç¨‹
    _dispatch_sema4_signal(&dsema->dsema_sema, 1);
    
    return 1;
}
```
&emsp;`semaphore_signal` èƒ½å¤Ÿå”¤é†’ä¸€ä¸ªåœ¨ `semaphore_wait` ä¸­ç­‰å¾…çš„çº¿ç¨‹ã€‚å¦‚æœæœ‰å¤šä¸ªç­‰å¾…çº¿ç¨‹ï¼Œåˆ™æ ¹æ®çº¿ç¨‹ä¼˜å…ˆçº§æ¥å”¤é†’ã€‚
```c++
void
_dispatch_sema4_signal(_dispatch_sema4_t *sema, long count)
{
    do {
        // semaphore_signal å”¤é†’çº¿ç¨‹
        kern_return_t kr = semaphore_signal(*sema);
        DISPATCH_SEMAPHORE_VERIFY_KR(kr);
    } while (--count);
}
```

***

## 22. dispatch_group çš„å®ç°åŸç†ã€‚
&emsp;dispatch_group å¯ä»¥å°†ä¸€ç»„ GCD ä»»åŠ¡å…³è”åˆ°ä¸€èµ·ï¼Œå¯ä»¥ç›‘å¬è¿™ä¸€ç»„æ‰€æœ‰ä»»åŠ¡çš„æ‰§è¡Œæƒ…å†µï¼Œå½“æ‰€æœ‰ä»»åŠ¡å¼‚æ­¥æ‰§è¡Œå®Œæ¯•åæˆ‘ä»¬å¯ä»¥å¾—åˆ°ä¸€ä¸ªæˆ–å¤šä¸ªå›è°ƒé€šçŸ¥ï¼ˆä½¿ç”¨ `dispatch_group_notify` æ·»åŠ å‡ ä¸ªå°±èƒ½æ‰§è¡Œå‡ ä¸ªå›è°ƒé€šçŸ¥ï¼‰ã€‚ï¼ˆdispatch_group ä¸æŒæœ‰ä¸å®ƒç›¸å…³çš„ä»»åŠ¡ blockï¼Œä½†æ˜¯ä¼šé€šè¿‡é“¾è¡¨çš„å½¢å¼æŒæœ‰ `dispatch_group_notify` å‡½æ•°æ·»åŠ çš„å›è°ƒé€šçŸ¥ blockï¼‰

&emsp;`dispatch_group_s` å®šä¹‰å’Œ `dispatch_semaphore_s` å®šä¹‰éƒ½æ˜¯æ”¾åœ¨ semaphore_internal.h æ–‡ä»¶ä¸­ï¼Œè€Œä¸”è¯¥æ–‡ä»¶ä¸­ä»…åŒ…å«å®ƒä¿©çš„å†…å®¹ï¼Œå…¶å®æ–‡ä»¶è¿™æ ·å¸ƒå±€ä¹Ÿæ˜¯æœ‰ç”¨æ„çš„ï¼Œå› ä¸ºå®ƒä¿©çš„å†…éƒ¨å®ç°æœ‰ä¸€äº›ç›¸ä¼¼æ€§ï¼Œdispatch_group åœ¨å†…éƒ¨ä¹Ÿä¼šç»´æŠ¤ä¸€ä¸ªå€¼ï¼Œå½“è°ƒç”¨ `dispatch_group_enter` å‡½æ•°è¿›è¡Œè¿›ç»„æ“ä½œæ—¶ï¼ˆ`dg_bits` - `0x0000000000000004ULL`ï¼‰ï¼Œå½“è°ƒç”¨ `dispatch_group_leave` å‡½æ•°è¿›è¡Œå‡ºç»„æ“ä½œæ—¶ï¼ˆ`dg_state` + `0x0000000000000004ULL`ï¼‰æ—¶å¯¹è¯¥å€¼è¿›è¡Œæ“ä½œï¼ˆè¿™é‡Œå¯ä»¥æŠŠ `dg_bits` å’Œ `dg_state` ç†è§£ä¸ºä¸€ä¸ªå€¼ï¼‰ï¼Œå½“è¯¥å€¼è¾¾åˆ°ä¸´ç•Œå€¼ 0 æ—¶ä¼šåšä¸€äº›åç»­æ“ä½œï¼ˆ`_dispatch_group_wake` å”¤é†’å¼‚æ­¥æ‰§è¡Œ `dispatch_group_notify` å‡½æ•°æ·»åŠ çš„æ‰€æœ‰å›è°ƒé€šçŸ¥ï¼‰ï¼Œä¸”åœ¨ä½¿ç”¨è¿‡ç¨‹ä¸­ä¸€å®šè¦è°¨è®°è¿›ç»„ï¼ˆenterï¼‰å’Œå‡ºç»„ï¼ˆleaveï¼‰å¿…é¡»ä¿æŒå¹³è¡¡ã€‚

&emsp;å‡è®¾ä¸ dispatch_group å…³è”çš„ GCD ä»»åŠ¡æ˜¯ä¸€ä¸ª blockï¼Œdispatch_group å¹¶ä¸æŒæœ‰æ­¤ blockï¼Œç”šè‡³ dispatch_group ä¸æ­¤ block æ²¡æœ‰ä»»ä½•å…³ç³»ï¼Œdispatch_group å†…éƒ¨çš„é‚£ä¸ªå€¼åªæ˜¯ä¸ enter/leave æ“ä½œæœ‰å…³ï¼ŒGCD ä»»åŠ¡åªæ˜¯å€Ÿç”¨äº†æ­¤å€¼ï¼Œä¾‹å¦‚åœ¨åˆ›å»ºå¤šä¸ª GCD å¼‚æ­¥ä»»åŠ¡ä¹‹å‰è°ƒç”¨å¤šæ¬¡ enter æ“ä½œï¼Œç„¶ååœ¨æ¯ä¸ª GCD ä»»åŠ¡ç»“æŸæ—¶è°ƒç”¨ leave æ“ä½œï¼Œå½“è¿™å¤šä¸ª GCD å¼‚æ­¥ä»»åŠ¡éƒ½æ‰§è¡Œå®Œæ¯•ï¼Œé‚£ä¹ˆå¦‚æœ dispatch_group æ·»åŠ äº†å›è°ƒé€šçŸ¥ï¼Œæ­¤æ—¶è‡ªä¼šæ”¶åˆ°å›è°ƒé€šçŸ¥ã€‚å³ä½¿æˆ‘ä»¬ä½¿ç”¨ dispatch_group_async åˆ›å»ºå¤šä¸ª GCD å¼‚æ­¥ä»»åŠ¡ blockï¼Œ è¿™äº› GCD ä»»åŠ¡ block å…¶å®ä¸ dispatch_group ä¹Ÿæ²¡æœ‰ä»»ä½•ç›´æ¥çš„å…³ç³»ã€‚

&emsp;é‚£ä¹ˆä¸è¿™äº› GCD å¼‚æ­¥ä»»åŠ¡ç›¸æ¯”çš„è¯ï¼Œæˆ‘ä»¬ä½¿ç”¨ `dispatch_group_notify` å‡½æ•°æ·»åŠ çš„å¤šä¸ªå›è°ƒé€šçŸ¥çš„ block åˆ™æ˜¯è¢« dispatch_group æ‰€å®Œå…¨æ‹¥æœ‰çš„ï¼Œè¿™äº›å›è°ƒé€šçŸ¥ block ä¼šé“¾æ¥æˆä¸€ä¸ªé“¾è¡¨ï¼Œè€Œ dispatch_group å®ä¾‹åˆ™ç›´æ¥æ‹¥æœ‰æ­¤é“¾è¡¨çš„å¤´èŠ‚ç‚¹å’Œå°¾èŠ‚ç‚¹ã€‚

&emsp;`dispatch_group_t` æ˜¯æŒ‡å‘ `dispatch_group_s` ç»“æ„ä½“çš„æŒ‡é’ˆï¼Œ`dispatch_group_s` ç»“æ„ä½“çš„å®šä¹‰å¦‚ä¸‹ã€‚
```c++
DISPATCH_CLASS_DECL(group, OBJECT);
struct dispatch_group_s {
    DISPATCH_OBJECT_HEADER(group);
    // å¯çœ‹åˆ°ä¸ŠåŠéƒ¨åˆ†å’Œå…¶å®ƒ GCD å¯¹è±¡éƒ½æ˜¯ç›¸åŒçš„ï¼Œæ¯•ç«Ÿå¤§å®¶éƒ½æ˜¯ç»§æ‰¿è‡ª dispatch_object_sï¼Œé‡ç‚¹æ˜¯ä¸‹é¢çš„æ–°å†…å®¹ 
    
    union { 
        uint64_t volatile dg_state;  // leave æ—¶åŠ  DISPATCH_GROUP_VALUE_INTERVAL
        struct { 
            uint32_t dg_bits; // enter æ—¶å‡ DISPATCH_GROUP_VALUE_INTERVAL
            
            // ä¸»è¦ç”¨äº dispatch_group_wait å‡½æ•°è¢«è°ƒç”¨åï¼Œ
            // å½“ dispath_group å¤„äº wait çŠ¶æ€æ—¶ï¼Œç»“æŸç­‰å¾…çš„æ¡ä»¶æœ‰ä¸¤æ¡ï¼š
            // 1): å½“ dispatch_group å…³è”çš„ block éƒ½æ‰§è¡Œå®Œæ¯•åï¼Œwait çŠ¶æ€ç»“æŸ
            // 2): å½“åˆ°è¾¾äº†æŒ‡å®šçš„ç­‰å¾…æ—¶é—´åï¼Œå³ä½¿å…³è”çš„ block æ²¡æœ‰æ‰§è¡Œå®Œæˆï¼Œä¹Ÿç»“æŸ wait çŠ¶æ€ 
            
            // è€Œå½“ dg_gen ä¸ä¸º 0 æ—¶ï¼Œè¯´æ˜ dg_state å‘ç”Ÿäº†è¿›ä½ï¼Œå¯è¡¨ç¤º dispatch_group å…³è”çš„ block éƒ½æ‰§è¡Œå®Œæ¯•äº†ï¼Œ
            // å¦‚æœ dispatch_group æ­¤æ—¶å¤„äº wait çŠ¶æ€çš„è¯å°±å¯ä»¥ç»“æŸäº†ï¼Œæ­¤æ—¶æ­£å¯¹åº”ä¸Šé¢ç»“æŸ wait çŠ¶æ€çš„æ¡ä»¶ 1 ä¸­ã€‚
            uint32_t dg_gen;
        };
    } __attribute__((aligned(8)));
    
    // ä¸‹é¢ä¸¤ä¸ªæˆå‘˜å˜é‡æ¯”è¾ƒç‰¹æ®Šï¼Œå®ƒä»¬åˆ†åˆ«æ˜¯ä¸€ä¸ªé“¾è¡¨çš„å¤´èŠ‚ç‚¹æŒ‡é’ˆå’Œå°¾èŠ‚ç‚¹æŒ‡é’ˆ
    // è°ƒç”¨ dispatch_group_notify å‡½æ•°å¯æ·»åŠ å½“ dispatch_group å…³è”çš„ block å¼‚æ­¥æ‰§è¡Œå®Œæˆåçš„å›è°ƒé€šçŸ¥ï¼Œ
    // å¤šæ¬¡è°ƒç”¨ dispatch_group_notify å‡½æ•°å¯æ·»åŠ å¤šä¸ªå›è°ƒäº‹ä»¶ï¼ˆæˆ‘ä»¬æ—¥å¸¸å¼€å‘ä¸€èˆ¬å°±ç”¨äº†ä¸€ä¸ªå›è°ƒäº‹ä»¶ï¼Œå¯èƒ½ä¼šå¿½ç•¥è¿™ä¸ªç»†èŠ‚ï¼‰ï¼Œ
    // è€Œè¿™äº›å¤šä¸ªå›è°ƒäº‹ä»¶åˆ™ä¼šæ„æˆä¸€ä¸ª dispatch_continuation_s ä½œä¸ºèŠ‚ç‚¹çš„é“¾è¡¨ï¼Œå½“ dispatch_group ä¸­å…³è”çš„ block å…¨éƒ¨æ‰§è¡Œå®Œæˆåï¼Œ
    // æ­¤é“¾è¡¨ä¸­çš„ dispatch_continuation_s éƒ½ä¼šå¾—åˆ°å¼‚æ­¥æ‰§è¡Œã€‚
    //ï¼ˆæ³¨æ„æ˜¯å¼‚æ­¥ï¼Œå…·ä½“åœ¨å“ªä¸ªé˜Ÿåˆ—åˆ™æ ¹æ® dispatch_group_notify å‡½æ•°çš„å…¥å‚å†³å®šï¼Œä»¥åŠæ‰§è¡Œçš„ä¼˜å…ˆçº§åˆ™æ ¹æ®é˜Ÿåˆ—çš„ä¼˜å…ˆçº§å†³å®šï¼‰ã€‚
    
    struct dispatch_continuation_s *volatile dg_notify_head; // dispatch_continuation_s é“¾è¡¨çš„å¤´éƒ¨èŠ‚ç‚¹
    struct dispatch_continuation_s *volatile dg_notify_tail; // dispatch_continuation_s é“¾è¡¨çš„å°¾éƒ¨èŠ‚ç‚¹
};
```
&emsp;`dg_bits` å’Œ `dg_state` æ˜¯è”åˆä½“å…±äº«åŒä¸€å—å†…å­˜ç©ºé—´çš„ä¸åŒåçš„æˆå‘˜å˜é‡ï¼Œè¿›ç»„å’Œå‡ºç»„æ—¶å‡å°‘å’Œå¢åŠ  `DISPATCH_GROUP_VALUE_INTERVAL` æ“ä½œçš„å…¶å®æ˜¯åŒä¸€ä¸ªå€¼ï¼Œå†è¯¦ç»†ä¸€ç‚¹çš„è¯æ˜¯è”åˆä½“å…±å ç”¨ 64 bit ç©ºé—´ï¼Œå…¶ä¸­ uint64_t ç±»å‹çš„ dg_state å¯å å®Œæ•´ 64 bitï¼Œç„¶å uint32_t ç±»å‹çš„ `dg_bits` å’Œ  uint32_t ç±»å‹çš„ `dg_gen` ç»„æˆç»“æ„ä½“å…±å ç”¨è¿™ 64 bitï¼Œå…¶ä¸­ `dg_bits` åœ¨ ä½ 32 bitï¼Œ`dg_gen` åœ¨é«˜ 32 bitã€‚

&emsp; GCD  ä»»åŠ¡ block ä¸ dispatch_group å…³è”çš„æ–¹å¼ï¼š

+ è°ƒç”¨ `dispatch_group_enter` è¡¨ç¤ºä¸€ä¸ª block ä¸ dispatch_group å…³è”ï¼ŒåŒæ—¶ block æ‰§è¡Œå®Œåè¦è°ƒç”¨ `dispatch_group_leave` è¡¨ç¤ºè§£é™¤å…³è”ï¼Œå¦åˆ™ `dispatch_group_s` ä¼šæ°¸è¿œç­‰ä¸‹å»ã€‚
+ è°ƒç”¨ `dispatch_group_async` å‡½æ•°ä¸ block  å…³è”ï¼Œå…¶å®å®ƒæ˜¯åœ¨å†…éƒ¨å°è£…äº†ä¸€å¯¹ enter å’Œ leave æ“ä½œã€‚

&emsp;åœ¨ dispatch_group è¿›è¡Œè¿›ç»„å‡ºç»„æ“ä½œæ¯æ¬¡æ˜¯ç”¨åŠ å‡ 4 ï¼ˆ`DISPATCH_GROUP_VALUE_INTERVAL`ï¼‰æ¥è®°å½•çš„ï¼Œå¹¶ä¸æ˜¯å¸¸è§çš„åŠ  1 å‡ 1ï¼Œç„¶åèµ·å§‹å€¼æ˜¯ä» uint32_t çš„æœ€å°å€¼ 0 å¼€å§‹çš„ï¼Œè¿™é‡Œç”¨äº†ä¸€ä¸ªæ— ç¬¦å·æ•°å’Œæœ‰ç¬¦å·æ•°çš„è½¬æ¢çš„å°æŠ€å·§ï¼Œä¾‹å¦‚ dispatch_group èµ·å§‹çŠ¶æ€æ—¶ uint32_t ç±»å‹çš„ `dg_bits` å€¼ä¸º 0ï¼Œç„¶åç¬¬ä¸€ä¸ª enter æ“ä½œè¿›æ¥ä»¥åï¼ŒæŠŠ uint32_t ç±»å‹çš„ `dg_bits` ä» 0 å‡å» 4ï¼Œç„¶å -4 è½¬æ¢ä¸º uint32_t ç±»å‹åå€¼ä¸º 4294967292ï¼Œç„¶å leave æ“ä½œæ—¶ `dg_bits` åŠ  4ï¼Œå³ 4294967292 åŠ  4ï¼Œè¿™æ ·ä¼šä½¿ uint32_t ç±»å‹å€¼æº¢å‡ºç„¶å `dg_bits` å€¼å°±å˜å› 0 äº†ï¼ˆuint32_t ç±»å‹çš„æœ€å°å€¼ï¼‰ï¼Œå¯¹åº”åˆ° dispatch_group ä¸­çš„é€»è¾‘åŸç†å³è¡¨ç¤º `dg_bits` è¾¾åˆ°ä¸´ç•Œå€¼äº†ï¼Œè¡¨ç¤ºä¸ç»„å…³è”çš„ block éƒ½æ‰§è¡Œå®Œæˆäº†ï¼Œå¯ä»¥æ‰§è¡Œåç»­çš„å”¤é†’æ“ä½œäº†ã€‚

&emsp;è¿˜æœ‰ä¸€ç‚¹ï¼Œ`dg_bits` ä½¿ç”¨ 32 bit ç©ºé—´å¯¹åº”ä½¿ç”¨ uint32_t ç±»å‹ï¼Œç„¶å `DISPATCH_GROUP_VALUE_INTERVAL`ï¼ˆé—´éš”ï¼‰ç”¨ 4 æ˜¯å› ä¸º uint32_t ç±»å‹è¡¨ç¤ºçš„æ•°å­—ä¸ªæ•°åˆšå¥½æ˜¯ 4 çš„æ•´æ•°å€å—ï¼Œä¸è¿‡åªè¦æ˜¯ 2 çš„å¹‚éƒ½æ˜¯æ•´æ•°å€ï¼Œä¸” uint32_t ç±»å‹çš„æ•°å­—å³ä½¿ä»¥ 4 ä¸ºé—´éš”è¡¨ç¤ºçš„æ•°å­—ä¸ªæ•°ä¹Ÿå®Œå…¨è¶³å¤Ÿä½¿ç”¨äº†ï¼Œ è¿™é‡Œçš„è¿˜åŒ…æ‹¬äº†æ©ç çš„ä½¿ç”¨ï¼Œ4 çš„äºŒè¿›åˆ¶è¡¨ç¤ºæ—¶åä¸¤ä½æ˜¯ 0ï¼Œæ­£å¥½å¯ä»¥ç”¨æ¥è¡¨ç¤ºä¸¤ä¸ªæ©ç ä½ï¼Œä»…åä¸¤ä½æ˜¯ 1 æ—¶åˆ†åˆ«å¯¹åº” `DISPATCH_GROUP_HAS_NOTIFS`ï¼ˆè¡¨ç¤º dispatch_group æ˜¯å¦æœ‰ notify å›è°ƒé€šçŸ¥çš„æ©ç ï¼‰å’Œ `DISPATCH_GROUP_HAS_WAITERS`ï¼ˆå¯¹åº” dispatch_group_wait å‡½æ•°çš„ä½¿ç”¨ï¼Œè¡¨ç¤º dispatch_group æ˜¯å¦å¤„äºç­‰å¾…çŠ¶æ€çš„æ©ç ï¼‰ã€‚

&emsp;`dispatch_group_async` å°†ä¸€ä¸ª block æäº¤åˆ°æŒ‡å®šçš„è°ƒåº¦é˜Ÿåˆ—å¹¶è¿›è¡Œå¼‚æ­¥è°ƒç”¨ï¼Œå¹¶å°†è¯¥ block ä¸ç»™å®šçš„ dispatch_group å…³è”ï¼ˆå…¶å†…éƒ¨è‡ªåŠ¨æ’å…¥äº† `dispatch_group_enter` å’Œ `dispatch_group_leave` æ“ä½œï¼Œç›¸å½“äº `dispatch_async` å’Œ `dispatch_group_enter`ã€`dispatch_group_leave` ä¸‰ä¸ªå‡½æ•°çš„ä¸€ä¸ªå°è£…ï¼‰ã€‚å’Œæˆ‘ä»¬è‡ªå·±æ‰‹åŠ¨è°ƒç”¨ enterã€leaveã€dispatch_async ç›¸æ¯” dispatch_group_async è½»æ¾äº†ä¸å°‘ï¼Œå¯ä»¥è®©æˆ‘ä»¬æ›´ä¸“æ³¨äº GCD ä»»åŠ¡çš„ç¼–å†™ã€‚

&emsp;è¿˜æœ‰ä¸€ä¸ªç‚¹è¿™é‡Œè¦æ³¨æ„ä¸€ä¸‹ï¼ŒæŠŠå…¥å‚ block `db` å°è£…æˆ `dispatch_continuation_t`  `dc` çš„è¿‡ç¨‹ä¸­ï¼Œä¼šæŠŠ `dc_flags` è®¾ç½®ä¸º `DC_FLAG_CONSUME | DC_FLAG_GROUP_ASYNC`ï¼Œè¿™é‡Œçš„ `DC_FLAG_GROUP_ASYNC` æ ‡å¿—å…³ç³»åˆ° `dc` æ‰§è¡Œçš„æ—¶å€™è°ƒç”¨çš„å…·ä½“å‡½æ•°ï¼ˆè¿™é‡Œçš„æäº¤çš„ä»»åŠ¡çš„ block å’Œ dispatch_group å…³è”çš„ç‚¹å°±åœ¨è¿™é‡Œï¼Œ`dc` æ‰§è¡Œæ—¶ä¼šè°ƒç”¨ `_dispatch_continuation_with_group_invoke(dc)`ï¼Œè€Œæˆ‘ä»¬æ—¥å¸¸ä½¿ç”¨çš„ `dispatch_async` å‡½æ•°æäº¤çš„å¼‚æ­¥ä»»åŠ¡çš„ block æ‰§è¡Œçš„æ—¶å€™è°ƒç”¨çš„æ˜¯ `_dispatch_client_callout(dc->dc_ctxt, dc->dc_func)` å‡½æ•°ï¼Œå®ƒä»¬æ­£æ˜¯æ ¹æ® `dc_flags` ä¸­çš„ `DC_FLAG_GROUP_ASYNC` æ ‡è¯†æ¥åŒºåˆ†çš„ã€‚

&emsp;`dispatch_group_notify` å‡½æ•°ï¼Œå½“ä¸ dispatch_group ç›¸å…³è”çš„æ‰€æœ‰ block éƒ½å·²å®Œæˆæ—¶ï¼Œè®¡åˆ’å°† `db` æäº¤åˆ°é˜Ÿåˆ— `dq`ï¼ˆå³å½“ä¸ dispatch_group ç›¸å…³è”çš„æ‰€æœ‰ block éƒ½å·²å®Œæˆæ—¶ï¼Œnotify æ·»åŠ çš„å›è°ƒé€šçŸ¥å°†å¾—åˆ°æ‰§è¡Œï¼‰ã€‚å¦‚æœæ²¡æœ‰ block ä¸ dispatch_group ç›¸å…³è”ï¼Œåˆ™é€šçŸ¥å— `db` å°†ç«‹å³æäº¤ã€‚å¦‚ä¸‹ä»£ç ä¸­é€šçŸ¥å— `db` å°†ç«‹å³è¢«è°ƒç”¨ã€‚

```c++
dispatch_group_t group = dispatch_group_create();
// dispatch_group_notify æäº¤çš„å›è°ƒ block ç«‹å³å¾—åˆ°æ‰§è¡Œ
dispatch_group_notify(group, globalQueue, ^{
    NSLog(@"ğŸƒâ€â™€ï¸ %@", [NSThread currentThread]);
});
// æ§åˆ¶å°æ‰“å°:
 ğŸƒâ€â™€ï¸ <NSThread: 0x600000fcbe00>{number = 5, name = (null)}
```

&emsp;é€šçŸ¥å— `db` æäº¤åˆ°ç›®æ ‡é˜Ÿåˆ— `dq` æ—¶ï¼Œè¯¥ dispatch_group å…³è”çš„ block å°†ä¸ºç©ºï¼Œæˆ–è€…è¯´åªæœ‰è¯¥ dispatch_group å…³è”çš„ block ä¸ºç©ºæ—¶ï¼Œé€šçŸ¥å— `db` æ‰ä¼šæäº¤åˆ°ç›®æ ‡é˜Ÿåˆ— `dq`ã€‚æ­¤æ—¶å¯ä»¥é€šè¿‡ `dispatch_release` é‡Šæ”¾ dispatch_groupï¼Œä¹Ÿå¯ä»¥é‡æ–°ç”¨äºå…¶ä»–æ“ä½œã€‚

&emsp;`dispatch_group_notify` å‡½æ•°ä¸ä¼šé˜»å¡å½“å‰çº¿ç¨‹ï¼Œæ­¤å‡½æ•°ä¼šç«‹å³è¿”å›ï¼Œå¦‚æœæˆ‘ä»¬æƒ³é˜»å¡å½“å‰çº¿ç¨‹ï¼Œæƒ³è¦ç­‰ dispatch_group ä¸­å…³è”çš„ block å…¨éƒ¨æ‰§è¡Œå®Œæˆåæ‰æ‰§è¡Œæ¥ä¸‹æ¥çš„æ“ä½œæ—¶ï¼Œå¯ä»¥ä½¿ç”¨ `dispatch_group_wait` å‡½æ•°å¹¶æŒ‡å®šå…·ä½“çš„ç­‰å¾…æ—¶é—´ï¼ˆ`DISPATCH_TIME_FOREVER`ï¼‰ã€‚

&emsp;`os_atomic_rmw_loop2o` æ˜¯ä¸€ä¸ªå®å®šä¹‰ï¼Œå†…éƒ¨åŒ…è£¹äº†ä¸€ä¸ª do while å¾ªç¯ï¼Œç›´åˆ° old_state == 0 æ—¶è·³å‡ºå¾ªç¯æ‰§è¡Œ `_dispatch_group_wake` å‡½æ•°å”¤é†’æ‰§è¡Œ notify é“¾è¡¨ä¸­çš„å›è°ƒé€šçŸ¥ï¼Œå³å¯¹åº”æˆ‘ä»¬ä¸Šæ–‡ä¸­çš„ `dispatch_group_leave` å‡½æ•°ä¸­ `dg_bits` çš„å€¼å›åˆ° 0 è¡¨ç¤º `dispatch_group` ä¸­å…³è”çš„ block éƒ½æ‰§è¡Œå®Œäº†ã€‚

&emsp;`dispatch_group_wait` å‡½æ•°åŒæ­¥ç­‰å¾…ç›´åˆ°ä¸ dispatch_group å…³è”çš„æ‰€æœ‰ block éƒ½å¼‚æ­¥æ‰§è¡Œå®Œæˆæˆ–è€…ç›´åˆ°æŒ‡å®šçš„è¶…æ—¶æ—¶é—´è¿‡å»ä¸ºæ­¢ï¼Œæ‰ä¼šè¿”å›ã€‚å¦‚æœæ²¡æœ‰ä¸ dispatch_group å…³è”çš„ blockï¼Œåˆ™æ­¤å‡½æ•°å°†ç«‹å³è¿”å›ã€‚ä»å¤šä¸ªçº¿ç¨‹åŒæ—¶ä½¿ç”¨åŒä¸€ dispatch_group è°ƒç”¨æ­¤å‡½æ•°çš„ç»“æœæ˜¯ä¸ç¡®å®šçš„ã€‚æˆåŠŸè¿”å›æ­¤å‡½æ•°åï¼Œdispatch_group å…³è”çš„ block ä¸ºç©ºï¼Œå¯ä»¥ä½¿ç”¨ `dispatch_release` é‡Šæ”¾ dispatch_groupï¼Œä¹Ÿå¯ä»¥å°†å…¶é‡æ–°ç”¨äºå…¶å®ƒ blockã€‚

&emsp;`dispatch_group_wait` å‡½æ•°å†…éƒ¨ä½¿ç”¨åŒä¸Šé¢çš„ os_atomic_rmw_loop2o å®å®šä¹‰ï¼Œå†…éƒ¨æ˜¯ä¸€ä¸ª do while å¾ªç¯ï¼Œæ¯æ¬¡å¾ªç¯éƒ½ä»æœ¬åœ°åŸå­å–å€¼ï¼Œåˆ¤æ–­ dispatch_group æ‰€å¤„çš„çŠ¶æ€ï¼Œæ˜¯å¦å…³è”çš„ block éƒ½å¼‚æ­¥æ‰§è¡Œå®Œæ¯•äº†ã€‚

&emsp;`_dispatch_group_wake` æŠŠ  notify å›è°ƒå‡½æ•°é“¾è¡¨ä¸­çš„æ‰€æœ‰çš„å‡½æ•°æäº¤åˆ°æŒ‡å®šçš„é˜Ÿåˆ—ä¸­å¼‚æ­¥æ‰§è¡Œï¼Œ`needs_release` è¡¨ç¤ºæ˜¯å¦éœ€è¦é‡Šæ”¾æ‰€æœ‰å…³è” block å¼‚æ­¥æ‰§è¡Œå®Œæˆã€æ‰€æœ‰çš„ notify å›è°ƒå‡½æ•°æ‰§è¡Œå®Œæˆçš„ dispatch_group å¯¹è±¡ã€‚`dg_state` åˆ™æ˜¯ dispatch_group çš„çŠ¶æ€ï¼ŒåŒ…å«ç›®å‰çš„å…³è”çš„ block æ•°é‡ç­‰ä¿¡æ¯ã€‚

## 23. dispatch_barrier_async çš„å®ç°åŸç†ã€‚
&emsp;`dispatch_barrier_async` æäº¤ barrier block ä»¥åœ¨æŒ‡å®šçš„è°ƒåº¦é˜Ÿåˆ—ä¸Šå¼‚æ­¥æ‰§è¡Œï¼ŒåŒ `dispatch_async` å‡½æ•°ä¸€æ ·ä¸ä¼šé˜»å¡å½“å‰çº¿ç¨‹ï¼Œæ­¤å‡½æ•°ä¼šç›´æ¥è¿”å›å¹¶æ‰§è¡Œæ¥ä¸‹æ¥çš„å‡½æ•°è¯­å¥ã€‚`dispatch_barrier_async` çš„ä½œç”¨æ˜¯å¯¹æ·»åŠ åˆ°åŒä¸€å¹¶å‘é˜Ÿåˆ—ä¸­çš„å¼‚æ­¥ä»»åŠ¡ä½œå‡º â€œæ’åºâ€ã€‚

```c++
- (void)viewDidLoad {
    [super viewDidLoad];
    
    dispatch_queue_t concurrentQueue = dispatch_queue_create("com.concurrent", DISPATCH_QUEUE_CONCURRENT);
    
    NSLog(@"ğŸ” START: %@", [NSThread currentThread]);
    
    dispatch_async(concurrentQueue, ^{ sleep(3); NSLog(@"ğŸƒâ€â™€ï¸ %@", [NSThread currentThread]);}); // â¬…ï¸ ä»»åŠ¡ä¸€
    dispatch_async(concurrentQueue, ^{ sleep(4); NSLog(@"ğŸƒâ€â™€ï¸ğŸƒâ€â™€ï¸ %@", [NSThread currentThread]);});// â¬…ï¸ ä»»åŠ¡äºŒ
    
    dispatch_barrier_async(concurrentQueue, ^{ sleep(3); NSLog(@"ğŸš¥ğŸš¥ %@", [NSThread currentThread]);}); // â¬…ï¸ Barrie ä»»åŠ¡
    
    dispatch_async(concurrentQueue, ^{ sleep(3); NSLog(@"ğŸƒâ€â™€ï¸ğŸƒâ€â™€ï¸ğŸƒâ€â™€ï¸ %@", [NSThread currentThread]);}); // â¬…ï¸ ä»»åŠ¡ä¸‰
    dispatch_async(concurrentQueue, ^{ sleep(2); NSLog(@"ğŸƒâ€â™€ï¸ğŸƒâ€â™€ï¸ğŸƒâ€â™€ï¸ğŸƒâ€â™€ï¸ %@", [NSThread currentThread]);}); // â¬…ï¸ ä»»åŠ¡å››
    
    NSLog(@"ğŸ” END: %@", [NSThread currentThread]);
}
```
&emsp;é¦–å…ˆå››ä¸ªä»»åŠ¡éƒ½ä¸ä¼šé˜»å¡ä¸»çº¿ç¨‹ï¼Œä¸¤æ¡ ğŸ” çš„æ‰“å°ä¼šé¦–å…ˆæ‰§è¡Œå®Œæ¯•ï¼Œç„¶åæ˜¯ä»»åŠ¡ä¸€å’Œä»»åŠ¡äºŒå¼‚æ­¥å¹¶å‘æ‰§è¡Œï¼Œå½“å®ƒä»¬å…¨éƒ¨éƒ½æ‰§è¡Œå®Œæ¯•ä»¥åï¼Œå¼€å§‹å¼‚æ­¥æ‰§è¡Œ Barrie ä»»åŠ¡ï¼Œå½“ Barrie ä»»åŠ¡ æ‰§è¡Œå®Œæ¯•ä»¥åï¼Œæ‰å¼€å§‹å¼‚æ­¥å¹¶å‘æ‰§è¡Œä»»åŠ¡ä¸‰å’Œä»»åŠ¡å››ï¼Œè¿™æ ·å°±åƒåœ¨å‰ä¸¤ä¸ªä»»åŠ¡å’Œåä¸¤ä¸ªä»»åŠ¡ä¹‹é—´æ’äº†ä¸€é“æ— å½¢çš„å¢™ï¼Œä½¿åœ¨ Barrie ä»»åŠ¡ä¹‹å‰æ·»åŠ çš„ä»»åŠ¡å’Œä¹‹åæ·»åŠ çš„ä»»åŠ¡æœ‰äº†æ‰§è¡Œé¡ºåºï¼Œè¿™å°±æ˜¯ `dispatch_barrier_async` å‡½æ•°çš„ä½œç”¨ï¼Œå¯ä»¥åœ¨å¤šä¸ªå¼‚æ­¥å¹¶å‘ä»»åŠ¡ä¹‹é—´æ·»åŠ æ‰§è¡Œé¡ºåºã€‚

&emsp;`dq` å‚æ•°æ˜¯ Barrier block æäº¤åˆ°çš„ç›®æ ‡è°ƒåº¦é˜Ÿåˆ—ï¼Œè¿™é‡Œè¦æ³¨æ„æŠŠéœ€è¦æ§åˆ¶å¼‚æ­¥å¹¶å‘æ‰§è¡Œé¡ºåºçš„ä»»åŠ¡éƒ½æ·»åŠ åˆ°åŒä¸€ä¸ªè‡ªå®šä¹‰çš„å¹¶å‘é˜Ÿåˆ— `dq` ä¸­ï¼ŒåŒæ—¶æ³¨æ„ä¸èƒ½ä½¿ç”¨ `dispatch_get_global_queue` API è·å–çš„å…¨å±€å¹¶å‘é˜Ÿåˆ—ä¸­ï¼ˆä¼šå¯¼è‡´ Barrier å¤±æ•ˆï¼Œå› ä¸ºå…¨å±€å¹¶å‘é˜Ÿåˆ—æ˜¯ç³»ç»Ÿåˆ›å»ºçš„ï¼Œè‹¹æœæœ‰æ—¶å€™ä¼šåœ¨å…¨å±€å¹¶å‘é˜Ÿåˆ—ä¸­å¤„ç†å®ƒè‡ªæœ‰ä»»åŠ¡ï¼Œä½¿ç”¨ barrier å‡½æ•°é˜»å¡å…¨å±€å¹¶å‘é˜Ÿåˆ—æ— æ•ˆï¼‰ï¼Œç³»ç»Ÿå°†åœ¨ç›®æ ‡é˜Ÿåˆ—ä¸Šä¿ç•™å¼•ç”¨ï¼Œç›´åˆ°è¯¥ block æ‰§è¡Œå®Œæˆä¸ºæ­¢ã€‚

&emsp;`work` å‚æ•°æ˜¯æäº¤åˆ°ç›®æ ‡è°ƒåº¦é˜Ÿåˆ—çš„ blockï¼ˆè¯¥å‡½æ•°å†…éƒ¨ä¼šä»£è¡¨è°ƒç”¨è€…æ‰§è¡Œ `Block_copy` å’Œ `Block_release`ï¼‰ã€‚
```c++
#ifdef __BLOCKS__
void
dispatch_barrier_async(dispatch_queue_t dq, dispatch_block_t work)
{
    // å–å¾—ä¸€ä¸ª dispatch_continuation_s ç»“æ„ä½“å®ä¾‹ï¼Œç”¨äºå°è£… work
    dispatch_continuation_t dc = _dispatch_continuation_alloc();
    
    // continuation resources are freed on run this is set on async or for non event_handler source handlers
    // #define DC_FLAG_CONSUME  0x004ul
    // continuation acts as a barrier
    // #define DC_FLAG_BARRIER  0x002ul
    // DC_FLAG_CONSUME | DC_FLAG_BARRIER = 0x006ul
    
    // dc_flags ä¸­æ·»åŠ  DC_FLAG_BARRIER æ ‡è®°ï¼Œæ ‡è®°æ­¤ work æ˜¯ä¸€ä¸ªå±éšœ blockï¼Œç„¶åå‰©ä¸‹çš„å†…å®¹éƒ½å’Œ dispatch_async å®Œå…¨ç›¸åŒ
    uintptr_t dc_flags = DC_FLAG_CONSUME | DC_FLAG_BARRIER;
    
    dispatch_qos_t qos;
    
    // å°è£… work block çš„å†…å®¹ä»¥åŠä»»åŠ¡æ‰§è¡Œæ—¶æ‰€å¤„çš„é˜Ÿåˆ—ç­‰å†…å®¹åˆ° dc ä¸­
    qos = _dispatch_continuation_init(dc, dq, work, 0, dc_flags);
    
    // æŠŠå°è£…å¥½çš„ dispatch_continuation_s è¿›è¡Œå¼‚æ­¥è°ƒç”¨
    _dispatch_continuation_async(dq, dc, qos, dc_flags);
}
#endif
```
&emsp;çœ‹åˆ° `dispatch_barrier_async` å‡½æ•°å†…éƒ¨å’Œ `dispatch_async` ç›¸æ¯”åœ¨ `dc_flags` èµ‹å€¼æ—¶æ·»åŠ äº† `DC_FLAG_BARRIER` æ ‡è®°ï¼Œè€Œæ­¤æ ‡è®°æ­£æ˜¯å‘ŠçŸ¥ `dispatch_continuation_s` ç»“æ„ä½“ä¸­å°è£…çš„ block æ˜¯ä¸€ä¸ª barrier blockï¼Œå…¶å®ƒçš„å†…å®¹åˆ™å’Œ `dispatch_async` å¦‚å‡ºä¸€è¾™ã€‚

&emsp;ä¸€ä¸ª `dispatch barrier` å…è®¸ä½ åœ¨ä¸€ä¸ªå¹¶è¡Œé˜Ÿåˆ—ä¸­åˆ›å»ºä¸€ä¸ªåŒæ­¥ç‚¹ã€‚å½“åœ¨é˜Ÿåˆ—ä¸­é‡åˆ°è¿™ä¸ª `barrier block` æ—¶ï¼Œè¿™ä¸ª `barrier block` ä¾¿ä¼šå»¶è¿Ÿæ‰§è¡Œï¼ˆåŒæ—¶æ‰€æœ‰åœ¨å…¶åçš„ block éƒ½ä¼šå»¶è¿Ÿï¼‰ï¼Œç›´è‡³æ‰€æœ‰åœ¨ barrier ä¹‹å‰çš„ block æ‰§è¡Œå®Œæˆã€‚è¿™æ—¶ï¼Œè¿™ä¸ª `barrier block` ä¾¿ä¼šæ‰§è¡Œï¼Œä¹‹åé˜Ÿåˆ—ä¾¿æ¢å¤æ­£å¸¸æ‰§è¡Œã€‚

&emsp;è°ƒç”¨è¿™ä¸ªå‡½æ•°æ€»æ˜¯ä¼šåœ¨è¿™ä¸ª block è¢«æäº¤åç«‹åˆ»è¿”å›ï¼Œå¹¶ä¸”ä¸ä¼šç­‰åˆ° block è¢«è§¦å‘ã€‚å½“è¿™ä¸ª `barrier block` åˆ°è¾¾ç§æœ‰å¹¶è¡Œ é˜Ÿåˆ—æœ€å‰ç«¯æ—¶ï¼Œå®ƒä¸æ˜¯ç«‹å³æ‰§è¡Œã€‚æ°æ°ç›¸åï¼Œè¿™ä¸ªé˜Ÿåˆ—ä¼šä¸€ç›´ç­‰å¾…å½“å‰æ­£åœ¨æ‰§è¡Œçš„é˜Ÿåˆ—æ‰§è¡Œå®Œæˆã€‚æ­¤æ—¶ `barrier block` æ‰ä¼šæ‰§è¡Œã€‚æ‰€æœ‰ `barrier block` ä¹‹åæäº¤çš„ block ä¼šç­‰åˆ° `barrier block` æ‰§è¡Œç»“æŸåæ‰ä¼šæ‰§è¡Œã€‚

&emsp;è¿™é‡Œä½ æŒ‡å®šçš„å¹¶è¡Œé˜Ÿåˆ—åº”è¯¥æ˜¯è‡ªå·±é€šè¿‡ `dispatch_queue_cretate` åˆ›å»ºçš„ã€‚å¦‚æœä½ ä¼ çš„æ˜¯ä¸€ä¸ªä¸²è¡Œæˆ–æ˜¯ä¸€ä¸ªå…¨å±€çš„å¹¶è¡Œé˜Ÿåˆ—ï¼Œé‚£è¿™ä¸ªå‡½æ•°ä¾¿ç­‰åŒäº `dispatch_async` å‡½æ•°æ•ˆæœäº†ã€‚

***

## 24. ä»‹ç» run loop çš„æ¦‚å¿µï¼ˆrun loop ä¸çº¿ç¨‹çš„å…³ç³»ï¼‰ã€‚
&emsp;Run loop æ˜¯ä¸ thread å…³è”çš„åŸºæœ¬åŸºç¡€ç»“æ„çš„ä¸€éƒ¨åˆ†ã€‚Run loop æ˜¯ä¸€ä¸ª event processing loop ï¼ˆäº‹ä»¶å¤„ç†å¾ªç¯ï¼‰ï¼Œå¯ç”¨äºè®¡åˆ’å·¥ä½œå¹¶åè°ƒæ”¶åˆ°çš„äº‹ä»¶çš„æ¥æ”¶ã€‚Run loop çš„ç›®çš„æ˜¯è®© thread åœ¨æœ‰å·¥ä½œè¦åšæ—¶ä¿æŒå¿™ç¢Œï¼Œè€Œåœ¨æ²¡æœ‰å·¥ä½œæ—¶è®© thread è¿›å…¥ç¡çœ çŠ¶æ€ã€‚

&emsp;ä¸€èˆ¬æ¥è®²ï¼Œä¸€ä¸ªçº¿ç¨‹ä¸€æ¬¡åªèƒ½æ‰§è¡Œä¸€ä¸ªä»»åŠ¡ï¼Œæ‰§è¡Œå®Œæˆåçº¿ç¨‹å°±ä¼šé€€å‡ºã€‚å¦‚æœæˆ‘ä»¬éœ€è¦ä¸€ä¸ªæœºåˆ¶ï¼Œè®©çº¿ç¨‹èƒ½éšæ—¶å¤„ç†äº‹ä»¶ä½†å¹¶ä¸é€€å‡ºï¼Œè¿™ç§æ¨¡å‹é€šå¸¸è¢«ç§°ä½œ Event Loopã€‚å®ç°è¿™ç§æ¨¡å‹çš„å…³é”®ç‚¹åœ¨äºåŸºäºæ¶ˆæ¯æœºåˆ¶ï¼šç®¡ç†äº‹ä»¶/æ¶ˆæ¯ï¼Œè®©çº¿ç¨‹åœ¨æ²¡æœ‰æ¶ˆæ¯æ—¶ä¼‘çœ ä»¥é¿å…èµ„æºå ç”¨ã€åœ¨æœ‰æ¶ˆæ¯åˆ°æ¥æ—¶ç«‹åˆ»è¢«å”¤é†’æ‰§è¡Œä»»åŠ¡ã€‚

&emsp;é‚£ä»€ä¹ˆæ˜¯ run loopï¼Ÿé¡¾åæ€ä¹‰ï¼Œrun loop å°±æ˜¯åœ¨ â€œè·‘åœˆâ€ï¼Œrun loop è¿è¡Œçš„æ ¸å¿ƒä»£ç æ˜¯ä¸€ä¸ªæœ‰çŠ¶æ€çš„ do while å¾ªç¯ï¼Œæ¯å¾ªç¯ä¸€æ¬¡å°±ç›¸å½“äºè·‘äº†ä¸€åœˆï¼Œçº¿ç¨‹å°±ä¼šå¯¹å½“å‰è¿™ä¸€åœˆé‡Œé¢äº§ç”Ÿçš„äº‹ä»¶è¿›è¡Œå¤„ç†ï¼Œå¹¶ä¸”åªè¦ä¸æ˜¯è¶…æ—¶æˆ–è€…æ•…æ„é€€å‡ºçŠ¶æ€ä¸‹ run loop å°±ä¸ä¼šé€€å‡ºï¼Œæ‰€ä»¥å¯ä»¥ä¿è¯çº¿ç¨‹ä¸é€€å‡ºï¼Œå¹¶ä¸”å¯ä»¥è®©æˆ‘ä»¬æ ¹æ®è‡ªå·±éœ€è¦å‘çº¿ç¨‹ä¸­æ·»åŠ ä»»åŠ¡ã€‚

&emsp;é‚£ä¹ˆä¸ºä»€ä¹ˆçº¿ç¨‹è¦æœ‰ run loop å‘¢ï¼Ÿå…¶å®æˆ‘ä»¬çš„ APP å¯ä»¥ç†è§£ä¸ºæ˜¯é  event é©±åŠ¨çš„ï¼ˆåŒ…æ‹¬ iOS å’Œ Android åº”ç”¨ï¼‰ã€‚æˆ‘ä»¬è§¦æ‘¸å±å¹•ã€ç½‘ç»œå›è°ƒç­‰éƒ½æ˜¯ä¸€ä¸ªä¸ªçš„ eventï¼Œä¹Ÿå°±æ˜¯äº‹ä»¶ã€‚è¿™äº›äº‹ä»¶äº§ç”Ÿä¹‹åä¼šåˆ†å‘ç»™æˆ‘ä»¬çš„ APPï¼ŒAPP æ¥æ”¶åˆ°äº‹ä»¶ä¹‹ååˆ†å‘ç»™å¯¹åº”çš„çº¿ç¨‹ã€‚é€šå¸¸æƒ…å†µä¸‹ï¼Œå¦‚æœçº¿ç¨‹æ²¡æœ‰ run loopï¼Œé‚£ä¹ˆä¸€ä¸ªçº¿ç¨‹ä¸€æ¬¡åªèƒ½æ‰§è¡Œä¸€ä¸ªä»»åŠ¡ï¼Œæ‰§è¡Œå®Œæˆåçº¿ç¨‹å°±ä¼šé€€å‡ºã€‚è¦æƒ³ APP çš„çº¿ç¨‹ä¸€ç›´èƒ½å¤Ÿå¤„ç†äº‹ä»¶æˆ–è€…ç­‰å¾…äº‹ä»¶ï¼ˆæ¯”å¦‚å¼‚æ­¥äº‹ä»¶ï¼‰ï¼Œå°±è¦ä¿æ´»çº¿ç¨‹ï¼Œä¹Ÿå°±æ˜¯ä¸èƒ½è®©çº¿ç¨‹æ—©æ—©çš„é€€å‡ºï¼Œæ­¤æ—¶ run loop å°±æ´¾ä¸Šç”¨åœºäº†ï¼Œå…¶å®ä¹Ÿä¸æ˜¯å¿…é¡»è¦ç»™çº¿ç¨‹æŒ‡å®šä¸€ä¸ª run loopï¼Œå¦‚æœéœ€è¦æˆ‘ä»¬çš„çº¿ç¨‹èƒ½å¤ŸæŒç»­çš„å¤„ç†äº‹ä»¶ï¼Œé‚£ä¹ˆå°±éœ€è¦ç»™çº¿ç¨‹ç»‘å®šä¸€ä¸ª run loopï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œrun loop èƒ½å¤Ÿä¿è¯çº¿ç¨‹ä¸€ç›´å¯ä»¥å¤„ç†äº‹ä»¶ã€‚

&emsp;run loop ä¸çº¿ç¨‹çš„å…³ç³»ï¼šä¸€ä¸ªçº¿ç¨‹å¯¹åº”ä¸€ä¸ª run loopï¼Œç¨‹åºè¿è¡Œæ˜¯ä¸»çº¿ç¨‹çš„ main run loop é»˜è®¤å¯åŠ¨äº†ï¼Œæ‰€ä»¥æˆ‘ä»¬çš„ç¨‹åºæ‰ä¸ä¼šé€€å‡ºï¼Œå­çº¿ç¨‹çš„ run loop æŒ‰éœ€å¯åŠ¨ï¼ˆè°ƒç”¨ run æ–¹æ³•ï¼‰ã€‚run loop æ˜¯çº¿ç¨‹çš„äº‹ä»¶ç®¡ç†è€…ï¼Œæˆ–è€…è¯´æ˜¯çº¿ç¨‹çš„äº‹ä»¶ç®¡å®¶ï¼Œå®ƒä¼šæŒ‰ç…§é¡ºåºç®¡ç†çº¿ç¨‹è¦å¤„ç†çš„äº‹ä»¶ï¼Œå†³å®šå“ªäº›äº‹ä»¶åœ¨ä»€ä¹ˆæ—¶å€™æäº¤ç»™çº¿ç¨‹å¤„ç†ã€‚ï¼ˆrun loop å†…éƒ¨æ˜¯åŸºäºå†…æ ¸åŸºäº mach port è¿›è¡Œå·¥ä½œçš„ï¼‰

&emsp;åœ¨å¼€å‘è€…æ–‡æ¡£ä¸­æŸ¥çœ‹ `UIApplicationMain` å‡½æ•°ï¼Œæ‘˜è¦å‘Šè¯‰æˆ‘ä»¬ `UIApplicationMain` å‡½æ•°å®Œæˆï¼š**åˆ›å»ºåº”ç”¨ç¨‹åºå¯¹è±¡å’Œåº”ç”¨ç¨‹åºä»£ç†å¹¶è®¾ç½® event cycle**ï¼Œçœ‹åˆ° Return Value ä¸€é¡¹ Apple å·²ç»æ˜ç¡®å‘Šè¯‰æˆ‘ä»¬ `UIApplicationMain` å‡½æ•°æ˜¯ä¸ä¼šè¿”å›çš„ï¼Œå¹¶ä¸”åœ¨ Discussion ä¸­ä¹Ÿå‘Šè¯‰æˆ‘ä»¬ `UIApplicationMain` å‡½æ•°å¯åŠ¨äº† main run loop å¹¶å¼€å§‹ç€æ‰‹ä¸ºæˆ‘ä»¬å¤„ç†äº‹ä»¶ã€‚

```c++
int main(int argc, char * argv[]) {
    @autoreleasepool {
        int retVal = 0;
        do {
            // åœ¨ç¡çœ ä¸­ç­‰å¾…æ¶ˆæ¯
            int message = sleep_and_wait();
            // å¤„ç†æ¶ˆæ¯
            retVal = process_message(message);
        } while (retVal == 0);
        return 0;
    }
}
```
&emsp;è¿˜æœ‰ä¸€ä¸ªæéšç§˜çš„ç‚¹ã€‚å½“æˆ‘ä»¬ä½¿ç”¨ block æ—¶ä¼šåœ¨ block å¤–é¢ä½¿ç”¨ `__weak` ä¿®é¥°ç¬¦å–å¾—ä¸€ä¸ªçš„ `self` çš„å¼±å¼•ç”¨å˜é‡ï¼Œç„¶ååœ¨ block å†…éƒ¨åˆä¼šä½¿ç”¨ `__strong` ä¿®é¥°ç¬¦å–å¾—ä¸€ä¸ªçš„ self å¼±å¼•ç”¨å˜é‡çš„å¼ºå¼•ç”¨ï¼Œé¦–å…ˆè¿™é‡Œæ˜¯åœ¨ block å†…éƒ¨ï¼Œå½“ block æ‰§è¡Œå®Œæ¯•åä¼šè¿›è¡Œè‡ªåŠ¨é‡Šæ”¾å¼ºå¼•ç”¨çš„ selfï¼Œè¿™é‡Œçš„ç›®çš„åªæ˜¯ä¸ºäº†ä¿è¯åœ¨ block  æ‰§è¡ŒæœŸé—´ self ä¸ä¼šè¢«é‡Šæ”¾ï¼Œè¿™å°±é»˜è®¤å»¶é•¿äº† self çš„ç”Ÿå‘½å‘¨æœŸåˆ° block æ‰§è¡Œç»“æŸï¼Œè¿™åœ¨æˆ‘ä»¬çš„æ—¥å¸¸å¼€å‘ä¸­æ²¡æœ‰ä»»ä½•é—®é¢˜ï¼Œä½†æ˜¯ï¼Œä½†æ˜¯ï¼Œä½†æ˜¯ï¼Œæ”¾åœ¨ run loop è¿™é‡Œæ˜¯ä¸è¡Œçš„ï¼Œå½“æˆ‘ä»¬ç›´æ¥ push è¿›å…¥ `ViewController` ç„¶åç›´æ¥ pop å›ä¸Šä¸€ä¸ªé¡µé¢æ—¶ï¼Œæˆ‘ä»¬è¦å€Ÿç”¨ ViewController çš„ dealloc å‡½æ•°æ¥ stop `self.commonThread` çº¿ç¨‹çš„ run loop çš„ï¼Œå¦‚æœæˆ‘ä»¬è¿˜ç”¨ `__strong` ä¿®é¥°ç¬¦å–å¾— self å¼ºå¼•ç”¨çš„è¯ï¼Œé‚£ä¹ˆç”±äº `self.commonThread` çº¿ç¨‹åˆ›å»ºæ—¶çš„ block å†…éƒ¨çš„ run loop çš„ `runMode:beforeDate:` å¯åŠ¨å‡½æ•°æ˜¯æ²¡æœ‰è¿”å›çš„ï¼Œå®ƒä¼šä¸€ç›´æ½œåœ¨çš„å»¶é•¿ self çš„ç”Ÿå‘½å‘¨æœŸï¼Œä¼šç›´æ¥å¯¼è‡´ `ViewController` æ— æ³•é‡Šæ”¾ï¼Œ`dealloc` å‡½æ•°å¾—ä¸åˆ°è°ƒç”¨ï¼ˆæè¿°çš„ä¸å¤Ÿæ¸…æ™°ï¼Œçœ‹ä¸‹é¢çš„å®ä¾‹ä»£ç åº”è¯¥ä¼šä¸€çœ¼çœ‹æ˜ç™½çš„ï¼‰ã€‚

&emsp;è¿™é‡Œæ˜¯ `__weak` å’Œ `__strong` é…å¯¹ä½¿ç”¨çš„ä¸€äº›è§£é‡Šï¼Œå¦‚æœå¯¹ block ä¸æ¸…æ™°çš„è¯å¯ä»¥å‚è€ƒå‰é¢çš„æ–‡ç« è¿›è¡Œå­¦ä¹ ã€‚
```c++
// ä¸‹é¢åœ¨å¹¶è¡Œé˜Ÿåˆ—é‡Œé¢è¦æ‰§è¡Œçš„ block æ²¡æœ‰ retain self
__weak typeof(self) _self = self;
dispatch_async(globalQueue_DEFAULT, ^{
    // ä¿è¯åœ¨ä¸‹é¢çš„æ‰§è¡Œè¿‡ç¨‹ä¸­ self ä¸ä¼šè¢«é‡Šæ”¾ï¼Œæ‰§è¡Œç»“æŸå self ä¼šæ‰§è¡Œä¸€æ¬¡ releaseã€‚
    
    // åœ¨ ARC ä¸‹ï¼Œè¿™é‡Œçœ‹ä¼¼å‰é¢çš„ __wek å’Œè¿™é‡Œçš„ __strong ç›¸äº’æŠµæ¶ˆäº†ï¼Œ
    // è¿™é‡Œçš„ self æ˜¯è¢« block æˆªè·çš„ selfï¼Œ
    // è¿™é‡Œ __strong çš„ selfï¼Œåœ¨å‡ºäº†ä¸‹é¢çš„å³è¾¹èŠ±æ‹¬å·æ—¶ï¼Œä¼šæ‰§è¡Œä¸€æ¬¡ release æ“ä½œã€‚ 
    // ä¸”åªæœ‰æ­¤ block æ‰§è¡Œçš„æ—¶å€™ _self æœ‰å€¼é‚£ä¹ˆæ­¤å¤„çš„ __strong self æ‰ä¼šæœ‰å€¼ï¼Œ
    // å¦åˆ™ä¸‹é¢çš„ if åˆ¤æ–­å°±ç›´æ¥ return äº†ã€‚
    
    __strong typeof(_self) self = _self;
    if (!self) return;
    
    // do something
    // ...
    
    dispatch_async(dispatch_get_main_queue(), ^{
        // æ­¤æ—¶å¦‚æœèƒ½è¿›æ¥ï¼Œè¡¨ç¤ºæ­¤æ—¶ self æ˜¯å­˜åœ¨çš„
        self.view.backgroundColor = [UIColor redColor];
    });
});
```

&emsp;NSRunLoop å¯¹è±¡å¤„ç†æ¥è‡ª window system çš„é¼ æ ‡å’Œé”®ç›˜äº‹ä»¶ã€NSPort å¯¹è±¡å’Œ NSConnection å¯¹è±¡ç­‰ sources çš„è¾“å…¥ã€‚NSRunLoop å¯¹è±¡è¿˜å¤„ç† NSTimer äº‹ä»¶ã€‚

&emsp;ä½ çš„åº”ç”¨ç¨‹åºæ—¢ä¸åˆ›å»ºä¹Ÿä¸æ˜¾å¼ç®¡ç† NSRunLoop å¯¹è±¡ã€‚æ¯ä¸ª NSThread å¯¹è±¡ï¼ˆåŒ…æ‹¬åº”ç”¨ç¨‹åºçš„ä¸»çº¿ç¨‹ï¼‰éƒ½æœ‰ä¸€ä¸ªæ ¹æ®éœ€è¦è‡ªåŠ¨ä¸ºå…¶åˆ›å»ºçš„ NSRunLoop å¯¹è±¡ã€‚å¦‚æœä½ éœ€è¦è®¿é—®å½“å‰çº¿ç¨‹çš„ run loopï¼Œåº”ä½¿ç”¨ç±»æ–¹æ³• currentRunLoop è¿›è¡Œè®¿é—®ã€‚è¯·æ³¨æ„ï¼Œä» NSRunLoop çš„è§’åº¦æ¥çœ‹ï¼ŒNSTimer  å¯¹è±¡ä¸æ˜¯ "input"â€”è€Œæ˜¯ä¸€ç§ç‰¹æ®Šç±»å‹ï¼Œè¿™æ„å‘³ç€å®ƒä»¬åœ¨è§¦å‘åä¸ä¼šå¯¼è‡´ run loop è¿”å›ã€‚ï¼ˆå¦‚å‰é¢çš„ç¤ºä¾‹ä»£ç ä¸­ï¼Œæ²¡æœ‰è¢« while å¾ªç¯åŒ…è£¹çš„ runMode:beforeDate: å‡½æ•°ï¼Œåœ¨æˆ‘ä»¬ç‚¹å‡»ä¸€æ¬¡å±å¹•åï¼Œä½¿å…¶æ¥åˆ°ä¸€ä¸ªäº‹ä»¶åï¼Œrun loop å°±ä¼šé€€å‡ºï¼Œè€Œå¦‚æœåªæ˜¯æ·»åŠ  timer çš„è¯ï¼Œrun loop åˆ™å¯ä»¥ä¸€ç›´æ¥æ”¶ timer çš„å›è°ƒï¼Œå¹¶ä¸ä¼šé€€å‡ºã€‚ï¼‰

&emsp;NSRunLoop ç±»é€šå¸¸ä¸è¢«è®¤ä¸ºæ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼Œå…¶æ–¹æ³•åªèƒ½åœ¨å½“å‰çº¿ç¨‹çš„ä¸Šä¸‹æ–‡ä¸­è°ƒç”¨ã€‚æ°¸è¿œä¸è¦å°è¯•è°ƒç”¨åœ¨å…¶ä»–çº¿ç¨‹ä¸­è¿è¡Œçš„ NSRunLoop å¯¹è±¡çš„æ–¹æ³•ï¼Œå› ä¸ºè¿™æ ·åšå¯èƒ½ä¼šå¯¼è‡´æ„å¤–ç»“æœã€‚

&emsp;`currentRunLoop` è¿”å›å½“å‰çº¿ç¨‹çš„ run loopï¼Œè¿”å›å€¼æ˜¯å½“å‰çº¿ç¨‹çš„ NSRunLoop å¯¹è±¡ã€‚å¦‚æœè¯¥çº¿ç¨‹è¿˜æ²¡æœ‰ run loopï¼Œåˆ™ä¼šä¸ºå…¶åˆ›å»ºå¹¶è¿”å›ä¸€ä¸ª run loopã€‚

&emsp;é¦–å…ˆ NSRunLoop æ˜¯å¯¹ Core Foundation æ¡†æ¶ä¸­çš„ \__CFRunLoop ç»“æ„çš„å°è£…ï¼Œæ‰€ä»¥æ–‡ç« ä¸Šé¢æ‰€æœ‰æåˆ°çš„ run loop åœ¨ä»£ç å±‚é¢éƒ½å¯ä»¥ç†è§£ä¸º NSRunLoop å¯¹è±¡æˆ–è€…æ˜¯ \__CFRunLoop ç»“æ„ä½“å®ä¾‹ã€‚NSRunLoop çš„å°è£…ä½¿æˆ‘ä»¬å¯ä»¥ä»¥æ›´åŠ é¢å‘å¯¹è±¡çš„æ€æƒ³æ¥å­¦ä¹ å’Œä½¿ç”¨ run loopï¼Œå¹¶ä¸”æ˜¯ç»§æ‰¿è‡ª NSObject çš„å¯ä»¥ä½¿ç”¨ ARC æ¥è‡ªåŠ¨å¤„ç†å†…å­˜ç”³è¯·å’Œé‡Šæ”¾ï¼ŒåŒæ—¶æ¯ä¸ª NSRunLoop å¯¹è±¡æ˜¯å’Œä¸€ä¸ª \__CFRunLoop ç»“æ„ä½“å®ä¾‹æ‰€å¯¹åº”çš„ï¼ŒgetCFRunLoop å‡½æ•°ä½¿æˆ‘ä»¬å¯ä»¥ç”±ä¸€ä¸ª NSRunLoop å¯¹è±¡å¾—åˆ°å…¶å¯¹åº”çš„ CFRunLoopRefï¼ˆ\__CFRunLoop ç»“æ„ä½“æŒ‡é’ˆï¼‰ç„¶åç”± CFRunLoopRef æˆ‘ä»¬å¯ä»¥å¯¹ run loop æ‰§è¡Œæ›´å¤šçš„æ“ä½œï¼Œå› ä¸ºè¿™é‡Œè™½æ˜¯å°è£…ï¼Œä½†æ˜¯è¿˜æ˜¯æœ‰å¾ˆå¤š \__CFRunLoop çš„å‡½æ•°åœ¨ NSRunLoop å¹¶æ²¡æœ‰å®ç°ï¼Œä¾‹å¦‚ä¸Šé¢çš„æåˆ°çš„è®¾ç½® run loop observerï¼š`void CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFRunLoopMode mode)` å‡½æ•°ã€‚

&emsp;æç¤ºï¼štimer ä¸è¢«è§†ä¸º input sourceï¼Œåœ¨ç­‰å¾…æ­¤æ–¹æ³•è¿”å›æ—¶å¯èƒ½ä¼šè§¦å‘å¤šæ¬¡ã€‚ï¼ˆå³æˆ‘ä»¬ä½¿ç”¨ addTimer:forMode: å‘ NSRunLoop å¯¹è±¡æ·»åŠ ä¸€ä¸ª timerï¼Œè€Œä¸”æ­¤ NSRunLoop å¯¹è±¡ ä»…æ­¤ä¸€ä¸ª timerï¼Œç„¶åä¸ä½¿ç”¨ while å¾ªç¯ä»…ä½¿ç”¨ runMode:beforeDate: å¯åŠ¨è¯¥ run loopï¼Œåˆ™ timer çš„ selector å°†ä¸€ç›´æ‰§è¡Œï¼Œtimer çš„æ‰§è¡Œå¹¶ä¸èƒ½åƒ input source ä¸€æ ·ä»…è¾“å…¥ä¸€æ¬¡å°±èƒ½å¯¼è‡´ runMode:beforeDate: å‡½æ•°è¿”å›ï¼‰


&emsp;å‚è€ƒé“¾æ¥ğŸ”—ğŸ”—ï¼š
+ [iOS ä»æºç è§£æRun Loop (ä¸€)ï¼šRun Loop åŸºæœ¬æ¦‚å¿µç†è§£ä¸ NSRunLoop æ–‡æ¡£](https://juejin.cn/post/6904921175546298375)

***

## 25. run loop å®˜æ–¹æ–‡æ¡£ã€‚
&emsp;&emsp;åœ¨å¦ä¸€ä¸ªçº¿ç¨‹ä¸Šæ‰§è¡Œ selector æ—¶ï¼Œç›®æ ‡çº¿ç¨‹å¿…é¡»å…·æœ‰æ´»åŠ¨çš„ run loopã€‚å¯¹äºä½ åˆ›å»ºçš„å­çº¿ç¨‹ï¼Œè¿™æ„å‘³ç€ç­‰å¾…ç›´åˆ°ä½ çš„ä»£ç æ˜¾å¼å¯åŠ¨å½“å‰çº¿ç¨‹çš„ run loopã€‚ä½†æ˜¯ï¼Œç”±äºä¸»çº¿ç¨‹å¯åŠ¨äº†è‡ªå·±çš„ run loopï¼Œå› æ­¤ä½ å¯ä»¥åœ¨åº”ç”¨ç¨‹åºè°ƒç”¨åº”ç”¨ç¨‹åºå§”æ‰˜çš„ `applicationDidFinishLaunching:` å‡½æ•°åç«‹å³å¼€å§‹åœ¨ä¸»çº¿ç¨‹ä¸Šå‘å‡ºè°ƒç”¨ï¼ˆæ·»åŠ  selector åœ¨ä¸»çº¿ç¨‹æ‰§è¡Œï¼‰ã€‚æ¯æ¬¡å¾ªç¯æ—¶ï¼Œrun loop éƒ½ä¼šå¤„ç†é˜Ÿåˆ—ä¸­æ‰€æœ‰çš„æ‰§è¡Œ selector çš„è°ƒç”¨ï¼Œè€Œä¸æ˜¯åœ¨æ¯æ¬¡å¾ªç¯è¿­ä»£æ—¶ä»…å¤„ç†ä¸€ä¸ªã€‚

&emsp;Timer sources åœ¨å°†æ¥çš„é¢„è®¾æ—¶é—´å°†äº‹ä»¶åŒæ­¥ä¼ é€’åˆ°ä½ çš„çº¿ç¨‹ã€‚Timers æ˜¯çº¿ç¨‹é€šçŸ¥è‡ªå·±æ‰§è¡ŒæŸäº‹çš„ä¸€ç§æ–¹å¼ã€‚

&emsp;å°½ç®¡ timer ç”ŸæˆåŸºäºæ—¶é—´çš„é€šçŸ¥ï¼ˆtime-based notificationsï¼‰ï¼Œä½†å®ƒä¸æ˜¯ä¸€ç§å®æ—¶æœºåˆ¶ï¼ˆreal-time mechanismï¼‰ã€‚ä¸ input sources ä¸€æ ·ï¼Œtimer ä¸ run loop çš„ç‰¹å®š mode ç›¸å…³è”ã€‚å¦‚æœ timer æœªå¤„äº run loop å½“å‰ç›‘è§†çš„æ¨¡å¼ï¼Œåˆ™åœ¨ä»¥ timer æ”¯æŒçš„ mode ä¹‹ä¸€è¿è¡Œ run loop ä¹‹å‰ï¼Œtimer ä¸ä¼šè§¦å‘ã€‚ç±»ä¼¼åœ°ï¼Œå¦‚æœåœ¨ run loop æ­£åœ¨æ‰§è¡Œå¤„ç†ç¨‹åºä¾‹ç¨‹ï¼ˆhandler routineï¼‰çš„è¿‡ç¨‹ä¸­è§¦å‘ timer ï¼Œåˆ™ timer å°†ç­‰åˆ°ä¸‹ä¸€æ¬¡é€šè¿‡ run loop è°ƒç”¨å…¶å¤„ç†ç¨‹åºä¾‹ç¨‹ï¼ˆhandler routineï¼‰ã€‚å¦‚æœ run loop æ ¹æœ¬æ²¡æœ‰è¿è¡Œï¼Œè®¡æ—¶å™¨å°±ä¸ä¼šè§¦å‘ã€‚

&emsp;ä½ å¯ä»¥å°† timer é…ç½®ä¸ºä»…ç”Ÿæˆä¸€æ¬¡äº‹ä»¶æˆ–é‡å¤ç”Ÿæˆäº‹ä»¶ã€‚é‡å¤ timer æ ¹æ®é¢„å®šçš„è§¦å‘æ—¶é—´è€Œä¸æ˜¯å®é™…è§¦å‘æ—¶é—´è‡ªåŠ¨é‡æ–°è°ƒåº¦è‡ªå·±ã€‚ä¾‹å¦‚ï¼Œå¦‚æœä¸€ä¸ª timer è¢«å®‰æ’åœ¨æŸä¸ªç‰¹å®šæ—¶é—´è§¦å‘ï¼Œå¹¶ä¸”æ­¤åæ¯éš” 5 ç§’è§¦å‘ä¸€æ¬¡ï¼Œé‚£ä¹ˆå³ä½¿å®é™…è§¦å‘æ—¶é—´è¢«å»¶è¿Ÿï¼Œè®¡åˆ’çš„è§¦å‘æ—¶é—´ä¹Ÿå°†å§‹ç»ˆè½åœ¨åŸæ¥çš„ 5 ç§’æ—¶é—´é—´éš”ä¸Šã€‚å¦‚æœè§¦å‘æ—¶é—´å»¶è¿Ÿå¤ªä¹…ï¼Œä»¥è‡´é”™è¿‡äº†ä¸€ä¸ªæˆ–å¤šä¸ªé¢„å®šçš„è§¦å‘æ—¶é—´ï¼Œåˆ™å¯¹äºé”™è¿‡çš„æ—¶é—´æ®µï¼Œtimer åªè§¦å‘ä¸€æ¬¡ã€‚åœ¨ä¸ºé”™è¿‡çš„æ—¶é—´æ®µè§¦å‘åï¼Œtimer å°†é‡æ–°å®‰æ’ä¸ºä¸‹ä¸€ä¸ªé¢„å®šçš„è§¦å‘æ—¶é—´ã€‚

&emsp;ä¸ timers ç±»ä¼¼ï¼Œ run loop observers å¯ä»¥ä½¿ç”¨ä¸€æ¬¡æˆ–é‡å¤ä½¿ç”¨ã€‚ä¸€æ¬¡æ€§ observer åœ¨æ¿€å‘åä» run loop ä¸­ç§»é™¤è‡ªå·±ï¼Œè€Œé‡å¤ observer ä¿æŒè¿æ¥ã€‚ä½ å¯ä»¥æŒ‡å®šåœ¨åˆ›å»º observer æ—¶æ˜¯è¿è¡Œä¸€æ¬¡è¿˜æ˜¯é‡å¤è¿è¡Œã€‚

&emsp;æ¯æ¬¡è¿è¡Œå®ƒæ—¶ï¼Œçº¿ç¨‹çš„ run loop éƒ½ä¼šå¤„ç†å¾…åŠäº‹ä»¶ï¼ˆpending eventsï¼‰ï¼Œå¹¶ä¸ºæ‰€æœ‰é™„åŠ çš„ observers ç”Ÿæˆé€šçŸ¥ã€‚å®ƒæ‰§è¡Œæ­¤æ“ä½œçš„é¡ºåºéå¸¸ å…·ä½“/æ˜ç¡®ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

1. é€šçŸ¥ observers å³å°†è¿›å…¥ run loopã€‚
2. é€šçŸ¥ observers ä»»ä½•å‡†å¤‡å°±ç»ªçš„ timers å³å°†è§¦å‘ã€‚
3. é€šçŸ¥ observers ä»»ä½•ä¸åŸºäºç«¯å£ï¼ˆnot port basedï¼‰çš„ input sourcesï¼ˆsource0ï¼‰éƒ½å°†è¢«è§¦å‘ã€‚
4. è§¦å‘æ‰€æœ‰å‡†å¤‡è§¦å‘çš„éåŸºäºç«¯å£çš„è¾“å…¥æºï¼ˆnon-port-based input sourcesï¼‰(source0)ã€‚
5. å¦‚æœåŸºäºç«¯å£çš„è¾“å…¥æºï¼ˆport-based input sourceï¼‰å·²å‡†å¤‡å¥½å¹¶ç­‰å¾…å¯åŠ¨ï¼Œè¯·ç«‹å³å¤„ç†äº‹ä»¶ã€‚**è½¬åˆ°æ­¥éª¤ 9**ã€‚
6. é€šçŸ¥ observersï¼Œçº¿ç¨‹å³å°†è¿›å…¥ä¼‘çœ çŠ¶æ€ã€‚

7. ä½¿çº¿ç¨‹è¿›å…¥ä¼‘çœ çŠ¶æ€å¹¶ç­‰å¾…å”¤é†’ï¼Œç›´åˆ°å‘ç”Ÿä»¥ä¸‹äº‹ä»¶ä¹‹ä¸€æ—¶ä¼šè¢«å”¤é†’ï¼š
  + åŸºäºç«¯å£çš„è¾“å…¥æºï¼ˆport-based input sourceï¼‰ï¼ˆsource1ï¼‰çš„äº‹ä»¶åˆ°è¾¾ã€‚
  + timers è§¦å‘ã€‚
  + ä¸º run loop è®¾ç½®çš„è¶…æ—¶æ—¶é—´è¿‡æœŸã€‚
  + run loop è¢«æ˜¾å¼å”¤é†’ã€‚
  
8. é€šçŸ¥ observerï¼Œçº¿ç¨‹åˆšåˆšå”¤é†’ã€‚
9. å¤„ç†å”¤é†’æ—¶æ”¶åˆ°çš„å¾…åŠäº‹ä»¶ã€‚
  + å¦‚æœè§¦å‘äº†ç”¨æˆ·å®šä¹‰çš„ timerï¼ˆå¤„ç† timer äº‹ä»¶å¹¶é‡æ–°å¯åŠ¨å¾ªç¯ï¼‰ã€‚**è½¬åˆ°æ­¥éª¤2**ã€‚
  + å¦‚æœè§¦å‘äº† input sourceï¼Œä¼ é€’äº‹ä»¶ã€‚ï¼ˆsource1ï¼‰
  + å¦‚æœ run loop è¢«æ˜ç¡®å”¤é†’ä½†å°šæœªè¶…æ—¶ï¼Œé‡æ–°å¯åŠ¨å¾ªç¯ã€‚**è½¬åˆ°æ­¥éª¤2**ã€‚
10. é€šçŸ¥ observerï¼Œrun loop å·²é€€å‡ºã€‚

&emsp;ä¾‹å¦‚ï¼Œå¦‚æœè®¡åˆ’æ‰§è¡Œä»¥ä¸‹ä»»ä¸€æ“ä½œï¼Œåˆ™éœ€è¦å¯åŠ¨ run loopï¼š

+ ä½¿ç”¨ç«¯å£ï¼ˆportsï¼‰æˆ–è‡ªå®šä¹‰è¾“å…¥æºï¼ˆcustom input sourcesï¼‰ä¸å…¶ä»–çº¿ç¨‹é€šä¿¡ã€‚
+ åœ¨çº¿ç¨‹ä¸Šä½¿ç”¨ timerã€‚
+ åœ¨ Cocoa åº”ç”¨ç¨‹åºä¸­ä½¿ç”¨ä»»ä½• `performSelectorâ€¦` æ–¹æ³•ã€‚
+ ä¿æŒçº¿ç¨‹æ‰§è¡Œå®šæœŸä»»åŠ¡ï¼ˆperiodic tasksï¼‰ã€‚

&emsp;å¦‚æœé€‰æ‹©ä½¿ç”¨ run loopï¼Œåˆ™é…ç½®å’Œè®¾ç½®å¾ˆç®€å•ã€‚ä¸è¿‡ï¼Œä¸æ‰€æœ‰çº¿ç¨‹ç¼–ç¨‹ä¸€æ ·ï¼Œä½ åº”è¯¥æœ‰ä¸€ä¸ªåœ¨é€‚å½“æƒ…å†µä¸‹é€€å‡ºå­çº¿ç¨‹çš„è®¡åˆ’ã€‚é€šè¿‡è®©çº¿ç¨‹é€€å‡ºè€Œå¹²å‡€åœ°ç»“æŸå®ƒæ€»æ˜¯æ¯”å¼ºåˆ¶å®ƒç»ˆæ­¢è¦å¥½ã€‚

&emsp;Run loop å¯¹è±¡æä¾›ä¸»æ¥å£ï¼Œç”¨äºå‘ run loop æ·»åŠ  input sourcesã€timers å’Œ run loop observersï¼Œç„¶åè¿è¡Œå®ƒã€‚æ¯ä¸ªçº¿ç¨‹éƒ½æœ‰ä¸€ä¸ªä¸ä¹‹å…³è”çš„ run loop å¯¹è±¡ã€‚åœ¨ Cocoa ä¸­ï¼Œæ­¤å¯¹è±¡æ˜¯ NSRunLoop ç±»çš„å®ä¾‹ã€‚åœ¨ä½çº§åº”ç”¨ç¨‹åºä¸­ï¼ˆlow-level applicationï¼‰ï¼Œå®ƒæ˜¯æŒ‡å‘ CFRunLoopRef ä¸é€æ˜ç±»å‹çš„æŒ‡é’ˆã€‚

&emsp;è¦è·å–å½“å‰çº¿ç¨‹çš„ run loopï¼Œè¯·ä½¿ç”¨ä»¥ä¸‹æ–¹æ³•ä¹‹ä¸€ï¼š

+ åœ¨ Cocoa åº”ç”¨ç¨‹åºä¸­ï¼Œä½¿ç”¨ NSRunLoop çš„ `currentRunLoop` ç±»æ–¹æ³•æ£€ç´¢ NSRunLoop å¯¹è±¡ã€‚
+ ä½¿ç”¨ `CFRunLoopGetCurrent` å‡½æ•°ã€‚

&emsp;åœ¨å­çº¿ç¨‹ä¸Šè¿è¡Œ run loop ä¹‹å‰ï¼Œå¿…é¡»è‡³å°‘å‘å…¶æ·»åŠ ä¸€ä¸ª input source æˆ– timerã€‚å¦‚æœ run loop æ²¡æœ‰ä»»ä½•è¦ç›‘è§†çš„ sourceï¼Œåˆ™å½“ä½ å°è¯•è¿è¡Œå®ƒæ—¶ï¼Œå®ƒä¼šç«‹å³é€€å‡ºã€‚

&emsp;åœ¨ä¸ºé•¿ç”Ÿå­˜æœŸçº¿ç¨‹ï¼ˆlong-lived threadï¼‰é…ç½®è¿è¡Œå¾ªç¯æ—¶ï¼Œæœ€å¥½è‡³å°‘æ·»åŠ ä¸€ä¸ª input source æ¥æ¥æ”¶æ¶ˆæ¯ã€‚è™½ç„¶ä½ å¯ä»¥åœ¨åªé™„åŠ  timer çš„æƒ…å†µä¸‹è¿›å…¥è¿è¡Œ run loopï¼Œä½†ä¸€æ—¦ timer è§¦å‘ï¼Œå®ƒé€šå¸¸ä¼šå¤±æ•ˆï¼Œè¿™å°†å¯¼è‡´ run loop é€€å‡ºã€‚é™„åŠ ä¸€ä¸ªé‡å¤ timer å¯ä»¥ä½¿ run loop åœ¨è¾ƒé•¿çš„æ—¶é—´å†…è¿è¡Œï¼Œä½†éœ€è¦å®šæœŸå¯åŠ¨ timer ä»¥å”¤é†’çº¿ç¨‹ï¼Œè¿™å®é™…ä¸Šæ˜¯å¦ä¸€ç§è½®è¯¢å½¢å¼ã€‚ç›¸æ¯”ä¹‹ä¸‹ï¼Œinput source ç­‰å¾…äº‹ä»¶å‘ç”Ÿï¼Œè®©çº¿ç¨‹ä¸€ç›´å¤„äºä¼‘çœ çŠ¶æ€ã€‚

&emsp;åœ¨å¤„ç†äº‹ä»¶ä¹‹å‰ï¼Œæœ‰ä¸¤ç§æ–¹æ³•å¯ä»¥ä½¿ run loop é€€å‡ºï¼š

+ é…ç½® run loop ä»¥ä½¿ç”¨è¶…æ—¶å€¼è¿è¡Œã€‚
+ å‘Šè¯‰è¿è¡Œå¾ªç¯åœæ­¢ã€‚

&emsp;å¦‚æœå¯ä»¥ç®¡ç†çš„è¯ï¼Œä½¿ç”¨è¶…æ—¶å€¼å½“ç„¶æ˜¯é¦–é€‰ã€‚æŒ‡å®šä¸€ä¸ªè¶…æ—¶å€¼å¯ä»¥è®© run loop åœ¨é€€å‡ºä¹‹å‰å®Œæˆå…¶æ‰€æœ‰çš„æ­£å¸¸å¤„ç†ï¼ŒåŒ…æ‹¬å‘ run loop observers å‘é€é€šçŸ¥ã€‚

&emsp;ä½¿ç”¨ `CFRunLoopStop` å‡½æ•°æ˜¾å¼åœæ­¢ run loop ä¼šäº§ç”Ÿç±»ä¼¼è¶…æ—¶çš„ç»“æœã€‚run loop å‘é€ä»»ä½•å‰©ä½™çš„ run loop é€šçŸ¥ï¼Œç„¶åé€€å‡ºã€‚ä¸åŒä¹‹å¤„åœ¨äºï¼Œä½ å¯ä»¥åœ¨æ— æ¡ä»¶å¯åŠ¨çš„è¿è¡Œå¾ªç¯ä¸­ä½¿ç”¨æ­¤æŠ€æœ¯ã€‚

&emsp;è¦ä¸ NSMachPort å¯¹è±¡å»ºç«‹æœ¬åœ°è¿æ¥ï¼Œéœ€è¦åˆ›å»ºç«¯å£å¯¹è±¡å¹¶å°†å…¶æ·»åŠ åˆ°ä¸»çº¿ç¨‹çš„è¿è¡Œå¾ªç¯ä¸­ã€‚å¯åŠ¨å­çº¿ç¨‹æ—¶ï¼Œå°†åŒä¸€å¯¹è±¡ä¼ é€’ç»™çº¿ç¨‹çš„å…¥å£ç‚¹å‡½æ•°ã€‚å­çº¿ç¨‹å¯ä»¥ä½¿ç”¨ç›¸åŒçš„å¯¹è±¡å°†æ¶ˆæ¯å‘é€å›ä¸»çº¿ç¨‹ã€‚

&emsp;CFRunLoop å¯¹è±¡ç›‘è§†ä»»åŠ¡çš„è¾“å…¥æºï¼ˆsources of inputï¼‰ï¼Œå¹¶åœ¨å‡†å¤‡å¥½è¿›è¡Œå¤„ç†æ—¶è°ƒåº¦æ§åˆ¶ã€‚è¾“å…¥æºï¼ˆinput sourcesï¼‰çš„ç¤ºä¾‹å¯èƒ½åŒ…æ‹¬ç”¨æˆ·è¾“å…¥è®¾å¤‡ã€ç½‘ç»œè¿æ¥ã€å‘¨æœŸæ€§æˆ–å»¶æ—¶äº‹ä»¶ä»¥åŠå¼‚æ­¥å›è°ƒã€‚

&emsp;run loop å¯ä»¥ç›‘è§†ä¸‰ç§ç±»å‹çš„å¯¹è±¡ï¼šsourcesï¼ˆCFRunLoopSourceï¼‰ã€timersï¼ˆCFRunLoopTimerï¼‰å’Œ observersï¼ˆCFRunLoopObserverï¼‰ã€‚è¦åœ¨è¿™äº›å¯¹è±¡éœ€è¦å¤„ç†æ—¶æ¥æ”¶å›è°ƒï¼Œå¿…é¡»é¦–å…ˆä½¿ç”¨ `CFRunLoopAddSource`ã€`CFRunLoopAddTimer` æˆ– `CFRunLoopAddObserver` å°†è¿™äº›å¯¹è±¡æ”¾å…¥ run loop ä¸­ï¼Œä»¥åä¹Ÿå¯ä»¥ä» run loop ä¸­åˆ é™¤å®ƒä»¬ï¼ˆæˆ–ä½¿å…¶ invalidateï¼‰ä»¥åœæ­¢æ¥æ”¶å…¶å›è°ƒã€‚ 

&emsp;æ·»åŠ åˆ° run loop çš„æ¯ä¸ª sourceã€timer å’Œ observer å¿…é¡»ä¸ä¸€ä¸ªæˆ–å¤šä¸ª run loop modes ç›¸å…³è”ã€‚Modes å†³å®š run loop åœ¨ç»™å®šè¿­ä»£æœŸé—´å¤„ç†å“ªäº›äº‹ä»¶ã€‚æ¯æ¬¡ run loop æ‰§è¡Œæ—¶ï¼Œå®ƒéƒ½ä»¥ç‰¹å®š mode æ‰§è¡Œã€‚åœ¨è¯¥ mode ä¸‹ï¼Œrun loop åªå¤„ç†ä¸è¯¥ mode å…³è”çš„ sourcesã€timers å’Œ observers å…³è”çš„äº‹ä»¶ã€‚ä½ å¯ä»¥å°†å¤§å¤šæ•° sources åˆ†é…ç»™é»˜è®¤çš„ run loop modeï¼ˆç”± kCFRunLoopDefaultMode å¸¸é‡æŒ‡å®šï¼‰ï¼Œè¯¥ mode ç”¨äºåœ¨åº”ç”¨ç¨‹åºï¼ˆæˆ–çº¿ç¨‹ï¼‰ç©ºé—²æ—¶å¤„ç†äº‹ä»¶ã€‚ç„¶è€Œï¼Œç³»ç»Ÿå®šä¹‰äº†å…¶å®ƒ modesï¼Œå¹¶ä¸”å¯ä»¥åœ¨å…¶å®ƒ modes ä¸‹æ‰§è¡Œ run loopï¼Œä»¥é™åˆ¶å¤„ç†å“ªäº› sourcesã€timers å’Œ observersã€‚å› ä¸º run loop modes è¢«ç®€å•åœ°æŒ‡å®šä¸ºå­—ç¬¦ä¸²ï¼Œæ‰€ä»¥ä½ è¿˜å¯ä»¥å®šä¹‰è‡ªå·±çš„è‡ªå®šä¹‰ mode æ¥é™åˆ¶äº‹ä»¶çš„å¤„ç†ã€‚

***

## 26. åœ¨å½“å‰çº¿ç¨‹è·å– run loop çš„è¿‡ç¨‹ã€‚
&emsp;`CFRunLoopGetMain/CFRunLoopGetCurrent` å‡½æ•°å¯åˆ†åˆ«ç”¨äºè·å–ä¸»çº¿ç¨‹çš„ run loop å’Œè·å–å½“å‰çº¿ç¨‹ï¼ˆå­çº¿ç¨‹ï¼‰çš„ run loopã€‚main run loop ä½¿ç”¨ä¸€ä¸ªé™æ€å˜é‡ \__main å­˜å‚¨ï¼Œå­çº¿ç¨‹çš„ run loop ä¼šä¿å­˜åœ¨å½“å‰çº¿ç¨‹çš„ TSD ä¸­ã€‚ä¸¤è€…åœ¨ç¬¬ä¸€æ¬¡è·å– run loop æ—¶éƒ½ä¼šè°ƒç”¨ \_CFRunLoopGet0 å‡½æ•°æ ¹æ®çº¿ç¨‹çš„ pthread_t å¯¹è±¡ä»é™æ€å…¨å±€å˜é‡ \__CFRunLoopsï¼ˆstatic CFMutableDictionaryRefï¼‰ä¸­è·å–ï¼Œå¦‚æœè·å–ä¸åˆ°çš„è¯åˆ™æ–°å»º run loop å¯¹è±¡ï¼Œå¹¶æ ¹æ®çº¿ç¨‹çš„ pthread_t ä¿å­˜åœ¨é™æ€å…¨å±€å˜é‡ \__CFRunLoopsï¼ˆstatic CFMutableDictionaryRefï¼‰ä¸­ï¼Œæ–¹ä¾¿åç»­è¯»å–ã€‚

&emsp;æ¯ä¸ªçº¿ç¨‹åªæœ‰ä¸€ä¸ª run loopã€‚æ—¢ä¸èƒ½åˆ›å»ºï¼ˆç³»ç»Ÿå¸®åˆ›å»ºï¼Œä¸éœ€è¦å¼€å‘è€…è‡ªå·±æ‰‹åŠ¨åˆ›å»ºï¼‰ä¹Ÿä¸èƒ½é”€æ¯çº¿ç¨‹çš„ run loopï¼ˆçº¿ç¨‹é”€æ¯æ—¶åŒæ—¶ä¹Ÿä¼šé€šè¿‡ TSD ä½¿å…¶å¯¹åº”çš„ run loop é”€æ¯ï¼‰ã€‚Core Foundation ä¼šæ ¹æ®éœ€è¦è‡ªåŠ¨ä¸ºä½ åˆ›å»ºå®ƒã€‚ä½¿ç”¨ `CFRunLoopGetCurrent` è·å–å½“å‰çº¿ç¨‹çš„ run loopã€‚è°ƒç”¨ `CFRunLoopRun` ä»¥é»˜è®¤æ¨¡å¼è¿è¡Œå½“å‰çº¿ç¨‹çš„ run loopï¼Œç›´åˆ° run loop è¢« `CFRunLoopStop` åœæ­¢ã€‚ä¹Ÿå¯ä»¥è°ƒç”¨ `CFRunLoopRunInMode` ä»¥æŒ‡å®šçš„ mode è¿è¡Œå½“å‰çº¿ç¨‹çš„ run loop ä¸€æ®µæ—¶é—´ï¼ˆæˆ–ç›´åˆ° run loop åœæ­¢ï¼‰ã€‚åªæœ‰åœ¨è¯·æ±‚çš„æ¨¡å¼è‡³å°‘æœ‰ä¸€ä¸ªè¦ç›‘è§†çš„ source æˆ– timer æ—¶ï¼Œæ‰èƒ½è¿è¡Œ run loopã€‚

&emsp;Core Foundation ä¸­çš„ CFRunLoop éƒ½æ˜¯ C APIï¼Œæä¾›äº† run loop ç›¸å½“ä¸°å¯Œçš„æ¥å£ï¼Œä¸”éƒ½æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼ŒNSRunLoop æ˜¯å¯¹ CFRunLoopRef çš„å°è£…ï¼Œæä¾›äº†é¢å‘å¯¹è±¡çš„ APIï¼Œéçº¿ç¨‹å®‰å…¨çš„ã€‚ä½¿ç”¨ NSRunLoop çš„ `getCFRunLoop` æ–¹æ³•å³å¯è·å–ç›¸åº”çš„ `CFRunLoopRef` ç±»å‹ã€‚

&emsp;ä¸‹é¢çœ‹ä¸€ä¸‹Objective-C æŒ‡é’ˆä¸ Core Foundation æŒ‡é’ˆä¹‹é—´çš„è½¬æ¢è§„åˆ™ï¼š

&emsp;ARC ä»…ç®¡ç† Objective-C æŒ‡é’ˆï¼ˆretainã€releaseã€autoreleaseï¼‰ï¼Œä¸ç®¡ç† Core Foundation æŒ‡é’ˆï¼ŒCF æŒ‡é’ˆéœ€è¦æˆ‘ä»¬æ‰‹åŠ¨çš„ CFRetain å’Œ CFRelease æ¥ç®¡ç†ï¼ˆå¯¹åº” MRC æ—¶çš„ retain/releaseï¼‰ï¼ŒCF ä¸­æ²¡æœ‰ autoreleaseã€‚

&emsp;Cocoa Foundation æŒ‡é’ˆä¸ Core FoundationæŒ‡é’ˆè½¬æ¢ï¼Œéœ€è¦è€ƒè™‘çš„æ˜¯**æ‰€æŒ‡å‘å¯¹è±¡æ‰€æœ‰æƒçš„å½’å±**ã€‚ARC æä¾›äº† 3 ä¸ªä¿®é¥°ç¬¦æ¥ç®¡ç†ã€‚

&emsp;1. \__bridgeï¼Œä»€ä¹ˆä¹Ÿä¸åšï¼Œä»…ä»…æ˜¯è½¬æ¢ã€‚æ­¤ç§æƒ…å†µä¸‹ï¼š

&emsp;1.1ï¼šä» Cocoa è½¬æ¢åˆ° Coreï¼Œéœ€è¦æ‰‹åŠ¨ CFRetainï¼Œå¦åˆ™ï¼ŒCocoa æŒ‡é’ˆé‡Šæ”¾åï¼Œä¼ å‡ºå»çš„æŒ‡é’ˆåˆ™æ— æ•ˆã€‚

&emsp;1.2ï¼šä» Core è½¬æ¢åˆ° Cocoaï¼Œéœ€è¦æ‰‹åŠ¨ CFReleaseï¼Œå¦åˆ™ï¼ŒCocoa æŒ‡é’ˆé‡Šæ”¾åï¼Œå¯¹è±¡å¼•ç”¨è®¡æ•°ä»ä¸º 1ï¼Œä¸ä¼šè¢«é”€æ¯ã€‚

&emsp;2. \__bridge_retainedï¼Œè½¬æ¢åè‡ªåŠ¨è°ƒç”¨ CFRetainï¼Œå³å¸®åŠ©è‡ªåŠ¨è§£å†³ä¸Šè¿° 1.1 çš„æƒ…å½¢ã€‚

&emsp;ï¼ˆ\__bridge_retained or CFBridgingRetainï¼ŒARC æŠŠå¯¹è±¡æ‰€æœ‰æƒè½¬å‡ºï¼Œéœ€ Core Foundation å¤„ç†ã€‚ï¼‰

&emsp;3. \__bridge_transferï¼Œè½¬æ¢åè‡ªåŠ¨è°ƒç”¨ CFReleaseï¼Œå³å¸®åŠ©è‡ªåŠ¨è§£å†³ä¸Šè¿° 1.2 çš„æƒ…å½¢ã€‚

&emsp;ï¼ˆ\__bridge_transfer or CFBridgingReleaseï¼ŒCore Foundation æŠŠå¯¹è±¡æ‰€æœ‰æƒäº¤ç»™ ARCï¼Œç”± ARC è‡ªåŠ¨å¤„ç†ã€‚ï¼‰

&emsp;åœ¨ Core Foundation ä¸‹ \__CFRunLoop ç»“æ„æ˜¯ Run Loop å¯¹åº”çš„æ•°æ®ç»“æ„ï¼Œå¯¹åº” Cocoa ä¸­çš„ NSRunLoop ç±»ã€‚CFRunLoopRef åˆ™æ˜¯æŒ‡å‘ \__CFRunLoop ç»“æ„ä½“çš„æŒ‡é’ˆã€‚
```c++
typedef struct __CFRunLoop * CFRunLoopRef;

struct __CFRunLoop { 
    CFRuntimeBase _base; // æ‰€æœ‰ CF "instances" éƒ½æ˜¯ä»è¿™ä¸ªç»“æ„å¼€å§‹çš„
    pthread_mutex_t _lock; // é”å®šä»¥è®¿é—® mode listï¼ˆCFMutableSetRef _modesï¼‰
    
    // typedef mach_port_t __CFPort;
    // å”¤é†’ run loop çš„ç«¯å£ï¼Œè¿™ä¸ªæ˜¯ run loop åŸç†çš„å…³é”®æ‰€åœ¨ï¼Œå¯é€šè¿‡ port æ¥è§¦å‘ CFRunLoopWakeUp å‡½æ•°
    __CFPort _wakeUpPort; // used for CFRunLoopWakeUp æ‰‹åŠ¨å”¤é†’ run loop çš„ç«¯å£ã€‚åˆå§‹åŒ– run loop æ—¶è®¾ç½®ï¼Œä»…ç”¨äº CFRunLoopWakeUpï¼ŒCFRunLoopWakeUp å‡½æ•°ä¼šå‘ _wakeUpPort å‘é€ä¸€æ¡æ¶ˆæ¯
    
    Boolean _unused; // æ ‡è®°æ˜¯å¦ä½¿ç”¨è¿‡
    
    //_perRunData æ˜¯ run loop æ¯æ¬¡è¿è¡Œéƒ½ä¼šé‡ç½®çš„ä¸€ä¸ªæ•°æ®ç»“æ„ï¼Œè¿™é‡Œçš„é‡ç½®æ˜¯æŒ‡å†åˆ›å»ºä¸€ä¸ª _per_run_data å®ä¾‹èµ‹å€¼ç»™ rl->_perRunDataï¼Œ
    // å¹¶ä¸æ˜¯ç®€å•çš„æŠŠ _perRunData çš„æ¯ä¸ªæˆå‘˜å˜é‡é‡æ–°èµ‹å€¼ã€‚ï¼ˆvolatile é˜²æ­¢ç¼–è¯‘å™¨è‡ªè¡Œä¼˜åŒ–ï¼Œæ¯æ¬¡è¯»å€¼éƒ½å»å¯„å­˜å™¨é‡Œé¢è¯»å–ï¼‰
    // åŒ…æ‹¬ uint32_t stopped; æ˜¯ run loop æ˜¯å¦åœæ­¢çš„æ ‡è®°ï¼Œuint32_t ignoreWakeUps; run loop æ˜¯å¦å¿½ç•¥å”¤é†’çš„æ ‡è®°ï¼ˆå®ƒä»¬çš„å®é™…ç”¨æ„æ˜¯è¡¨ç¤ºå½“å‰ run loop æ˜¯å¦å·²ç»åœæ­¢ã€æ˜¯å¦å·²ç»è¢«å”¤é†’ï¼‰
    volatile _per_run_data *_perRunData; // reset for runs of the run loop 
    
    pthread_t _pthread; // run loop æ‰€å¯¹åº”çš„çº¿ç¨‹ï¼ŒäºŒè€…æ˜¯ä¸€ä¸€å¯¹åº”çš„ã€‚ï¼ˆä¹‹å‰åœ¨å­¦ä¹ çº¿ç¨‹æ—¶å¹¶æ²¡æœ‰åœ¨çº¿ç¨‹çš„ç»“æ„ä½“ä¸­çœ‹åˆ°æœ‰ run loop ç›¸å…³çš„å­—æ®µï¼Œå…¶å®çº¿ç¨‹çš„ run loop æ˜¯å­˜åœ¨äº† TSD ä¸­ï¼Œå½“ç„¶å¦‚æœæ˜¯çº¿ç¨‹æœ‰è·å– run loop çš„è¯ï¼‰
    uint32_t _winthread; // Windows ä¸‹è®°å½• run loop å¯¹è±¡åˆ›å»ºæ—¶æ‰€å¤„çš„çº¿ç¨‹çš„ ID
    
    CFMutableSetRef _commonModes; // å­˜å‚¨å­—ç¬¦ä¸²ï¼ˆè€Œé runloopMode å¯¹è±¡ï¼‰çš„å®¹å™¨ï¼Œå¯¹åº”ç€æ‰€æœ‰æ ‡è®°ä¸º common çš„ modeã€‚
    CFMutableSetRef _commonModeItems; // å­˜å‚¨ modeItem å¯¹è±¡çš„å®¹å™¨ï¼Œå¯¹åº”äºæ‰€æœ‰æ ‡è®°ä¸º common çš„ mode ä¸‹çš„ Itemï¼ˆå³ sourceã€timerã€observerï¼‰
    CFRunLoopModeRef _currentMode; // å½“å‰è¿è¡Œçš„ Run Loop Mode å®ä¾‹çš„æŒ‡é’ˆï¼ˆtypedef struct __CFRunLoopMode *CFRunLoopModeRefï¼‰
    CFMutableSetRef _modes; // é›†åˆï¼Œå­˜å‚¨çš„æ˜¯ CFRunLoopModeRef
    
    // é“¾è¡¨å¤´æŒ‡é’ˆï¼Œè¯¥é“¾è¡¨ä¿å­˜äº†æ‰€æœ‰éœ€è¦è¢« run loop æ‰§è¡Œçš„ blockã€‚
    // å¤–éƒ¨é€šè¿‡è°ƒç”¨ CFRunLoopPerformBlock å‡½æ•°æ¥å‘é“¾è¡¨ä¸­æ·»åŠ ä¸€ä¸ª block èŠ‚ç‚¹ã€‚
    // run loop ä¼šåœ¨ CFRunLoopDoBlock æ—¶éå†è¯¥é“¾è¡¨ï¼Œé€ä¸€æ‰§è¡Œ blockã€‚
    struct _block_item *_blocks_head;
    
    // é“¾è¡¨å°¾æŒ‡é’ˆï¼Œä¹‹æ‰€ä»¥æœ‰å°¾æŒ‡é’ˆï¼Œæ˜¯ä¸ºäº†é™ä½å¢åŠ  block èŠ‚ç‚¹æ—¶çš„æ—¶é—´å¤æ‚åº¦ã€‚
    //ï¼ˆä¾‹å¦‚æœ‰æ–°èŠ‚ç‚¹æ’å…¥æ—¶ï¼Œåªæœ‰å¤´èŠ‚ç‚¹çš„è¯ï¼Œè¦ä»å¤´èŠ‚ç‚¹éå†æ‰èƒ½æ‰¾åˆ°å°¾èŠ‚ç‚¹ï¼Œç°åœ¨å·²ç»æœ‰å°¾èŠ‚ç‚¹ä¸éœ€è¦éå†äº†ï¼Œåˆ™æ—¶é—´å¤æ‚åº¦ä» O(n) é™åˆ°äº† O(1ï¼‰ã€‚)
    struct _block_item *_blocks_tail;
    
    // ç»å¯¹æ—¶é—´æ˜¯è‡ªå‚è€ƒæ—¥æœŸåˆ°å‚è€ƒæ—¥æœŸï¼ˆçºªå…ƒï¼‰ä¸º 2001 å¹´ 1 æœˆ 1 æ—¥ 00:00:00 çš„æ—¶é—´é—´éš”ã€‚
    // typedef double CFTimeInterval;
    // typedef CFTimeInterval CFAbsoluteTime;
    
    CFAbsoluteTime _runTime; // è¿è¡Œæ—¶é—´ç‚¹
    CFAbsoluteTime _sleepTime; // ä¼‘çœ æ—¶é—´ç‚¹
    
    // æ‰€æœ‰ "CF objects" çš„åŸºç¡€ "type" åŠå…¶ä¸Šçš„å¤šæ€å‡½æ•°ï¼ˆpolymorphic functionsï¼‰
    // typedef const void * CFTypeRef;
    CFTypeRef _counterpart;
};
```

&emsp;éœ€è¦è¢« run loop æ‰§è¡Œçš„ block é“¾è¡¨ä¸­çš„èŠ‚ç‚¹æ•°æ®ç»“æ„ã€‚
```c++
struct _block_item {
    struct _block_item *_next; // æŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
    
    // typedef const void * CFTypeRef; 
    // CFString æˆ– CFSet ç±»å‹ï¼Œä¹Ÿå°±æ˜¯è¯´ä¸€ä¸ª block å¯èƒ½å¯¹åº”å•ä¸ªæˆ–å¤šä¸ª mode 
    CFTypeRef _mode; // CFString or CFSet
    
    void (^_block)(void); // çœŸæ­£è¦æ‰§è¡Œçš„ block æœ¬ä½“
};
```

&emsp;ä¸€ä¸ª run loop å¯¹åº”å¤šä¸ª modeï¼Œä¸€ä¸ª mode ä¸‹å¯ä»¥åŒ…å«å¤šä¸ª modeItemã€‚æ—¢ç„¶ run loop åŒ…å«å¤šä¸ª mode é‚£ä¹ˆå®ƒå®šå¯ä»¥åœ¨ä¸åŒçš„ mode ä¸‹è¿è¡Œï¼Œrun loop ä¸€æ¬¡åªèƒ½åœ¨ä¸€ä¸ª mode ä¸‹è¿è¡Œï¼Œå¦‚æœæƒ³è¦åˆ‡æ¢ modeï¼Œåªèƒ½é€€å‡º run loopï¼Œç„¶åå†æ ¹æ®æŒ‡å®šçš„ mode è¿è¡Œ run loopï¼Œè¿™æ ·å¯ä»¥æ˜¯ä½¿ä¸åŒçš„ mode ä¸‹çš„ modeItem ç›¸äº’éš”ç¦»ï¼Œä¸ä¼šç›¸äº’å½±å“ã€‚

***

## 27. åˆ›å»º run loop çš„è¿‡ç¨‹ã€‚
&emsp;`static CFRunLoopRef __CFRunLoopCreate(pthread_t t);` å‡½æ•°å…¥å‚æ˜¯ä¸€ä¸ªçº¿ç¨‹ï¼Œè¿”å›å€¼æ˜¯ä¸€ä¸ª run loop æŒ‡é’ˆï¼Œæ­£å¦‚å…¶åï¼Œå®Œæˆçš„åŠŸèƒ½å°±æ˜¯ä¸ºçº¿ç¨‹åˆ›å»º run loopã€‚å®ƒé¦–å…ˆè°ƒç”¨ `_CFRuntimeCreateInstance` å‡½æ•°ï¼Œæ ¹æ®å…¥å‚ `CFRunLoopGetTypeID()` åˆ›å»ºä¸€ä¸ª CFRunLoop å®ä¾‹å˜é‡å¹¶è¿”å›å…¶åœ°å€ï¼Œç„¶åå¯¹è¯¥ run loop çš„å®ä¾‹å˜é‡çš„ä¸€äº›æˆå‘˜å˜é‡è¿›è¡Œåˆå§‹åŒ–ã€‚

+ åˆå§‹åŒ– loop çš„ `_perRunData`ã€‚
+ åˆå§‹åŒ– loop çš„ `pthread_mutex_t _lock`ï¼Œ`_lock` çš„åˆå§‹æ—¶å±æ€§ç”¨çš„ `PTHREAD_MUTEX_RECURSIVE`ï¼Œå³ `_lock` ä¸ºä¸€ä¸ªäº’æ–¥é€’å½’é”ã€‚
+ ç»™ loop çš„ `_wakeUpPort`ï¼ˆå”¤é†’ç«¯å£ï¼‰èµ‹åˆå€¼ï¼ˆ`__CFPortAllocate()`ï¼‰ã€‚
+ è®¾ç½® loop çš„ `_perRunData->ignoreWakeUps` ä¸º `0x57414B45`ï¼Œå‰é¢ `__CFRunLoopPushPerRunData` åˆå§‹åŒ–æ—¶ `_perRunData->ignoreWakeUps` çš„å€¼æ˜¯ `0x00000000`ã€‚
+ åˆå§‹åŒ– loop çš„ `_commonModes` å¹¶æŠŠé»˜è®¤ mode çš„å­—ç¬¦ä¸²ï¼ˆ"kCFRunLoopDefaultMode"ï¼‰æ·»åŠ åˆ° `_commonModes` ä¸­ï¼Œå³æŠŠé»˜è®¤ mode æ ‡è®°ä¸º commonã€‚
+ åˆå§‹åŒ– loop çš„ `_modes`ï¼Œå¹¶æŠŠæ„å»ºå¥½çš„ `CFRunLoopModeRef rlm` æ·»åŠ åˆ° `_modes` ä¸­ã€‚
+ æŠŠ `pthread_t t` èµ‹å€¼ç»™ loop çš„ `_pthread` æˆå‘˜å˜é‡ã€‚ï¼ˆ`Windows` ä¸‹ä¼šè·å–å½“å‰çº¿ç¨‹çš„ ID èµ‹å€¼ç»™ loop çš„ `_winthread`ï¼‰

***

## 28. CFRunLoopMode å®šä¹‰åŠå…¶åˆ›å»ºè¿‡ç¨‹ã€‚
&emsp;æ¯æ¬¡ run loop å¼€å§‹ run çš„æ—¶å€™ï¼Œéƒ½å¿…é¡»æŒ‡å®šä¸€ä¸ª modeï¼Œç§°ä¸º run loop modeï¼ˆè¿è¡Œå¾ªç¯æ¨¡å¼ï¼‰ã€‚mode æŒ‡å®šäº†åœ¨è¿™æ¬¡ run ä¸­ï¼Œrun loop å¯ä»¥å¤„ç†çš„ä»»åŠ¡ï¼Œå¯¹äºä¸å±äºå½“å‰ mode çš„ä»»åŠ¡ï¼Œåˆ™éœ€è¦åˆ‡æ¢ run loop è‡³å¯¹åº” mode ä¸‹ï¼Œå†é‡æ–°è°ƒç”¨ run æ–¹æ³•ï¼Œæ‰èƒ½å¤Ÿè¢«å¤„ç†ï¼Œè¿™æ ·ä¹Ÿä¿è¯äº†ä¸åŒ mode çš„ source/timer/observer äº’ä¸å½±å“ï¼Œä½¿ä¸åŒ mode ä¸‹çš„æ•°æ®åšåˆ°ç›¸äº’éš”ç¦»çš„ã€‚

&emsp;`__CFRunLoopMode` å®šä¹‰ã€‚
```c++
typedef struct __CFRunLoopMode *CFRunLoopModeRef;

struct __CFRunLoopMode {
    CFRuntimeBase _base; // æ‰€æœ‰ CF "instances" éƒ½æ˜¯ä»è¿™ä¸ªç»“æ„å¼€å§‹çš„
    pthread_mutex_t _lock; // å¿…é¡»åœ¨é”å®šä¹‹å‰å°† run loop é”å®šï¼Œå³åŠ é”å‰éœ€è¦ run loop å¯¹è±¡å…ˆåŠ é”
    CFStringRef _name; // mode çš„ä¸€ä¸ªå­—ç¬¦ä¸²åç§°
    Boolean _stopped; // æ ‡è®°äº† run loop çš„è¿è¡ŒçŠ¶æ€ï¼Œå®é™…ä¸Šå¹¶éå¦‚æ­¤ç®€å•ï¼Œè¿˜æœ‰å‰é¢çš„ _per_run_dataã€‚
    char _padding[3]; 
    
    // _sources0ã€_sources1ã€_observersã€_timers éƒ½æ˜¯é›†åˆç±»å‹ï¼Œé‡Œé¢éƒ½æ˜¯ mode itemï¼Œå³ä¸€ä¸ª mode åŒ…å«å¤šä¸ª mode item
    CFMutableSetRef _sources0; // sources0 äº‹ä»¶é›†åˆï¼ˆä¹‹æ‰€ä»¥ç”¨é›†åˆæ˜¯ä¸ºäº†ä¿è¯æ¯ä¸ªå…ƒç´ å”¯ä¸€ï¼‰
    CFMutableSetRef _sources1; // sources1 äº‹ä»¶é›†åˆ
    
    CFMutableArrayRef _observers; // run loop observer è§‚å¯Ÿè€…æ•°ç»„
    CFMutableArrayRef _timers; // è®¡æ—¶å™¨æ•°ç»„
    
    CFMutableDictionaryRef _portToV1SourceMap; // å­˜å‚¨äº† Source1 çš„ port ä¸ source çš„å¯¹åº”å…³ç³»ï¼Œkey æ˜¯ mach_port_tï¼Œvalue æ˜¯ CFRunLoopSourceRef
    __CFPortSet _portSet; // ä¿å­˜æ‰€æœ‰éœ€è¦ç›‘å¬çš„ portï¼Œæ¯”å¦‚ _wakeUpPortï¼Œ_timerPortï¼ŒqueuePort éƒ½ä¿å­˜åœ¨è¿™ä¸ªé›†åˆä¸­
    CFIndex _observerMask; // æ·»åŠ  obsever æ—¶è®¾ç½® _observerMask ä¸º observer çš„ _activitiesï¼ˆCFRunLoopActivity çŠ¶æ€ï¼‰
    
    // DEPLOYMENT_TARGET_MACOSX è¡¨ç¤ºéƒ¨ç½²åœ¨ maxOS ä¸‹
    // #if DEPLOYMENT_TARGET_MACOSX
    //  #define USE_DISPATCH_SOURCE_FOR_TIMERS 1
    //  #define USE_MK_TIMER_TOO 1
    // #else
    //  #define USE_DISPATCH_SOURCE_FOR_TIMERS 0
    //  #define USE_MK_TIMER_TOO 1
    // #endif
    
    // åœ¨ maxOS ä¸‹ USE_DISPATCH_SOURCE_FOR_TIMERS å’Œ USE_MK_TIMER_TOO éƒ½ä¸ºçœŸã€‚
    
#if USE_DISPATCH_SOURCE_FOR_TIMERS
    // ä½¿ç”¨ dispatch_source è¡¨ç¤º timer
    dispatch_source_t _timerSource; // GCD è®¡æ—¶å™¨
    dispatch_queue_t _queue; // é˜Ÿåˆ—
    Boolean _timerFired; // set to true by the source when a timer has fired è®¡æ—¶å™¨è§¦å‘æ—¶ç”± source è®¾ç½®ä¸º trueï¼Œåœ¨ _timerSource çš„å›è°ƒäº‹ä»¶ä¸­å€¼ä¼šç½®ä¸º trueï¼Œå³æ ‡è®°ä¸º timer è¢«è§¦å‘ã€‚
    Boolean _dispatchTimerArmed;
#endif

#if USE_MK_TIMER_TOO
    // ä½¿ç”¨ MK è¡¨ç¤º timer 
    mach_port_t _timerPort; // MK_TIMER çš„ port
    Boolean _mkTimerArmed;
#endif

#if DEPLOYMENT_TARGET_WINDOWS
    DWORD _msgQMask;
    void (*_msgPump)(void);
#endif

    // timer è½¯ä¸´ç•Œç‚¹
    uint64_t _timerSoftDeadline; /* TSR */
    // timer ç¡¬ä¸´ç•Œç‚¹
    uint64_t _timerHardDeadline; /* TSR */
};
```

&emsp;`__CFRunLoopFindMode` å‡½æ•°æ ¹æ® modeName ä» rl çš„ \_modes ä¸­æ‰¾åˆ°å…¶å¯¹åº”çš„ CFRunLoopModeRefï¼Œå¦‚æœæ‰¾åˆ°çš„è¯åˆ™åŠ é”å¹¶è¿”å›ã€‚å¦‚æœæœªæ‰¾åˆ°ï¼Œå¹¶ä¸” create ä¸ºçœŸçš„è¯ï¼Œåˆ™æ–°å»º \_\_CFRunLoopMode åŠ é”å¹¶è¿”å›ï¼Œå¦‚æœ create ä¸ºå‡çš„è¯ï¼Œåˆ™è¿”å› NULLã€‚
```c++
static CFRunLoopModeRef __CFRunLoopFindMode(CFRunLoopRef rl, CFStringRef modeName, Boolean create) {
    // ç”¨äºæ£€æŸ¥ç»™å®šçš„è¿›ç¨‹æ˜¯å¦è¢«åˆ†å‰
    CHECK_FOR_FORK();
    
    // struct __CFRunLoopMode ç»“æ„ä½“æŒ‡é’ˆ
    CFRunLoopModeRef rlm;
    
    // åˆ›å»ºä¸€ä¸ª struct __CFRunLoopMode ç»“æ„ä½“å®ä¾‹ï¼Œ
    // å¹¶è°ƒç”¨ memset æŠŠ srlm å†…å­˜ç©ºé—´å…¨éƒ¨ç½®ä¸º 0ã€‚
    struct __CFRunLoopMode srlm;
    memset(&srlm, 0, sizeof(srlm));
    
    // __kCFRunLoopModeTypeID ç°åœ¨æ­£æ˜¯è¡¨ç¤º CFRunLoopMode ç±»ï¼Œå®é™…å€¼æ˜¯ run loop mode ç±»åœ¨å…¨å±€ç±»è¡¨ __CFRuntimeClassTable ä¸­çš„ç´¢å¼•ã€‚
    
    // å‰é¢ __CFRunLoopCreate å‡½æ•°å†…éƒ¨ä¼šè°ƒç”¨ CFRunLoopGetTypeID() å‡½æ•°ï¼Œ
    // å…¶å†…éƒ¨æ˜¯å…¨å±€æ‰§è¡Œä¸€æ¬¡åœ¨ CF è¿è¡Œæ—¶ä¸­æ³¨å†Œä¸¤ä¸ªæ–°ç±» run loopï¼ˆCFRunLoopï¼‰å’Œ run loop modeï¼ˆCFRunLoopModeï¼‰ï¼Œ
    // å…¶ä¸­ __kCFRunLoopModeTypeID = _CFRuntimeRegisterClass(&__CFRunLoopModeClass)ï¼Œé‚£ä¹ˆ __kCFRunLoopModeTypeID æ­¤æ—¶ä¾¿æ˜¯ run loop mode ç±»åœ¨å…¨å±€ç±»è¡¨ä¸­çš„ç´¢å¼•ã€‚
    //ï¼ˆ__CFRunLoopModeClass å¯ä»¥ç†è§£ä¸ºä¸€ä¸ªé™æ€å…¨å±€çš„ "ç±»å¯¹è±¡"ï¼ˆå®é™…å€¼æ˜¯ä¸€ä¸ªï¼‰ï¼Œ_CFRuntimeRegisterClass å‡½æ•°æ­£æ˜¯æŠŠå®ƒæ”¾è¿›ä¸€ä¸ªå…¨å±€çš„ __CFRuntimeClassTable ç±»è¡¨ä¸­ã€‚ï¼‰

    // æœ¬èº« srlm æ˜¯ä¸€ç‰‡ç©ºç™½å†…å­˜ï¼Œç°åœ¨ç›¸å½“äºæŠŠ srlm è®¾ç½®ä¸ºä¸€ä¸ª run loop mode ç±»çš„å¯¹è±¡ã€‚ 
    //ï¼ˆå®é™…å°±æ˜¯è®¾ç½® CFRuntimeBase çš„ _cfinfo æˆå‘˜å˜é‡ï¼Œsrlm é‡Œé¢ç›®å‰åŒ…å«çš„å†…å®¹å°±æ˜¯ run loop mode çš„ç±»ä¿¡æ¯ã€‚ï¼‰
    _CFRuntimeSetInstanceTypeIDAndIsa(&srlm, __kCFRunLoopModeTypeID);
    
    // æŠŠ srlm çš„ mode åç§°è®¾ç½®ä¸ºå…¥å‚ modeName
    srlm._name = modeName;
    
    // ä» rl->_modes å“ˆå¸Œè¡¨ä¸­æ‰¾ &srlm å¯¹åº”çš„ CFRunLoopModeRef
    rlm = (CFRunLoopModeRef)CFSetGetValue(rl->_modes, &srlm);
    
    // å¦‚æœæ‰¾åˆ°äº†åˆ™åŠ é”ï¼Œç„¶åè¿”å› rlmã€‚
    if (NULL != rlm) {
        __CFRunLoopModeLock(rlm);
        return rlm;
    }
    
    // å¦‚æœæ²¡æœ‰æ‰¾åˆ°ï¼Œå¹¶ä¸” create å€¼ä¸º falseï¼Œåˆ™è¡¨ç¤ºä¸è¿›è¡Œåˆ›å»ºï¼Œç›´æ¥è¿”å› NULLã€‚
    if (!create) {
        return NULL;
    }
    
    // åˆ›å»ºä¸€ä¸ª CFRunLoopMode å¯¹å¹¶è¿”å›å…¶åœ°å€
    rlm = (CFRunLoopModeRef)_CFRuntimeCreateInstance(kCFAllocatorSystemDefault, __kCFRunLoopModeTypeID, sizeof(struct __CFRunLoopMode) - sizeof(CFRuntimeBase), NULL);
    
    // å¦‚æœ rlm åˆ›å»ºå¤±è´¥ï¼Œåˆ™è¿”å› NULL
    if (NULL == rlm) {
        return NULL;
    }
    
    // åˆå§‹åŒ– rlm çš„ pthread_mutex_t _lock ä¸ºä¸€ä¸ªäº’æ–¥é€’å½’é”ã€‚
    //ï¼ˆ__CFRunLoopLockInit å†…éƒ¨ä½¿ç”¨çš„ PTHREAD_MUTEX_RECURSIVE è¡¨ç¤ºé€’å½’é”ï¼Œå…è®¸åŒä¸€ä¸ªçº¿ç¨‹å¯¹åŒä¸€é”åŠ é”å¤šæ¬¡ï¼Œä¸”éœ€è¦å¯¹åº”æ¬¡æ•°çš„è§£é”æ“ä½œï¼‰
    __CFRunLoopLockInit(&rlm->_lock);
    
    // åˆå§‹åŒ– _name
    rlm->_name = CFStringCreateCopy(kCFAllocatorSystemDefault, modeName);
    
    // ä¸‹é¢æ˜¯ä¸€ç»„æˆå‘˜å˜é‡çš„åˆå§‹èµ‹å€¼
    rlm->_stopped = false;
    rlm->_portToV1SourceMap = NULL;
    
    // _sources0ã€_sources1ã€_observersã€_timers åˆå§‹çŠ¶æ€éƒ½æ˜¯ç©ºçš„
    rlm->_sources0 = NULL;
    rlm->_sources1 = NULL;
    rlm->_observers = NULL;
    rlm->_timers = NULL;
    
    rlm->_observerMask = 0;
    rlm->_portSet = __CFPortSetAllocate(); // CFSet ç”³è¯·ç©ºé—´åˆå§‹åŒ–
    rlm->_timerSoftDeadline = UINT64_MAX;
    rlm->_timerHardDeadline = UINT64_MAX;
    
    // ret æ˜¯ä¸€ä¸ªä¸´æ—¶å˜é‡åˆå§‹å€¼æ˜¯ KERN_SUCCESSï¼Œç”¨æ¥è¡¨ç¤ºå‘ rlm->_portSet ä¸­æ·»åŠ  port æ—¶çš„ç»“æœï¼Œ
    // å¦‚æœæ·»åŠ å¤±è´¥çš„è¯ï¼Œä¼šç›´æ¥ CRASH 
    kern_return_t ret = KERN_SUCCESS;
    
#if USE_DISPATCH_SOURCE_FOR_TIMERS
    // macOS ä¸‹ï¼Œä½¿ç”¨ dispatch_source æ„é€  timer
    
    // _timerFired é¦–å…ˆèµ‹å€¼ä¸º falseï¼Œç„¶ååœ¨ timer çš„å›è°ƒå‡½æ•°æ‰§è¡Œçš„æ—¶å€™ä¼šèµ‹å€¼ä¸º true
    rlm->_timerFired = false;
    
    // é˜Ÿåˆ—
    rlm->_queue = _dispatch_runloop_root_queue_create_4CF("Run Loop Mode Queue", 0);
    
    // æ„å»º queuePortï¼Œå…¥å‚æ˜¯ mode çš„ _queue
    mach_port_t queuePort = _dispatch_runloop_root_queue_get_port_4CF(rlm->_queue);
    
    // å¦‚æœ queuePort ä¸º NULLï¼Œåˆ™ crashã€‚ï¼ˆæ— æ³•åˆ›å»ºè¿è¡Œå¾ªç¯æ¨¡å¼é˜Ÿåˆ—ç«¯å£ã€‚ï¼‰
    if (queuePort == MACH_PORT_NULL) CRASH("*** Unable to create run loop mode queue port. (%d) ***", -1);
    
    // æ„å»º dispatch_source ç±»å‹ä½¿ç”¨çš„æ˜¯ DISPATCH_SOURCE_TYPE_TIMERï¼Œè¡¨ç¤ºæ˜¯ä¸€ä¸ª timer
    rlm->_timerSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, rlm->_queue);
    
    // è¿™é‡Œä¸ºäº†åœ¨ä¸‹é¢çš„ block å†…éƒ¨ä¿®æ”¹ _timerFired çš„å€¼ï¼Œç”¨äº†ä¸€ä¸ª __block æŒ‡é’ˆå˜é‡ã€‚ï¼ˆè§‰çš„å¦‚æœè¿™é‡Œåªæ˜¯æ”¹å€¼ï¼Œæ„Ÿè§‰ç”¨æŒ‡é’ˆå°±å¤Ÿäº†å¯ä»¥ä¸ç”¨ __block ä¿®é¥°ï¼‰
    // å½“ _timerSourceï¼ˆè®¡æ—¶å™¨ï¼‰å›è°ƒæ—¶ä¼šæ‰§è¡Œè¿™ä¸ª blockã€‚
    __block Boolean *timerFiredPointer = &(rlm->_timerFired);
    dispatch_source_set_event_handler(rlm->_timerSource, ^{
        *timerFiredPointer = true;
    });
    
    // Set timer to far out there. The unique leeway makes this timer easy to spot in debug output.
    // å°†è®¡æ—¶å™¨è®¾ç½®åœ¨è¿œå¤„ã€‚ç‹¬ç‰¹çš„å›æ—‹ä½™åœ°ä½¿è¯¥è®¡æ—¶å™¨æ˜“äºå‘ç°è°ƒè¯•è¾“å‡ºã€‚ï¼ˆä» DISPATCH_TIME_FOREVER å¯åŠ¨ï¼ŒDISPATCH_TIME_FOREVER ä¸ºæ—¶é—´é—´éš”ï¼‰
    _dispatch_source_set_runloop_timer_4CF(rlm->_timerSource, DISPATCH_TIME_FOREVER, DISPATCH_TIME_FOREVER, 321);
    // å¯åŠ¨
    dispatch_resume(rlm->_timerSource);
    
    // æŠŠè¿è¡Œå¾ªç¯æ¨¡å¼é˜Ÿåˆ—ç«¯å£ queuePort æ·»åŠ åˆ° rlm çš„ _portSetï¼ˆç«¯å£é›†åˆï¼‰ä¸­ã€‚
    ret = __CFPortSetInsert(queuePort, rlm->_portSet);
    // å¦‚æœæ·»åŠ å¤±è´¥åˆ™ crashã€‚ï¼ˆæ— æ³•å°†è®¡æ—¶å™¨ç«¯å£æ’å…¥ç«¯å£é›†ä¸­ã€‚ï¼‰
    if (KERN_SUCCESS != ret) CRASH("*** Unable to insert timer port into port set. (%d) ***", ret);
#endif

#if USE_MK_TIMER_TOO
    // mk æ„é€  timer
    
    // æ„å»º timer ç«¯å£
    rlm->_timerPort = mk_timer_create();
    // åŒæ ·æŠŠ rlm çš„ _timerPort æ·»åŠ åˆ° rlm çš„ _portSetï¼ˆç«¯å£é›†åˆï¼‰ä¸­ã€‚
    ret = __CFPortSetInsert(rlm->_timerPort, rlm->_portSet);
    // å¦‚æœæ·»åŠ å¤±è´¥åˆ™ crashã€‚ï¼ˆæ— æ³•å°†è®¡æ—¶å™¨ç«¯å£æ’å…¥ç«¯å£é›†ä¸­ã€‚ï¼‰
    if (KERN_SUCCESS != ret) CRASH("*** Unable to insert timer port into port set. (%d) ***", ret);
#endif
    
    // ç„¶åè¿™é‡ŒæŠŠ rl çš„ _wakeUpPort ä¹Ÿæ·»åŠ åˆ° rlm çš„ _portSetï¼ˆç«¯å£é›†åˆï¼‰ä¸­ã€‚
    //ï¼ˆè¿™é‡Œè¦ç‰¹åˆ«æ³¨æ„ä¸€ä¸‹ï¼Œrun loop çš„ _wakeUpPort ä¼šè¢«æ’å…¥åˆ°æ‰€æœ‰ mode çš„ _portSet ä¸­ã€‚ï¼‰
    ret = __CFPortSetInsert(rl->_wakeUpPort, rlm->_portSet);
    // å¦‚æœæ·»åŠ å¤±è´¥åˆ™ crashã€‚ï¼ˆæ— æ³•å°†å”¤é†’ç«¯å£æ’å…¥ç«¯å£é›†ä¸­ã€‚ï¼‰
    if (KERN_SUCCESS != ret) CRASH("*** Unable to insert wake up port into port set. (%d) ***", ret);
    
#if DEPLOYMENT_TARGET_WINDOWS
    rlm->_msgQMask = 0;
    rlm->_msgPump = NULL;
#endif

    // è¿™é‡ŒæŠŠ rlm æ·»åŠ åˆ° rl çš„ _modes ä¸­ï¼Œ
    //ï¼ˆæœ¬è´¨æ˜¯æŠŠ rlm æ·»åŠ åˆ° _modes å“ˆå¸Œè¡¨ä¸­ï¼‰
    CFSetAddValue(rl->_modes, rlm);
    
    // é‡Šæ”¾ï¼Œrlm å·²è¢« rl->_modes æŒæœ‰ï¼Œå¹¶ä¸ä¼šè¢«é”€æ¯åªæ˜¯å‡å°‘å¼•ç”¨è®¡æ•°
    CFRelease(rlm);
    
    // åŠ é”ï¼Œç„¶åè¿”å› rlm
    __CFRunLoopModeLock(rlm);    /* return mode locked */
    return rlm;
}
```
&emsp;å…¶ä¸­ `ret = __CFPortSetInsert(rl->_wakeUpPort, rlm->_portSet)` ä¼šæŠŠ run loop å¯¹è±¡çš„ `_wakeUpPort` æ·»åŠ åˆ°æ¯ä¸ª run loop mode å¯¹è±¡çš„ `_portSet` ç«¯å£é›†åˆé‡Œã€‚å³å½“ä¸€ä¸ª run loop æœ‰å¤šä¸ª run loop mode æ—¶ï¼Œé‚£ä¹ˆæ¯ä¸ª run loop mode éƒ½ä¼šæœ‰ run loop çš„ `_wakeUpPort`ã€‚

&emsp;åœ¨ macOS ä¸‹ run loop mode çš„ `_timerSource` çš„è®¡æ—¶å™¨çš„å›è°ƒäº‹ä»¶å†…éƒ¨ä¼šæŠŠ run loop mode çš„ `_timerFired` å­—æ®µç½®ä¸º trueï¼Œè¡¨ç¤ºè®¡æ—¶å™¨è¢«è§¦å‘ã€‚

&emsp;run loop mode åˆ›å»ºå¥½äº†ï¼Œçœ‹åˆ° source/timer/observer ä¸‰è€…å¯¹åº”çš„ `_sources0`ã€`_sources1`ã€`_observers`ã€`_timers` å››ä¸ªå­—æ®µåˆå§‹çŠ¶æ€éƒ½æ˜¯ç©ºï¼Œéœ€è¦æˆ‘ä»¬è‡ªå·±æ·»åŠ  run loop mode itemï¼Œ

## ğŸ‰ğŸ‰ğŸ‰ æœªå®Œå¾…ç»­...
