# æ±‡ç¼–ç¬¬äºŒç¯‡

&emsp;å¤´æ–‡ä»¶æ‘˜å–å‡ºæ¥å¤‡ç”¨

```c++
#import <i386/_types.h>
#import <i386/_mcontext.h>
#include <mach/i386/_structs.h>
#include <mach/arm/_structs.h>
#import <mach/thread_act.h>
```

&emsp;ææ¸…æ¥šå‡½æ•°è°ƒç”¨æ ˆæ˜¯æ€ä¹ˆè·å–çš„ï¼Œå°±å¿…é¡»äº†è§£è¿™ä¸ªæœºåˆ¶ã€‚

&emsp;å‡½æ•°è°ƒç”¨æ ˆæœ‰ä¸ªå¤§è‡´çš„å°è±¡ï¼Œæ ˆå¸§å›¾ï¼š

&emsp;é¦–å…ˆäº†è§£å¯„å­˜å™¨ï¼ŒARM64 æœ‰ 34 ä¸ªå¯„å­˜å™¨ï¼Œå…¶ä¸­ 31 ä¸ªé€šç”¨å¯„å­˜å™¨ã€SPã€PCã€CPSRã€‚è°ƒç”¨çº¦å®šæŒ‡å®šä»–ä»¬å…¶ä¸­çš„ä¸€äº›å¯„å­˜å™¨æœ‰ç‰¹æ®Šçš„ç”¨é€”ï¼Œä¾‹å¦‚ï¼š

&emsp;x0-x28 é€šç”¨å¯„å­˜å™¨ã€‚

&emsp;x29(FP) é€šå¸¸ç”¨ä½œå¸§æŒ‡é’ˆ fp (frame pointer å¯„å­˜å™¨) ï¼Œæ ˆå¸§åŸºå€å¯„å­˜å™¨ï¼ŒæŒ‡å‘å½“å‰å‡½æ•°æ ˆå¸§çš„æ ˆåº•ã€‚

&emsp;x30(LR) é“¾æ¥å¯„å­˜å™¨ï¼ˆlink registerï¼‰ã€‚å®ƒä¿å­˜äº†å½“ç›®å‰å‡½æ•°è¿”å›æ—¶ä¸‹ä¸€ä¸ªå‡½æ•°çš„åœ°å€ã€‚

&emsp;SP æ ˆæŒ‡é’ˆï¼ˆstack pointerï¼‰å­˜æ”¾æŒ‡å‘æ ˆé¡¶çš„æŒ‡é’ˆï¼Œä½¿ç”¨ SP/WSP æ¥è¿›è¡Œå¯¹ SP å¯„å­˜å™¨çš„è®¿é—®ã€‚

&emsp;PC ç¨‹åºè®¡æ•°å™¨ï¼ˆprogram counterï¼‰å®ƒå­˜æ”¾äº†å½“å‰æ‰§è¡ŒæŒ‡ä»¤çš„åœ°å€ï¼Œåœ¨æ¯ä¸ªæŒ‡ä»¤æ‰§è¡Œå®Œæˆåä¼šè‡ªåŠ¨å¢åŠ ã€‚

&emsp;CPSR çŠ¶æ€å¯„å­˜å™¨

```c++
/* Get the current mach thread ID.
 * mach_thread_self() receives a send right for the thread port which needs to be deallocated to balance the reference count. This function takes care of all of that for you.
 *
 * @return The current thread ID.
 */
KSThread ksthread_self(void);

KSThread ksthread_self()
{
    thread_t thread_self = mach_thread_self();
    mach_port_deallocate(mach_task_self(), thread_self);
    return (KSThread)thread_self;
}
```

&emsp;å¯ä»¥çœ‹åˆ°å…¶å®ƒçš„å¯„å­˜å™¨ä¹Ÿè¿˜æœ‰ä¸€äº›ä¸ç›¸å¹²çš„ä¿¡æ¯ï¼Œè¯´æ˜å¯„å­˜å™¨ä¸ä¼šæ¯ä¸ªå †æ ˆæ‰§è¡Œå®Œéƒ½å…¨éƒ¨æ¸…ç†ï¼Œä¸€èˆ¬åªéœ€è¦ä½¿ç”¨æ—¶å€™æ­£ç¡®å–å€¼å³å¯ã€‚

&emsp;å› æ­¤å¯çŸ¥è°ƒç”¨é“¾å°±æ˜¯ä¸€ä¸ªé“¾è¡¨ç»“æ„ã€‚å¸§çš„åœ°å€å°±æ˜¯æ ˆåŸºå€å¯„å­˜å™¨çš„åœ°å€ã€‚è€Œæ¯ä¸ªå¸§çš„è¿”å›åœ°å€æŒ‡é’ˆå°±æ˜¯ä¸Šä¸€ä¸ªæ ˆçš„åŸºå€å¯„å­˜å™¨ã€‚

&emsp;å†…æ ¸ä¸ºäº†èƒ½åœ¨å‡ºç°å¼‚å¸¸æ—¶å›æº¯è°ƒç”¨è¿‡ç¨‹ï¼Œä¼šæŠŠæ•´ä¸ªè°ƒç”¨é“¾çš„å †æ ˆä¿å­˜ä¸‹æ¥ã€‚

&emsp;å…¶ä¸­ä¹‹ä¸€é¿å…è°ƒç”¨æ ˆçš„å¼€é”€ï¼Œå› æ­¤ runtime æŠŠå®ƒä»¥çº¯æ±‡ç¼–çš„å½¢å¼å®ç°ï¼Œç›¸å½“äºå†…åµŒåœ¨å½“å‰çš„è°ƒç”¨æ ˆé‡Œæ‰§è¡Œï¼Œå³å®ƒå…±ç”¨çš„æ˜¯å½“å‰è°ƒç”¨æ ˆçš„ç©ºé—´ï¼Œè€Œä¸éœ€è¦æ–°å¼€è¾Ÿä¸€ä¸ªè°ƒç”¨æ ˆã€‚




## ä» å¸¸è§çš„æ±‡ç¼–è¯­æ³• ä¸€èŠ‚ç»§ç»­å‘ä¸‹å­¦ä¹ ....

## å‚è€ƒé“¾æ¥
**å‚è€ƒé“¾æ¥:ğŸ”—**
+ [iOSé€†å‘ ï¼šåˆè¯†æ±‡ç¼–](https://zhuanlan.zhihu.com/p/369071456)
+ [æ·±å…¥iOSç³»ç»Ÿåº•å±‚ä¹‹ç¨‹åºä¸­çš„æ±‡ç¼–ä»£ç ](https://www.jianshu.com/p/f649285668cd)
+ [ios-crash-dump-analysis-book](https://github.com/faisalmemon/ios-crash-dump-analysis-book)
+ [ios-crash-dump-analysis-book/zh](https://faisalmemon.github.io/ios-crash-dump-analysis-book/zh/)
+ [iOS Crash/å´©æºƒ/å¼‚å¸¸ å †æ ˆè·å–](https://www.jianshu.com/p/8ece78d71b3d)
+ [iOSå †æ ˆä¿¡æ¯è§£æï¼ˆå‡½æ•°åœ°å€ä¸ç¬¦å·å…³è”ï¼‰](https://www.jianshu.com/p/df5b08330afd)
+ [Machå¾®å†…æ ¸ç®€ä»‹](https://wangkejie.com/iOS/kernelarchitecture/mach.html)
+ [Mach Overview](https://developer.apple.com/library/archive/documentation/Darwin/Conceptual/KernelProgramming/Mach/Mach.html)
+ [è°ˆè°ˆiOSå †æ ˆé‚£äº›äº‹](https://joey520.github.io/2020/03/15/è°ˆè°ˆmsgSendä¸ºä»€ä¹ˆä¸ä¼šå‡ºç°åœ¨å †æ ˆä¸­/)
+ [iOS çš„å´©æºƒæ•è·-å †æ ˆç¬¦å·åŒ–-å´©æºƒåˆ†æ](https://www.jianshu.com/p/302ed945e9cf)
+ [å‡½æ•°æ ˆçš„å®ç°åŸç†](https://segmentfault.com/a/1190000017151354)
+ [å‡½æ•°è°ƒç”¨æ ˆ å‰–æï¼‹å›¾è§£[è½¬]](https://www.jianshu.com/p/78e01e513120)
+ [[è½¬è½½]Cè¯­è¨€å‡½æ•°è°ƒç”¨æ ˆ](https://www.jianshu.com/p/c89d243b8276)
+ [BSBackTraceloggerå­¦ä¹ ç¬”è®°](https://juejin.cn/post/6910791727670362125)
+ [å¦‚ä½•å®šä½Obj-Cé‡æŒ‡é’ˆéšæœºCrash(ä¸€)ï¼šå…ˆæé«˜é‡æŒ‡é’ˆCrashç‡](https://cloud.tencent.com/developer/article/1070505)
+ [å¦‚ä½•å®šä½Obj-Cé‡æŒ‡é’ˆéšæœºCrash(äºŒ)ï¼šè®©éå¿…ç°Crashå˜æˆå¿…ç°](https://cloud.tencent.com/developer/article/1070512)
+ [å¦‚ä½•å®šä½Obj-Cé‡æŒ‡é’ˆéšæœºCrash(ä¸‰)ï¼šå¦‚ä½•è®©Crashè‡ªæŠ¥å®¶é—¨](https://cloud.tencent.com/developer/article/1070528)
+ [iOS/OSX Crashï¼šæ•æ‰å¼‚å¸¸](https://zhuanlan.zhihu.com/p/271282052)
+ [æ±‡ç¼–è¿‡ç¨‹è°ƒç”¨æ˜¯æ€æ ·æ“ä½œæ ˆçš„ï¼Ÿ](https://www.zhihu.com/question/49410551/answer/115870825)
